# 1 "test.cu"
# 61 "/usr/local/cuda/bin/..//include/device_types.h"
#if 0
# 61
enum cudaRoundMode { 
# 63
cudaRoundNearest, 
# 64
cudaRoundZero, 
# 65
cudaRoundPosInf, 
# 66
cudaRoundMinInf
# 67
}; 
#endif
# 149 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h" 3
typedef long ptrdiff_t; 
# 211 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h" 3
typedef unsigned long size_t; 
#include "crt/host_runtime.h"
# 124 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 124
enum cudaError { 
# 131
cudaSuccess, 
# 137
cudaErrorMissingConfiguration, 
# 143
cudaErrorMemoryAllocation, 
# 149
cudaErrorInitializationError, 
# 159 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorLaunchFailure, 
# 168 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorPriorLaunchFailure, 
# 178 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorLaunchTimeout, 
# 187 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorLaunchOutOfResources, 
# 193
cudaErrorInvalidDeviceFunction, 
# 202 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorInvalidConfiguration, 
# 208
cudaErrorInvalidDevice, 
# 214
cudaErrorInvalidValue, 
# 220
cudaErrorInvalidPitchValue, 
# 226
cudaErrorInvalidSymbol, 
# 231
cudaErrorMapBufferObjectFailed, 
# 236
cudaErrorUnmapBufferObjectFailed, 
# 242
cudaErrorInvalidHostPointer, 
# 248
cudaErrorInvalidDevicePointer, 
# 254
cudaErrorInvalidTexture, 
# 260
cudaErrorInvalidTextureBinding, 
# 267
cudaErrorInvalidChannelDescriptor, 
# 273
cudaErrorInvalidMemcpyDirection, 
# 283 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorAddressOfConstant, 
# 292 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorTextureFetchFailed, 
# 301 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorTextureNotBound, 
# 310 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorSynchronizationError, 
# 316
cudaErrorInvalidFilterSetting, 
# 322
cudaErrorInvalidNormSetting, 
# 330
cudaErrorMixedDeviceExecution, 
# 337
cudaErrorCudartUnloading, 
# 342
cudaErrorUnknown, 
# 350
cudaErrorNotYetImplemented, 
# 359 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorMemoryValueTooLarge, 
# 366
cudaErrorInvalidResourceHandle, 
# 374
cudaErrorNotReady, 
# 381
cudaErrorInsufficientDriver, 
# 394 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorSetOnActiveProcess, 
# 400
cudaErrorInvalidSurface, 
# 406
cudaErrorNoDevice, 
# 412
cudaErrorECCUncorrectable, 
# 417
cudaErrorSharedObjectSymbolNotFound, 
# 422
cudaErrorSharedObjectInitFailed, 
# 428
cudaErrorUnsupportedLimit, 
# 434
cudaErrorDuplicateVariableName, 
# 440
cudaErrorDuplicateTextureName, 
# 446
cudaErrorDuplicateSurfaceName, 
# 456 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorDevicesUnavailable, 
# 461
cudaErrorInvalidKernelImage, 
# 469
cudaErrorNoKernelImageForDevice, 
# 482 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorIncompatibleDriverContext, 
# 489
cudaErrorPeerAccessAlreadyEnabled, 
# 496
cudaErrorPeerAccessNotEnabled, 
# 502
cudaErrorDeviceAlreadyInUse = 54, 
# 509
cudaErrorProfilerDisabled, 
# 517
cudaErrorProfilerNotInitialized, 
# 524
cudaErrorProfilerAlreadyStarted, 
# 531
cudaErrorProfilerAlreadyStopped, 
# 539
cudaErrorAssert, 
# 546
cudaErrorTooManyPeers, 
# 552
cudaErrorHostMemoryAlreadyRegistered, 
# 558
cudaErrorHostMemoryNotRegistered, 
# 563
cudaErrorOperatingSystem, 
# 569
cudaErrorPeerAccessUnsupported, 
# 576
cudaErrorLaunchMaxDepthExceeded, 
# 584
cudaErrorLaunchFileScopedTex, 
# 592
cudaErrorLaunchFileScopedSurf, 
# 607 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorSyncDepthExceeded, 
# 619 "/usr/local/cuda/bin/..//include/driver_types.h"
cudaErrorLaunchPendingCountExceeded, 
# 624
cudaErrorNotPermitted, 
# 630
cudaErrorNotSupported, 
# 635
cudaErrorStartupFailure = 127, 
# 643
cudaErrorApiFailureBase = 10000
# 644
}; 
#endif
# 649 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 649
enum cudaChannelFormatKind { 
# 651
cudaChannelFormatKindSigned, 
# 652
cudaChannelFormatKindUnsigned, 
# 653
cudaChannelFormatKindFloat, 
# 654
cudaChannelFormatKindNone
# 655
}; 
#endif
# 660 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 660
struct cudaChannelFormatDesc { 
# 662
int x; 
# 663
int y; 
# 664
int z; 
# 665
int w; 
# 666
cudaChannelFormatKind f; 
# 667
}; 
#endif
# 672 "/usr/local/cuda/bin/..//include/driver_types.h"
typedef struct cudaArray *cudaArray_t; 
# 677
typedef const cudaArray *cudaArray_const_t; 
# 679
struct cudaArray; 
# 684
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
# 689
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
# 691
struct cudaMipmappedArray; 
# 696
#if 0
# 696
enum cudaMemoryType { 
# 698
cudaMemoryTypeHost = 1, 
# 699
cudaMemoryTypeDevice
# 700
}; 
#endif
# 705 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 705
enum cudaMemcpyKind { 
# 707
cudaMemcpyHostToHost, 
# 708
cudaMemcpyHostToDevice, 
# 709
cudaMemcpyDeviceToHost, 
# 710
cudaMemcpyDeviceToDevice, 
# 711
cudaMemcpyDefault
# 712
}; 
#endif
# 718 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 718
struct cudaPitchedPtr { 
# 720
void *ptr; 
# 721
size_t pitch; 
# 722
size_t xsize; 
# 723
size_t ysize; 
# 724
}; 
#endif
# 730 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 730
struct cudaExtent { 
# 732
size_t width; 
# 733
size_t height; 
# 734
size_t depth; 
# 735
}; 
#endif
# 741 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 741
struct cudaPos { 
# 743
size_t x; 
# 744
size_t y; 
# 745
size_t z; 
# 746
}; 
#endif
# 751 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 751
struct cudaMemcpy3DParms { 
# 753
cudaArray_t srcArray; 
# 754
cudaPos srcPos; 
# 755
cudaPitchedPtr srcPtr; 
# 757
cudaArray_t dstArray; 
# 758
cudaPos dstPos; 
# 759
cudaPitchedPtr dstPtr; 
# 761
cudaExtent extent; 
# 762
cudaMemcpyKind kind; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 763
}; 
#endif
# 768 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 768
struct cudaMemcpy3DPeerParms { 
# 770
cudaArray_t srcArray; 
# 771
cudaPos srcPos; 
# 772
cudaPitchedPtr srcPtr; 
# 773
int srcDevice; 
# 775
cudaArray_t dstArray; 
# 776
cudaPos dstPos; 
# 777
cudaPitchedPtr dstPtr; 
# 778
int dstDevice; 
# 780
cudaExtent extent; 
# 781
}; 
#endif
# 786 "/usr/local/cuda/bin/..//include/driver_types.h"
struct cudaGraphicsResource; 
# 791
#if 0
# 791
enum cudaGraphicsRegisterFlags { 
# 793
cudaGraphicsRegisterFlagsNone, 
# 794
cudaGraphicsRegisterFlagsReadOnly, 
# 795
cudaGraphicsRegisterFlagsWriteDiscard, 
# 796
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
# 797
cudaGraphicsRegisterFlagsTextureGather = 8
# 798
}; 
#endif
# 803 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 803
enum cudaGraphicsMapFlags { 
# 805
cudaGraphicsMapFlagsNone, 
# 806
cudaGraphicsMapFlagsReadOnly, 
# 807
cudaGraphicsMapFlagsWriteDiscard
# 808
}; 
#endif
# 813 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 813
enum cudaGraphicsCubeFace { 
# 815
cudaGraphicsCubeFacePositiveX, 
# 816
cudaGraphicsCubeFaceNegativeX, 
# 817
cudaGraphicsCubeFacePositiveY, 
# 818
cudaGraphicsCubeFaceNegativeY, 
# 819
cudaGraphicsCubeFacePositiveZ, 
# 820
cudaGraphicsCubeFaceNegativeZ
# 821
}; 
#endif
# 826 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 826
enum cudaResourceType { 
# 828
cudaResourceTypeArray, 
# 829
cudaResourceTypeMipmappedArray, 
# 830
cudaResourceTypeLinear, 
# 831
cudaResourceTypePitch2D
# 832
}; 
#endif
# 837 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 837
enum cudaResourceViewFormat { 
# 839
cudaResViewFormatNone, 
# 840
cudaResViewFormatUnsignedChar1, 
# 841
cudaResViewFormatUnsignedChar2, 
# 842
cudaResViewFormatUnsignedChar4, 
# 843
cudaResViewFormatSignedChar1, 
# 844
cudaResViewFormatSignedChar2, 
# 845
cudaResViewFormatSignedChar4, 
# 846
cudaResViewFormatUnsignedShort1, 
# 847
cudaResViewFormatUnsignedShort2, 
# 848
cudaResViewFormatUnsignedShort4, 
# 849
cudaResViewFormatSignedShort1, 
# 850
cudaResViewFormatSignedShort2, 
# 851
cudaResViewFormatSignedShort4, 
# 852
cudaResViewFormatUnsignedInt1, 
# 853
cudaResViewFormatUnsignedInt2, 
# 854
cudaResViewFormatUnsignedInt4, 
# 855
cudaResViewFormatSignedInt1, 
# 856
cudaResViewFormatSignedInt2, 
# 857
cudaResViewFormatSignedInt4, 
# 858
cudaResViewFormatHalf1, 
# 859
cudaResViewFormatHalf2, 
# 860
cudaResViewFormatHalf4, 
# 861
cudaResViewFormatFloat1, 
# 862
cudaResViewFormatFloat2, 
# 863
cudaResViewFormatFloat4, 
# 864
cudaResViewFormatUnsignedBlockCompressed1, 
# 865
cudaResViewFormatUnsignedBlockCompressed2, 
# 866
cudaResViewFormatUnsignedBlockCompressed3, 
# 867
cudaResViewFormatUnsignedBlockCompressed4, 
# 868
cudaResViewFormatSignedBlockCompressed4, 
# 869
cudaResViewFormatUnsignedBlockCompressed5, 
# 870
cudaResViewFormatSignedBlockCompressed5, 
# 871
cudaResViewFormatUnsignedBlockCompressed6H, 
# 872
cudaResViewFormatSignedBlockCompressed6H, 
# 873
cudaResViewFormatUnsignedBlockCompressed7
# 874
}; 
#endif
# 879 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 879
struct cudaResourceDesc { 
# 880
cudaResourceType resType; 
# 882
union { 
# 883
struct { 
# 884
cudaArray_t array; 
# 885
} array; 
# 886
struct { 
# 887
cudaMipmappedArray_t mipmap; 
# 888
} mipmap; 
# 889
struct { 
# 890
void *devPtr; 
# 891
cudaChannelFormatDesc desc; 
# 892
size_t sizeInBytes; 
# 893
} linear; 
# 894
struct { 
# 895
void *devPtr; 
# 896
cudaChannelFormatDesc desc; 
# 897
size_t width; 
# 898
size_t height; 
# 899
size_t pitchInBytes; 
# 900
} pitch2D; 
# 901
} res; 
# 902
}; 
#endif
# 907 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 907
struct cudaResourceViewDesc { 
# 909
cudaResourceViewFormat format; 
# 910
size_t width; 
# 911
size_t height; 
# 912
size_t depth; 
# 913
unsigned firstMipmapLevel; 
# 914
unsigned lastMipmapLevel; 
# 915
unsigned firstLayer; 
# 916
unsigned lastLayer; 
# 917
}; 
#endif
# 922 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 922
struct cudaPointerAttributes { 
# 928
cudaMemoryType memoryType; 
# 939 "/usr/local/cuda/bin/..//include/driver_types.h"
int device; 
# 945
void *devicePointer; 
# 951
void *hostPointer; 
# 952
}; 
#endif
# 957 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 957
struct cudaFuncAttributes { 
# 964
size_t sharedSizeBytes; 
# 970
size_t constSizeBytes; 
# 975
size_t localSizeBytes; 
# 982
int maxThreadsPerBlock; 
# 987
int numRegs; 
# 994
int ptxVersion; 
# 1001
int binaryVersion; 
# 1002
}; 
#endif
# 1007 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 1007
enum cudaFuncCache { 
# 1009
cudaFuncCachePreferNone, 
# 1010
cudaFuncCachePreferShared, 
# 1011
cudaFuncCachePreferL1, 
# 1012
cudaFuncCachePreferEqual
# 1013
}; 
#endif
# 1019 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 1019
enum cudaSharedMemConfig { 
# 1021
cudaSharedMemBankSizeDefault, 
# 1022
cudaSharedMemBankSizeFourByte, 
# 1023
cudaSharedMemBankSizeEightByte
# 1024
}; 
#endif
# 1029 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 1029
enum cudaComputeMode { 
# 1031
cudaComputeModeDefault, 
# 1032
cudaComputeModeExclusive, 
# 1033
cudaComputeModeProhibited, 
# 1034
cudaComputeModeExclusiveProcess
# 1035
}; 
#endif
# 1040 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 1040
enum cudaLimit { 
# 1042
cudaLimitStackSize, 
# 1043
cudaLimitPrintfFifoSize, 
# 1044
cudaLimitMallocHeapSize, 
# 1045
cudaLimitDevRuntimeSyncDepth, 
# 1046
cudaLimitDevRuntimePendingLaunchCount
# 1047
}; 
#endif
# 1052 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 1052
enum cudaOutputMode { 
# 1054
cudaKeyValuePair, 
# 1055
cudaCSV
# 1056
}; 
#endif
# 1061 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 1061
enum cudaDeviceAttr { 
# 1063
cudaDevAttrMaxThreadsPerBlock = 1, 
# 1064
cudaDevAttrMaxBlockDimX, 
# 1065
cudaDevAttrMaxBlockDimY, 
# 1066
cudaDevAttrMaxBlockDimZ, 
# 1067
cudaDevAttrMaxGridDimX, 
# 1068
cudaDevAttrMaxGridDimY, 
# 1069
cudaDevAttrMaxGridDimZ, 
# 1070
cudaDevAttrMaxSharedMemoryPerBlock, 
# 1071
cudaDevAttrTotalConstantMemory, 
# 1072
cudaDevAttrWarpSize, 
# 1073
cudaDevAttrMaxPitch, 
# 1074
cudaDevAttrMaxRegistersPerBlock, 
# 1075
cudaDevAttrClockRate, 
# 1076
cudaDevAttrTextureAlignment, 
# 1077
cudaDevAttrGpuOverlap, 
# 1078
cudaDevAttrMultiProcessorCount, 
# 1079
cudaDevAttrKernelExecTimeout, 
# 1080
cudaDevAttrIntegrated, 
# 1081
cudaDevAttrCanMapHostMemory, 
# 1082
cudaDevAttrComputeMode, 
# 1083
cudaDevAttrMaxTexture1DWidth, 
# 1084
cudaDevAttrMaxTexture2DWidth, 
# 1085
cudaDevAttrMaxTexture2DHeight, 
# 1086
cudaDevAttrMaxTexture3DWidth, 
# 1087
cudaDevAttrMaxTexture3DHeight, 
# 1088
cudaDevAttrMaxTexture3DDepth, 
# 1089
cudaDevAttrMaxTexture2DLayeredWidth, 
# 1090
cudaDevAttrMaxTexture2DLayeredHeight, 
# 1091
cudaDevAttrMaxTexture2DLayeredLayers, 
# 1092
cudaDevAttrSurfaceAlignment, 
# 1093
cudaDevAttrConcurrentKernels, 
# 1094
cudaDevAttrEccEnabled, 
# 1095
cudaDevAttrPciBusId, 
# 1096
cudaDevAttrPciDeviceId, 
# 1097
cudaDevAttrTccDriver, 
# 1098
cudaDevAttrMemoryClockRate, 
# 1099
cudaDevAttrGlobalMemoryBusWidth, 
# 1100
cudaDevAttrL2CacheSize, 
# 1101
cudaDevAttrMaxThreadsPerMultiProcessor, 
# 1102
cudaDevAttrAsyncEngineCount, 
# 1103
cudaDevAttrUnifiedAddressing, 
# 1104
cudaDevAttrMaxTexture1DLayeredWidth, 
# 1105
cudaDevAttrMaxTexture1DLayeredLayers, 
# 1106
cudaDevAttrMaxTexture2DGatherWidth = 45, 
# 1107
cudaDevAttrMaxTexture2DGatherHeight, 
# 1108
cudaDevAttrMaxTexture3DWidthAlt, 
# 1109
cudaDevAttrMaxTexture3DHeightAlt, 
# 1110
cudaDevAttrMaxTexture3DDepthAlt, 
# 1111
cudaDevAttrPciDomainId, 
# 1112
cudaDevAttrTexturePitchAlignment, 
# 1113
cudaDevAttrMaxTextureCubemapWidth, 
# 1114
cudaDevAttrMaxTextureCubemapLayeredWidth, 
# 1115
cudaDevAttrMaxTextureCubemapLayeredLayers, 
# 1116
cudaDevAttrMaxSurface1DWidth, 
# 1117
cudaDevAttrMaxSurface2DWidth, 
# 1118
cudaDevAttrMaxSurface2DHeight, 
# 1119
cudaDevAttrMaxSurface3DWidth, 
# 1120
cudaDevAttrMaxSurface3DHeight, 
# 1121
cudaDevAttrMaxSurface3DDepth, 
# 1122
cudaDevAttrMaxSurface1DLayeredWidth, 
# 1123
cudaDevAttrMaxSurface1DLayeredLayers, 
# 1124
cudaDevAttrMaxSurface2DLayeredWidth, 
# 1125
cudaDevAttrMaxSurface2DLayeredHeight, 
# 1126
cudaDevAttrMaxSurface2DLayeredLayers, 
# 1127
cudaDevAttrMaxSurfaceCubemapWidth, 
# 1128
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
# 1129
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
# 1130
cudaDevAttrMaxTexture1DLinearWidth, 
# 1131
cudaDevAttrMaxTexture2DLinearWidth, 
# 1132
cudaDevAttrMaxTexture2DLinearHeight, 
# 1133
cudaDevAttrMaxTexture2DLinearPitch, 
# 1134
cudaDevAttrMaxTexture2DMipmappedWidth, 
# 1135
cudaDevAttrMaxTexture2DMipmappedHeight, 
# 1136
cudaDevAttrComputeCapabilityMajor, 
# 1137
cudaDevAttrComputeCapabilityMinor, 
# 1138
cudaDevAttrMaxTexture1DMipmappedWidth, 
# 1139
cudaDevAttrStreamPrioritiesSupported
# 1140
}; 
#endif
# 1145 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
# 1145
struct cudaDeviceProp { 
# 1147
char name[256]; 
# 1148
size_t totalGlobalMem; 
# 1149
size_t sharedMemPerBlock; 
# 1150
int regsPerBlock; 
# 1151
int warpSize; 
# 1152
size_t memPitch; 
# 1153
int maxThreadsPerBlock; 
# 1154
int maxThreadsDim[3]; 
# 1155
int maxGridSize[3]; 
# 1156
int clockRate; 
# 1157
size_t totalConstMem; 
# 1158
int major; 
# 1159
int minor; 
# 1160
size_t textureAlignment; 
# 1161
size_t texturePitchAlignment; 
# 1162
int deviceOverlap; 
# 1163
int multiProcessorCount; 
# 1164
int kernelExecTimeoutEnabled; 
# 1165
int integrated; 
# 1166
int canMapHostMemory; 
# 1167
int computeMode; 
# 1168
int maxTexture1D; 
# 1169
int maxTexture1DMipmap; 
# 1170
int maxTexture1DLinear; 
# 1171
int maxTexture2D[2]; 
# 1172
int maxTexture2DMipmap[2]; 
# 1173
int maxTexture2DLinear[3]; 
# 1174
int maxTexture2DGather[2]; 
# 1175
int maxTexture3D[3]; 
# 1176
int maxTexture3DAlt[3]; 
# 1177
int maxTextureCubemap; 
# 1178
int maxTexture1DLayered[2]; 
# 1179
int maxTexture2DLayered[3]; 
# 1180
int maxTextureCubemapLayered[2]; 
# 1181
int maxSurface1D; 
# 1182
int maxSurface2D[2]; 
# 1183
int maxSurface3D[3]; 
# 1184
int maxSurface1DLayered[2]; 
# 1185
int maxSurface2DLayered[3]; 
# 1186
int maxSurfaceCubemap; 
# 1187
int maxSurfaceCubemapLayered[2]; 
# 1188
size_t surfaceAlignment; 
# 1189
int concurrentKernels; 
# 1190
int ECCEnabled; 
# 1191
int pciBusID; 
# 1192
int pciDeviceID; 
# 1193
int pciDomainID; 
# 1194
int tccDriver; 
# 1195
int asyncEngineCount; 
# 1196
int unifiedAddressing; 
# 1197
int memoryClockRate; 
# 1198
int memoryBusWidth; 
# 1199
int l2CacheSize; 
# 1200
int maxThreadsPerMultiProcessor; 
# 1201
int streamPrioritiesSupported; 
# 1202
}; 
#endif
# 1274 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
typedef 
# 1271
struct cudaIpcEventHandle_st { 
# 1273
char reserved[64]; 
# 1274
} cudaIpcEventHandle_t; 
#endif
# 1282 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
typedef 
# 1279
struct cudaIpcMemHandle_st { 
# 1281
char reserved[64]; 
# 1282
} cudaIpcMemHandle_t; 
#endif
# 1293 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
typedef cudaError 
# 1293
cudaError_t; 
#endif
# 1298 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
typedef struct CUstream_st *
# 1298
cudaStream_t; 
#endif
# 1303 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
typedef struct CUevent_st *
# 1303
cudaEvent_t; 
#endif
# 1308 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
typedef cudaGraphicsResource *
# 1308
cudaGraphicsResource_t; 
#endif
# 1313 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
typedef struct CUuuid_st 
# 1313
cudaUUID_t; 
#endif
# 1318 "/usr/local/cuda/bin/..//include/driver_types.h"
#if 0
typedef cudaOutputMode 
# 1318
cudaOutputMode_t; 
#endif
# 84 "/usr/local/cuda/bin/..//include/surface_types.h"
#if 0
# 84
enum cudaSurfaceBoundaryMode { 
# 86
cudaBoundaryModeZero, 
# 87
cudaBoundaryModeClamp, 
# 88
cudaBoundaryModeTrap
# 89
}; 
#endif
# 94 "/usr/local/cuda/bin/..//include/surface_types.h"
#if 0
# 94
enum cudaSurfaceFormatMode { 
# 96
cudaFormatModeForced, 
# 97
cudaFormatModeAuto
# 98
}; 
#endif
# 103 "/usr/local/cuda/bin/..//include/surface_types.h"
#if 0
# 103
struct surfaceReference { 
# 108
cudaChannelFormatDesc channelDesc; 
# 109
}; 
#endif
# 114 "/usr/local/cuda/bin/..//include/surface_types.h"
#if 0
typedef unsigned long long 
# 114
cudaSurfaceObject_t; 
#endif
# 84 "/usr/local/cuda/bin/..//include/texture_types.h"
#if 0
# 84
enum cudaTextureAddressMode { 
# 86
cudaAddressModeWrap, 
# 87
cudaAddressModeClamp, 
# 88
cudaAddressModeMirror, 
# 89
cudaAddressModeBorder
# 90
}; 
#endif
# 95 "/usr/local/cuda/bin/..//include/texture_types.h"
#if 0
# 95
enum cudaTextureFilterMode { 
# 97
cudaFilterModePoint, 
# 98
cudaFilterModeLinear
# 99
}; 
#endif
# 104 "/usr/local/cuda/bin/..//include/texture_types.h"
#if 0
# 104
enum cudaTextureReadMode { 
# 106
cudaReadModeElementType, 
# 107
cudaReadModeNormalizedFloat
# 108
}; 
#endif
# 113 "/usr/local/cuda/bin/..//include/texture_types.h"
#if 0
# 113
struct textureReference { 
# 118
int normalized; 
# 122
cudaTextureFilterMode filterMode; 
# 126
cudaTextureAddressMode addressMode[3]; 
# 130
cudaChannelFormatDesc channelDesc; 
# 134
int sRGB; 
# 138
unsigned maxAnisotropy; 
# 142
cudaTextureFilterMode mipmapFilterMode; 
# 146
float mipmapLevelBias; 
# 150
float minMipmapLevelClamp; 
# 154
float maxMipmapLevelClamp; 
# 155
int __cudaReserved[15]; 
# 156
}; 
#endif
# 161 "/usr/local/cuda/bin/..//include/texture_types.h"
#if 0
# 161
struct cudaTextureDesc { 
# 166
cudaTextureAddressMode addressMode[3]; 
# 170
cudaTextureFilterMode filterMode; 
# 174
cudaTextureReadMode readMode; 
# 178
int sRGB; 
# 182
int normalizedCoords; 
# 186
unsigned maxAnisotropy; 
# 190
cudaTextureFilterMode mipmapFilterMode; 
# 194
float mipmapLevelBias; 
# 198
float minMipmapLevelClamp; 
# 202
float maxMipmapLevelClamp; 
# 203
}; 
#endif
# 208 "/usr/local/cuda/bin/..//include/texture_types.h"
#if 0
typedef unsigned long long 
# 208
cudaTextureObject_t; 
#endif
# 96 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 96
struct char1 { 
# 98
signed char x; 
# 99
}; 
#endif
# 101 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 101
struct uchar1 { 
# 103
unsigned char x; 
# 104
}; 
#endif
# 107 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 107
struct __attribute((aligned(2))) char2 { 
# 109
signed char x, y; 
# 110
}; 
#endif
# 112 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 112
struct __attribute((aligned(2))) uchar2 { 
# 114
unsigned char x, y; 
# 115
}; 
#endif
# 117 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 117
struct char3 { 
# 119
signed char x, y, z; 
# 120
}; 
#endif
# 122 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 122
struct uchar3 { 
# 124
unsigned char x, y, z; 
# 125
}; 
#endif
# 127 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 127
struct __attribute((aligned(4))) char4 { 
# 129
signed char x, y, z, w; 
# 130
}; 
#endif
# 132 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 132
struct __attribute((aligned(4))) uchar4 { 
# 134
unsigned char x, y, z, w; 
# 135
}; 
#endif
# 137 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 137
struct short1 { 
# 139
short x; 
# 140
}; 
#endif
# 142 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 142
struct ushort1 { 
# 144
unsigned short x; 
# 145
}; 
#endif
# 147 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 147
struct __attribute((aligned(4))) short2 { 
# 149
short x, y; 
# 150
}; 
#endif
# 152 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 152
struct __attribute((aligned(4))) ushort2 { 
# 154
unsigned short x, y; 
# 155
}; 
#endif
# 157 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 157
struct short3 { 
# 159
short x, y, z; 
# 160
}; 
#endif
# 162 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 162
struct ushort3 { 
# 164
unsigned short x, y, z; 
# 165
}; 
#endif
# 167 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 167
struct __attribute((aligned(8))) short4 { short x; short y; short z; short w; }; 
#endif
# 168 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 168
struct __attribute((aligned(8))) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
# 170 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 170
struct int1 { 
# 172
int x; 
# 173
}; 
#endif
# 175 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 175
struct uint1 { 
# 177
unsigned x; 
# 178
}; 
#endif
# 180 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 180
struct __attribute((aligned(8))) int2 { int x; int y; }; 
#endif
# 181 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 181
struct __attribute((aligned(8))) uint2 { unsigned x; unsigned y; }; 
#endif
# 183 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 183
struct int3 { 
# 185
int x, y, z; 
# 186
}; 
#endif
# 188 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 188
struct uint3 { 
# 190
unsigned x, y, z; 
# 191
}; 
#endif
# 193 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 193
struct __attribute((aligned(16))) int4 { 
# 195
int x, y, z, w; 
# 196
}; 
#endif
# 198 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 198
struct __attribute((aligned(16))) uint4 { 
# 200
unsigned x, y, z, w; 
# 201
}; 
#endif
# 203 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 203
struct long1 { 
# 205
long x; 
# 206
}; 
#endif
# 208 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 208
struct ulong1 { 
# 210
unsigned long x; 
# 211
}; 
#endif
# 218 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 218
struct __attribute((aligned((2) * sizeof(long)))) long2 { 
# 220
long x, y; 
# 221
}; 
#endif
# 223 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 223
struct __attribute((aligned((2) * sizeof(unsigned long)))) ulong2 { 
# 225
unsigned long x, y; 
# 226
}; 
#endif
# 230 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 230
struct long3 { 
# 232
long x, y, z; 
# 233
}; 
#endif
# 235 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 235
struct ulong3 { 
# 237
unsigned long x, y, z; 
# 238
}; 
#endif
# 240 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 240
struct __attribute((aligned(16))) long4 { 
# 242
long x, y, z, w; 
# 243
}; 
#endif
# 245 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 245
struct __attribute((aligned(16))) ulong4 { 
# 247
unsigned long x, y, z, w; 
# 248
}; 
#endif
# 250 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 250
struct float1 { 
# 252
float x; 
# 253
}; 
#endif
# 272 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 272
struct __attribute((aligned(8))) float2 { float x; float y; }; 
#endif
# 277 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 277
struct float3 { 
# 279
float x, y, z; 
# 280
}; 
#endif
# 282 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 282
struct __attribute((aligned(16))) float4 { 
# 284
float x, y, z, w; 
# 285
}; 
#endif
# 287 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 287
struct longlong1 { 
# 289
long long x; 
# 290
}; 
#endif
# 292 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 292
struct ulonglong1 { 
# 294
unsigned long long x; 
# 295
}; 
#endif
# 297 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 297
struct __attribute((aligned(16))) longlong2 { 
# 299
long long x, y; 
# 300
}; 
#endif
# 302 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 302
struct __attribute((aligned(16))) ulonglong2 { 
# 304
unsigned long long x, y; 
# 305
}; 
#endif
# 307 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 307
struct longlong3 { 
# 309
long long x, y, z; 
# 310
}; 
#endif
# 312 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 312
struct ulonglong3 { 
# 314
unsigned long long x, y, z; 
# 315
}; 
#endif
# 317 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 317
struct __attribute((aligned(16))) longlong4 { 
# 319
long long x, y, z, w; 
# 320
}; 
#endif
# 322 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 322
struct __attribute((aligned(16))) ulonglong4 { 
# 324
unsigned long long x, y, z, w; 
# 325
}; 
#endif
# 327 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 327
struct double1 { 
# 329
double x; 
# 330
}; 
#endif
# 332 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 332
struct __attribute((aligned(16))) double2 { 
# 334
double x, y; 
# 335
}; 
#endif
# 337 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 337
struct double3 { 
# 339
double x, y, z; 
# 340
}; 
#endif
# 342 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 342
struct __attribute((aligned(16))) double4 { 
# 344
double x, y, z, w; 
# 345
}; 
#endif
# 360 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef char1 
# 360
char1; 
#endif
# 361 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef uchar1 
# 361
uchar1; 
#endif
# 362 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef char2 
# 362
char2; 
#endif
# 363 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef uchar2 
# 363
uchar2; 
#endif
# 364 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef char3 
# 364
char3; 
#endif
# 365 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef uchar3 
# 365
uchar3; 
#endif
# 366 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef char4 
# 366
char4; 
#endif
# 367 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef uchar4 
# 367
uchar4; 
#endif
# 368 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef short1 
# 368
short1; 
#endif
# 369 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ushort1 
# 369
ushort1; 
#endif
# 370 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef short2 
# 370
short2; 
#endif
# 371 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ushort2 
# 371
ushort2; 
#endif
# 372 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef short3 
# 372
short3; 
#endif
# 373 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ushort3 
# 373
ushort3; 
#endif
# 374 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef short4 
# 374
short4; 
#endif
# 375 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ushort4 
# 375
ushort4; 
#endif
# 376 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef int1 
# 376
int1; 
#endif
# 377 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef uint1 
# 377
uint1; 
#endif
# 378 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef int2 
# 378
int2; 
#endif
# 379 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef uint2 
# 379
uint2; 
#endif
# 380 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef int3 
# 380
int3; 
#endif
# 381 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef uint3 
# 381
uint3; 
#endif
# 382 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef int4 
# 382
int4; 
#endif
# 383 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef uint4 
# 383
uint4; 
#endif
# 384 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef long1 
# 384
long1; 
#endif
# 385 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ulong1 
# 385
ulong1; 
#endif
# 386 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef long2 
# 386
long2; 
#endif
# 387 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ulong2 
# 387
ulong2; 
#endif
# 388 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef long3 
# 388
long3; 
#endif
# 389 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ulong3 
# 389
ulong3; 
#endif
# 390 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef long4 
# 390
long4; 
#endif
# 391 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ulong4 
# 391
ulong4; 
#endif
# 392 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef float1 
# 392
float1; 
#endif
# 393 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef float2 
# 393
float2; 
#endif
# 394 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef float3 
# 394
float3; 
#endif
# 395 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef float4 
# 395
float4; 
#endif
# 396 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef longlong1 
# 396
longlong1; 
#endif
# 397 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ulonglong1 
# 397
ulonglong1; 
#endif
# 398 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef longlong2 
# 398
longlong2; 
#endif
# 399 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ulonglong2 
# 399
ulonglong2; 
#endif
# 400 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef longlong3 
# 400
longlong3; 
#endif
# 401 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ulonglong3 
# 401
ulonglong3; 
#endif
# 402 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef longlong4 
# 402
longlong4; 
#endif
# 403 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef ulonglong4 
# 403
ulonglong4; 
#endif
# 404 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef double1 
# 404
double1; 
#endif
# 405 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef double2 
# 405
double2; 
#endif
# 406 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef double3 
# 406
double3; 
#endif
# 407 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef double4 
# 407
double4; 
#endif
# 415 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
# 415
struct dim3 { 
# 417
unsigned x, y, z; 
# 423
}; 
#endif
# 425 "/usr/local/cuda/bin/..//include/vector_types.h"
#if 0
typedef dim3 
# 425
dim3; 
#endif
# 86 "/usr/local/cuda/bin/..//include/cuda_device_runtime_api.h"
extern "C" cudaError_t cudaDeviceGetAttribute(int * , cudaDeviceAttr , int ); 
# 87
extern "C" cudaError_t cudaDeviceGetLimit(size_t * , cudaLimit ); 
# 88
extern "C" cudaError_t cudaDeviceGetCacheConfig(cudaFuncCache * ); 
# 89
extern "C" cudaError_t cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * ); 
# 90
extern "C" cudaError_t cudaDeviceSynchronize(); 
# 91
extern "C" cudaError_t cudaGetLastError(); 
# 92
extern "C" cudaError_t cudaPeekAtLastError(); 
# 93
extern "C" const char *cudaGetErrorString(cudaError_t ); 
# 94
extern "C" cudaError_t cudaGetDeviceCount(int * ); 
# 95
extern "C" cudaError_t cudaGetDevice(int * ); 
# 96
extern "C" cudaError_t cudaStreamCreateWithFlags(cudaStream_t * , unsigned ); 
# 97
extern "C" cudaError_t cudaStreamDestroy(cudaStream_t ); 
# 98
extern "C" cudaError_t cudaStreamWaitEvent(cudaStream_t , cudaEvent_t , unsigned ); 
# 99
extern "C" cudaError_t cudaEventCreateWithFlags(cudaEvent_t * , unsigned ); 
# 100
extern "C" cudaError_t cudaEventRecord(cudaEvent_t , cudaStream_t ); 
# 101
extern "C" cudaError_t cudaEventDestroy(cudaEvent_t ); 
# 102
extern "C" cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * , const void * ); 
# 103
extern "C" cudaError_t cudaFree(void * ); 
# 104
extern "C" cudaError_t cudaMalloc(void ** , size_t ); 
# 105
extern "C" cudaError_t cudaMemcpyAsync(void * , const void * , size_t , cudaMemcpyKind , cudaStream_t ); 
# 106
extern "C" cudaError_t cudaMemcpy2DAsync(void * , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t ); 
# 107
extern "C" cudaError_t cudaMemcpy3DAsync(const cudaMemcpy3DParms * , cudaStream_t ); 
# 108
extern "C" cudaError_t cudaMemsetAsync(void * , int , size_t , cudaStream_t ); 
# 109
extern "C" cudaError_t cudaMemset2DAsync(void * , size_t , int , size_t , size_t , cudaStream_t ); 
# 110
extern "C" cudaError_t cudaMemset3DAsync(cudaPitchedPtr , int , cudaExtent , cudaStream_t ); 
# 111
extern "C" cudaError_t cudaRuntimeGetVersion(int * ); 
# 113
extern "C" { __attribute__((unused)) extern void *cudaGetParameterBuffer(size_t , size_t ); } 
# 114
extern "C" { __attribute__((unused)) extern cudaError_t cudaLaunchDevice(void * , void * , dim3 , dim3 , unsigned , cudaStream_t ); } 
# 116
namespace _GLOBAL__N__12_test_cpp1_ii_main { }; using namespace _GLOBAL__N__12_test_cpp1_ii_main; namespace _GLOBAL__N__12_test_cpp1_ii_main { 
# 117
template< class T> inline cudaError_t cudaMalloc(T ** , size_t ); 
# 118
template< class T> inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * , T * ); 
# 119
}
# 193 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceReset(); 
# 210 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceSynchronize(); 
# 295 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceSetLimit(cudaLimit , size_t ); 
# 324 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceGetLimit(size_t * , cudaLimit ); 
# 355 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceGetCacheConfig(cudaFuncCache * ); 
# 390 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceGetStreamPriorityRange(int * , int * ); 
# 432 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceSetCacheConfig(cudaFuncCache ); 
# 461 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * ); 
# 503 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceSetSharedMemConfig(cudaSharedMemConfig ); 
# 526 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceGetByPCIBusId(int * , char * ); 
# 553 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceGetPCIBusId(char * , int , int ); 
# 595 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaIpcGetEventHandle(cudaIpcEventHandle_t * , cudaEvent_t ); 
# 630 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaIpcOpenEventHandle(cudaEvent_t * , cudaIpcEventHandle_t ); 
# 668 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaIpcGetMemHandle(cudaIpcMemHandle_t * , void * ); 
# 718 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaIpcOpenMemHandle(void ** , cudaIpcMemHandle_t , unsigned ); 
# 748 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaIpcCloseMemHandle(void * ); 
# 784 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaThreadExit(); 
# 808 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaThreadSynchronize(); 
# 867 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaThreadSetLimit(cudaLimit , size_t ); 
# 898 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaThreadGetLimit(size_t * , cudaLimit ); 
# 933 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaThreadGetCacheConfig(cudaFuncCache * ); 
# 979 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaThreadSetCacheConfig(cudaFuncCache ); 
# 1029 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetLastError(); 
# 1070 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaPeekAtLastError(); 
# 1084 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" const char *cudaGetErrorString(cudaError_t ); 
# 1114 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetDeviceCount(int * ); 
# 1329 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetDeviceProperties(cudaDeviceProp * , int ); 
# 1476 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceGetAttribute(int * , cudaDeviceAttr , int ); 
# 1495 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaChooseDevice(int * , const cudaDeviceProp * ); 
# 1529 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaSetDevice(int ); 
# 1546 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetDevice(int * ); 
# 1575 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaSetValidDevices(int * , int ); 
# 1635 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaSetDeviceFlags(unsigned ); 
# 1669 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaStreamCreate(cudaStream_t * ); 
# 1698 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaStreamCreateWithFlags(cudaStream_t * , unsigned ); 
# 1741 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaStreamCreateWithPriority(cudaStream_t * , unsigned , int ); 
# 1765 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaStreamGetPriority(cudaStream_t , int * ); 
# 1786 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaStreamGetFlags(cudaStream_t , unsigned * ); 
# 1807 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaStreamDestroy(cudaStream_t ); 
# 1842 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaStreamWaitEvent(cudaStream_t , cudaEvent_t , unsigned ); 
# 1856 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" { typedef void (*cudaStreamCallback_t)(cudaStream_t , cudaError_t , void * ); }
# 1894 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaStreamAddCallback(cudaStream_t , cudaStreamCallback_t , void * , unsigned ); 
# 1914 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaStreamSynchronize(cudaStream_t ); 
# 1932 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaStreamQuery(cudaStream_t ); 
# 1964 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaEventCreate(cudaEvent_t * ); 
# 1998 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaEventCreateWithFlags(cudaEvent_t * , unsigned ); 
# 2031 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaEventRecord(cudaEvent_t , cudaStream_t  = 0); 
# 2060 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaEventQuery(cudaEvent_t ); 
# 2092 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaEventSynchronize(cudaEvent_t ); 
# 2117 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaEventDestroy(cudaEvent_t ); 
# 2158 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaEventElapsedTime(float * , cudaEvent_t , cudaEvent_t ); 
# 2200 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaConfigureCall(dim3 , dim3 , size_t  = 0, cudaStream_t  = 0); 
# 2227 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaSetupArgument(const void * , size_t , size_t ); 
# 2273 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaFuncSetCacheConfig(const void * , cudaFuncCache ); 
# 2324 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaFuncSetSharedMemConfig(const void * , cudaSharedMemConfig ); 
# 2359 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaLaunch(const void * ); 
# 2392 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * , const void * ); 
# 2414 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaSetDoubleForDevice(double * ); 
# 2436 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaSetDoubleForHost(double * ); 
# 2471 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMalloc(void ** , size_t ); 
# 2500 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMallocHost(void ** , size_t ); 
# 2539 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMallocPitch(void ** , size_t * , size_t , size_t ); 
# 2581 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMallocArray(cudaArray_t * , const cudaChannelFormatDesc * , size_t , size_t  = 0, unsigned  = 0); 
# 2605 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaFree(void * ); 
# 2625 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaFreeHost(void * ); 
# 2647 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaFreeArray(cudaArray_t ); 
# 2669 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaFreeMipmappedArray(cudaMipmappedArray_t ); 
# 2728 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaHostAlloc(void ** , size_t , unsigned ); 
# 2781 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaHostRegister(void * , size_t , unsigned ); 
# 2800 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaHostUnregister(void * ); 
# 2827 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaHostGetDevicePointer(void ** , void * , unsigned ); 
# 2846 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaHostGetFlags(unsigned * , void * ); 
# 2881 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMalloc3D(cudaPitchedPtr * , cudaExtent ); 
# 3016 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMalloc3DArray(cudaArray_t * , const cudaChannelFormatDesc * , cudaExtent , unsigned  = 0); 
# 3137 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMallocMipmappedArray(cudaMipmappedArray_t * , const cudaChannelFormatDesc * , cudaExtent , unsigned , unsigned  = 0); 
# 3163 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetMipmappedArrayLevel(cudaArray_t * , cudaMipmappedArray_const_t , unsigned ); 
# 3260 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy3D(const cudaMemcpy3DParms * ); 
# 3288 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms * ); 
# 3392 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy3DAsync(const cudaMemcpy3DParms * , cudaStream_t  = 0); 
# 3414 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms * , cudaStream_t  = 0); 
# 3433 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemGetInfo(size_t * , size_t * ); 
# 3454 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaArrayGetInfo(cudaChannelFormatDesc * , cudaExtent * , unsigned * , cudaArray_t ); 
# 3489 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy(void * , const void * , size_t , cudaMemcpyKind ); 
# 3521 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyPeer(void * , int , const void * , int , size_t ); 
# 3555 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyToArray(cudaArray_t , size_t , size_t , const void * , size_t , cudaMemcpyKind ); 
# 3589 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyFromArray(void * , cudaArray_const_t , size_t , size_t , size_t , cudaMemcpyKind ); 
# 3624 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyArrayToArray(cudaArray_t , size_t , size_t , cudaArray_const_t , size_t , size_t , size_t , cudaMemcpyKind  = cudaMemcpyDeviceToDevice); 
# 3666 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy2D(void * , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind ); 
# 3708 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy2DToArray(cudaArray_t , size_t , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind ); 
# 3750 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy2DFromArray(void * , size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , cudaMemcpyKind ); 
# 3790 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy2DArrayToArray(cudaArray_t , size_t , size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , cudaMemcpyKind  = cudaMemcpyDeviceToDevice); 
# 3825 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyToSymbol(const void * , const void * , size_t , size_t  = 0, cudaMemcpyKind  = cudaMemcpyHostToDevice); 
# 3860 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyFromSymbol(void * , const void * , size_t , size_t  = 0, cudaMemcpyKind  = cudaMemcpyDeviceToHost); 
# 3902 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyAsync(void * , const void * , size_t , cudaMemcpyKind , cudaStream_t  = 0); 
# 3933 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyPeerAsync(void * , int , const void * , int , size_t , cudaStream_t  = 0); 
# 3974 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyToArrayAsync(cudaArray_t , size_t , size_t , const void * , size_t , cudaMemcpyKind , cudaStream_t  = 0); 
# 4015 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyFromArrayAsync(void * , cudaArray_const_t , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); 
# 4066 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy2DAsync(void * , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); 
# 4116 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy2DToArrayAsync(cudaArray_t , size_t , size_t , const void * , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); 
# 4165 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpy2DFromArrayAsync(void * , size_t , cudaArray_const_t , size_t , size_t , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); 
# 4207 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyToSymbolAsync(const void * , const void * , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); 
# 4249 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemcpyFromSymbolAsync(void * , const void * , size_t , size_t , cudaMemcpyKind , cudaStream_t  = 0); 
# 4275 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemset(void * , int , size_t ); 
# 4305 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemset2D(void * , size_t , int , size_t , size_t ); 
# 4348 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemset3D(cudaPitchedPtr , int , cudaExtent ); 
# 4376 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemsetAsync(void * , int , size_t , cudaStream_t  = 0); 
# 4409 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemset2DAsync(void * , size_t , int , size_t , size_t , cudaStream_t  = 0); 
# 4455 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaMemset3DAsync(cudaPitchedPtr , int , cudaExtent , cudaStream_t  = 0); 
# 4478 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetSymbolAddress(void ** , const void * ); 
# 4500 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetSymbolSize(size_t * , const void * ); 
# 4644 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaPointerGetAttributes(cudaPointerAttributes * , const void * ); 
# 4678 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceCanAccessPeer(int * , int , int ); 
# 4715 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceEnablePeerAccess(int , unsigned ); 
# 4734 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDeviceDisablePeerAccess(int ); 
# 4788 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGraphicsUnregisterResource(cudaGraphicsResource_t ); 
# 4820 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t , unsigned ); 
# 4855 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGraphicsMapResources(int , cudaGraphicsResource_t * , cudaStream_t  = 0); 
# 4886 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGraphicsUnmapResources(int , cudaGraphicsResource_t * , cudaStream_t  = 0); 
# 4915 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGraphicsResourceGetMappedPointer(void ** , size_t * , cudaGraphicsResource_t ); 
# 4949 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGraphicsSubResourceGetMappedArray(cudaArray_t * , cudaGraphicsResource_t , unsigned , unsigned ); 
# 4974 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * , cudaGraphicsResource_t ); 
# 5010 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetChannelDesc(cudaChannelFormatDesc * , cudaArray_const_t ); 
# 5045 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaChannelFormatDesc cudaCreateChannelDesc(int , int , int , int , cudaChannelFormatKind ); 
# 5092 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaBindTexture(size_t * , const textureReference * , const void * , const cudaChannelFormatDesc * , size_t  = ((2147483647) * 2U) + 1U); 
# 5143 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaBindTexture2D(size_t * , const textureReference * , const void * , const cudaChannelFormatDesc * , size_t , size_t , size_t ); 
# 5171 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaBindTextureToArray(const textureReference * , cudaArray_const_t , const cudaChannelFormatDesc * ); 
# 5199 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaBindTextureToMipmappedArray(const textureReference * , cudaMipmappedArray_const_t , const cudaChannelFormatDesc * ); 
# 5220 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaUnbindTexture(const textureReference * ); 
# 5245 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetTextureAlignmentOffset(size_t * , const textureReference * ); 
# 5270 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetTextureReference(const textureReference ** , const void * ); 
# 5306 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaBindSurfaceToArray(const surfaceReference * , cudaArray_const_t , const cudaChannelFormatDesc * ); 
# 5325 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetSurfaceReference(const surfaceReference ** , const void * ); 
# 5536 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaCreateTextureObject(cudaTextureObject_t * , const cudaResourceDesc * , const cudaTextureDesc * , const cudaResourceViewDesc * ); 
# 5551 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDestroyTextureObject(cudaTextureObject_t ); 
# 5567 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetTextureObjectResourceDesc(cudaResourceDesc * , cudaTextureObject_t ); 
# 5583 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetTextureObjectTextureDesc(cudaTextureDesc * , cudaTextureObject_t ); 
# 5600 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * , cudaTextureObject_t ); 
# 5633 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaCreateSurfaceObject(cudaSurfaceObject_t * , const cudaResourceDesc * ); 
# 5648 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDestroySurfaceObject(cudaSurfaceObject_t ); 
# 5663 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * , cudaSurfaceObject_t ); 
# 5690 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaDriverGetVersion(int * ); 
# 5707 "/usr/local/cuda/bin/..//include/cuda_runtime_api.h"
extern "C" cudaError_t cudaRuntimeGetVersion(int * ); 
# 5712
extern "C" cudaError_t cudaGetExportTable(const void ** , const cudaUUID_t * ); 
# 107 "/usr/local/cuda/bin/..//include/channel_descriptor.h"
template< class T> inline cudaChannelFormatDesc cudaCreateChannelDesc() 
# 108
{ 
# 109
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
# 110
} 
# 112
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
# 113
{ 
# 114
int e = (((int)sizeof(unsigned short)) * 8); 
# 116
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 117
} 
# 119
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
# 120
{ 
# 121
int e = (((int)sizeof(unsigned short)) * 8); 
# 123
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 124
} 
# 126
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
# 127
{ 
# 128
int e = (((int)sizeof(unsigned short)) * 8); 
# 130
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
# 131
} 
# 133
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
# 134
{ 
# 135
int e = (((int)sizeof(unsigned short)) * 8); 
# 137
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
# 138
} 
# 140
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
# 141
{ 
# 142
int e = (((int)sizeof(char)) * 8); 
# 147
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 149
} 
# 151
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
# 152
{ 
# 153
int e = (((int)sizeof(signed char)) * 8); 
# 155
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 156
} 
# 158
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
# 159
{ 
# 160
int e = (((int)sizeof(unsigned char)) * 8); 
# 162
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 163
} 
# 165
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
# 166
{ 
# 167
int e = (((int)sizeof(signed char)) * 8); 
# 169
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 170
} 
# 172
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
# 173
{ 
# 174
int e = (((int)sizeof(unsigned char)) * 8); 
# 176
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 177
} 
# 179
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
# 180
{ 
# 181
int e = (((int)sizeof(signed char)) * 8); 
# 183
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 184
} 
# 186
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
# 187
{ 
# 188
int e = (((int)sizeof(unsigned char)) * 8); 
# 190
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 191
} 
# 193
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
# 194
{ 
# 195
int e = (((int)sizeof(signed char)) * 8); 
# 197
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 198
} 
# 200
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
# 201
{ 
# 202
int e = (((int)sizeof(unsigned char)) * 8); 
# 204
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 205
} 
# 207
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
# 208
{ 
# 209
int e = (((int)sizeof(short)) * 8); 
# 211
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 212
} 
# 214
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
# 215
{ 
# 216
int e = (((int)sizeof(unsigned short)) * 8); 
# 218
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 219
} 
# 221
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
# 222
{ 
# 223
int e = (((int)sizeof(short)) * 8); 
# 225
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 226
} 
# 228
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
# 229
{ 
# 230
int e = (((int)sizeof(unsigned short)) * 8); 
# 232
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 233
} 
# 235
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
# 236
{ 
# 237
int e = (((int)sizeof(short)) * 8); 
# 239
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 240
} 
# 242
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
# 243
{ 
# 244
int e = (((int)sizeof(unsigned short)) * 8); 
# 246
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 247
} 
# 249
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
# 250
{ 
# 251
int e = (((int)sizeof(short)) * 8); 
# 253
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 254
} 
# 256
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
# 257
{ 
# 258
int e = (((int)sizeof(unsigned short)) * 8); 
# 260
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 261
} 
# 263
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
# 264
{ 
# 265
int e = (((int)sizeof(int)) * 8); 
# 267
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 268
} 
# 270
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
# 271
{ 
# 272
int e = (((int)sizeof(unsigned)) * 8); 
# 274
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 275
} 
# 277
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
# 278
{ 
# 279
int e = (((int)sizeof(int)) * 8); 
# 281
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 282
} 
# 284
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
# 285
{ 
# 286
int e = (((int)sizeof(unsigned)) * 8); 
# 288
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 289
} 
# 291
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
# 292
{ 
# 293
int e = (((int)sizeof(int)) * 8); 
# 295
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 296
} 
# 298
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
# 299
{ 
# 300
int e = (((int)sizeof(unsigned)) * 8); 
# 302
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 303
} 
# 305
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
# 306
{ 
# 307
int e = (((int)sizeof(int)) * 8); 
# 309
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 310
} 
# 312
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
# 313
{ 
# 314
int e = (((int)sizeof(unsigned)) * 8); 
# 316
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 317
} 
# 379 "/usr/local/cuda/bin/..//include/channel_descriptor.h"
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
# 380
{ 
# 381
int e = (((int)sizeof(float)) * 8); 
# 383
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 384
} 
# 386
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
# 387
{ 
# 388
int e = (((int)sizeof(float)) * 8); 
# 390
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 391
} 
# 393
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
# 394
{ 
# 395
int e = (((int)sizeof(float)) * 8); 
# 397
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
# 398
} 
# 400
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
# 401
{ 
# 402
int e = (((int)sizeof(float)) * 8); 
# 404
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
# 405
} 
# 79 "/usr/local/cuda/bin/..//include/driver_functions.h"
static inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
# 80
{ 
# 81
cudaPitchedPtr s; 
# 83
(s.ptr) = d; 
# 84
(s.pitch) = p; 
# 85
(s.xsize) = xsz; 
# 86
(s.ysize) = ysz; 
# 88
return s; 
# 89
} 
# 106 "/usr/local/cuda/bin/..//include/driver_functions.h"
static inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
# 107
{ 
# 108
cudaPos p; 
# 110
(p.x) = x; 
# 111
(p.y) = y; 
# 112
(p.z) = z; 
# 114
return p; 
# 115
} 
# 132 "/usr/local/cuda/bin/..//include/driver_functions.h"
static inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
# 133
{ 
# 134
cudaExtent e; 
# 136
(e.width) = w; 
# 137
(e.height) = h; 
# 138
(e.depth) = d; 
# 140
return e; 
# 141
} 
# 69 "/usr/local/cuda/bin/..//include/vector_functions.h"
static inline char1 make_char1(signed char x) 
# 70
{ 
# 71
char1 t; (t.x) = x; return t; 
# 72
} 
# 74
static inline uchar1 make_uchar1(unsigned char x) 
# 75
{ 
# 76
uchar1 t; (t.x) = x; return t; 
# 77
} 
# 79
static inline char2 make_char2(signed char x, signed char y) 
# 80
{ 
# 81
char2 t; (t.x) = x; (t.y) = y; return t; 
# 82
} 
# 84
static inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
# 85
{ 
# 86
uchar2 t; (t.x) = x; (t.y) = y; return t; 
# 87
} 
# 89
static inline char3 make_char3(signed char x, signed char y, signed char z) 
# 90
{ 
# 91
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 92
} 
# 94
static inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
# 95
{ 
# 96
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 97
} 
# 99
static inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
# 100
{ 
# 101
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 102
} 
# 104
static inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
# 105
{ 
# 106
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 107
} 
# 109
static inline short1 make_short1(short x) 
# 110
{ 
# 111
short1 t; (t.x) = x; return t; 
# 112
} 
# 114
static inline ushort1 make_ushort1(unsigned short x) 
# 115
{ 
# 116
ushort1 t; (t.x) = x; return t; 
# 117
} 
# 119
static inline short2 make_short2(short x, short y) 
# 120
{ 
# 121
short2 t; (t.x) = x; (t.y) = y; return t; 
# 122
} 
# 124
static inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
# 125
{ 
# 126
ushort2 t; (t.x) = x; (t.y) = y; return t; 
# 127
} 
# 129
static inline short3 make_short3(short x, short y, short z) 
# 130
{ 
# 131
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 132
} 
# 134
static inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
# 135
{ 
# 136
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 137
} 
# 139
static inline short4 make_short4(short x, short y, short z, short w) 
# 140
{ 
# 141
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 142
} 
# 144
static inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
# 145
{ 
# 146
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 147
} 
# 149
static inline int1 make_int1(int x) 
# 150
{ 
# 151
int1 t; (t.x) = x; return t; 
# 152
} 
# 154
static inline uint1 make_uint1(unsigned x) 
# 155
{ 
# 156
uint1 t; (t.x) = x; return t; 
# 157
} 
# 159
static inline int2 make_int2(int x, int y) 
# 160
{ 
# 161
int2 t; (t.x) = x; (t.y) = y; return t; 
# 162
} 
# 164
static inline uint2 make_uint2(unsigned x, unsigned y) 
# 165
{ 
# 166
uint2 t; (t.x) = x; (t.y) = y; return t; 
# 167
} 
# 169
static inline int3 make_int3(int x, int y, int z) 
# 170
{ 
# 171
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 172
} 
# 174
static inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
# 175
{ 
# 176
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 177
} 
# 179
static inline int4 make_int4(int x, int y, int z, int w) 
# 180
{ 
# 181
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 182
} 
# 184
static inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
# 185
{ 
# 186
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 187
} 
# 189
static inline long1 make_long1(long x) 
# 190
{ 
# 191
long1 t; (t.x) = x; return t; 
# 192
} 
# 194
static inline ulong1 make_ulong1(unsigned long x) 
# 195
{ 
# 196
ulong1 t; (t.x) = x; return t; 
# 197
} 
# 199
static inline long2 make_long2(long x, long y) 
# 200
{ 
# 201
long2 t; (t.x) = x; (t.y) = y; return t; 
# 202
} 
# 204
static inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
# 205
{ 
# 206
ulong2 t; (t.x) = x; (t.y) = y; return t; 
# 207
} 
# 209
static inline long3 make_long3(long x, long y, long z) 
# 210
{ 
# 211
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 212
} 
# 214
static inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
# 215
{ 
# 216
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 217
} 
# 219
static inline long4 make_long4(long x, long y, long z, long w) 
# 220
{ 
# 221
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 222
} 
# 224
static inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
# 225
{ 
# 226
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 227
} 
# 229
static inline float1 make_float1(float x) 
# 230
{ 
# 231
float1 t; (t.x) = x; return t; 
# 232
} 
# 234
static inline float2 make_float2(float x, float y) 
# 235
{ 
# 236
float2 t; (t.x) = x; (t.y) = y; return t; 
# 237
} 
# 239
static inline float3 make_float3(float x, float y, float z) 
# 240
{ 
# 241
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 242
} 
# 244
static inline float4 make_float4(float x, float y, float z, float w) 
# 245
{ 
# 246
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 247
} 
# 249
static inline longlong1 make_longlong1(long long x) 
# 250
{ 
# 251
longlong1 t; (t.x) = x; return t; 
# 252
} 
# 254
static inline ulonglong1 make_ulonglong1(unsigned long long x) 
# 255
{ 
# 256
ulonglong1 t; (t.x) = x; return t; 
# 257
} 
# 259
static inline longlong2 make_longlong2(long long x, long long y) 
# 260
{ 
# 261
longlong2 t; (t.x) = x; (t.y) = y; return t; 
# 262
} 
# 264
static inline ulonglong2 make_ulonglong2(unsigned long long x, unsigned long long y) 
# 265
{ 
# 266
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
# 267
} 
# 269
static inline longlong3 make_longlong3(long long x, long long y, long long z) 
# 270
{ 
# 271
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 272
} 
# 274
static inline ulonglong3 make_ulonglong3(unsigned long long x, unsigned long long y, unsigned long long z) 
# 275
{ 
# 276
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 277
} 
# 279
static inline longlong4 make_longlong4(long long x, long long y, long long z, long long w) 
# 280
{ 
# 281
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 282
} 
# 284
static inline ulonglong4 make_ulonglong4(unsigned long long x, unsigned long long y, unsigned long long z, unsigned long long w) 
# 285
{ 
# 286
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 287
} 
# 289
static inline double1 make_double1(double x) 
# 290
{ 
# 291
double1 t; (t.x) = x; return t; 
# 292
} 
# 294
static inline double2 make_double2(double x, double y) 
# 295
{ 
# 296
double2 t; (t.x) = x; (t.y) = y; return t; 
# 297
} 
# 299
static inline double3 make_double3(double x, double y, double z) 
# 300
{ 
# 301
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 302
} 
# 304
static inline double4 make_double4(double x, double y, double z, double w) 
# 305
{ 
# 306
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 307
} 
# 44 "/usr/include/string.h" 3
extern "C" void *memcpy(void *__restrict__ , const void *__restrict__ , size_t ) throw()
# 46
 __attribute((__nonnull__(1, 2))); 
# 49
extern "C" void *memmove(void * , const void * , size_t ) throw()
# 50
 __attribute((__nonnull__(1, 2))); 
# 57
extern "C" void *memccpy(void *__restrict__ , const void *__restrict__ , int , size_t ) throw()
# 59
 __attribute((__nonnull__(1, 2))); 
# 65
extern "C" void *memset(void * , int , size_t ) throw() __attribute((__nonnull__(1))); 
# 68
extern "C" int memcmp(const void * , const void * , size_t ) throw()
# 69
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 75
extern void *memchr(void * , int , size_t ) throw() __asm__("memchr")
# 76
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 77
extern const void *memchr(const void * , int , size_t ) throw() __asm__("memchr")
# 78
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 104 "/usr/include/string.h" 3
void *rawmemchr(void * , int ) throw() __asm__("rawmemchr")
# 105
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 106
const void *rawmemchr(const void * , int ) throw() __asm__("rawmemchr")
# 107
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 115
void *memrchr(void * , int , size_t ) throw() __asm__("memrchr")
# 116
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 117
const void *memrchr(const void * , int , size_t ) throw() __asm__("memrchr")
# 118
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 128
extern "C" char *strcpy(char *__restrict__ , const char *__restrict__ ) throw()
# 129
 __attribute((__nonnull__(1, 2))); 
# 131
extern "C" char *strncpy(char *__restrict__ , const char *__restrict__ , size_t ) throw()
# 133
 __attribute((__nonnull__(1, 2))); 
# 136
extern "C" char *strcat(char *__restrict__ , const char *__restrict__ ) throw()
# 137
 __attribute((__nonnull__(1, 2))); 
# 139
extern "C" char *strncat(char *__restrict__ , const char *__restrict__ , size_t ) throw()
# 140
 __attribute((__nonnull__(1, 2))); 
# 143
extern "C" int strcmp(const char * , const char * ) throw()
# 144
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 146
extern "C" int strncmp(const char * , const char * , size_t ) throw()
# 147
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 150
extern "C" int strcoll(const char * , const char * ) throw()
# 151
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 153
extern "C" size_t strxfrm(char *__restrict__ , const char *__restrict__ , size_t ) throw()
# 155
 __attribute((__nonnull__(2))); 
# 40 "/usr/include/xlocale.h" 3
extern "C" { typedef 
# 28
struct __locale_struct { 
# 31
struct __locale_data *__locales[13]; 
# 34
const unsigned short *__ctype_b; 
# 35
const int *__ctype_tolower; 
# 36
const int *__ctype_toupper; 
# 39
const char *__names[13]; 
# 40
} *__locale_t; }
# 43
extern "C" { typedef __locale_t locale_t; }
# 165 "/usr/include/string.h" 3
extern "C" int strcoll_l(const char * , const char * , __locale_t ) throw()
# 166
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 3))); 
# 168
extern "C" size_t strxfrm_l(char * , const char * , size_t , __locale_t ) throw()
# 169
 __attribute((__nonnull__(2, 4))); 
# 175
extern "C" char *strdup(const char * ) throw()
# 176
 __attribute((__malloc__)) __attribute((__nonnull__(1))); 
# 183
extern "C" char *strndup(const char * , size_t ) throw()
# 184
 __attribute((__malloc__)) __attribute((__nonnull__(1))); 
# 215 "/usr/include/string.h" 3
extern char *strchr(char * , int ) throw() __asm__("strchr")
# 216
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 217
extern const char *strchr(const char * , int ) throw() __asm__("strchr")
# 218
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 242 "/usr/include/string.h" 3
extern char *strrchr(char * , int ) throw() __asm__("strrchr")
# 243
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 244
extern const char *strrchr(const char * , int ) throw() __asm__("strrchr")
# 245
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 271 "/usr/include/string.h" 3
char *strchrnul(char * , int ) throw() __asm__("strchrnul")
# 272
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 273
const char *strchrnul(const char * , int ) throw() __asm__("strchrnul")
# 274
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 284
extern "C" size_t strcspn(const char * , const char * ) throw()
# 285
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 288
extern "C" size_t strspn(const char * , const char * ) throw()
# 289
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 294
extern char *strpbrk(char * , const char * ) throw() __asm__("strpbrk")
# 295
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 296
extern const char *strpbrk(const char * , const char * ) throw() __asm__("strpbrk")
# 297
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 321 "/usr/include/string.h" 3
extern char *strstr(char * , const char * ) throw() __asm__("strstr")
# 322
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 323
extern const char *strstr(const char * , const char * ) throw() __asm__("strstr")
# 325
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 348 "/usr/include/string.h" 3
extern "C" char *strtok(char *__restrict__ , const char *__restrict__ ) throw()
# 349
 __attribute((__nonnull__(2))); 
# 354
extern "C" char *__strtok_r(char *__restrict__ , const char *__restrict__ , char **__restrict__ ) throw()
# 357
 __attribute((__nonnull__(2, 3))); 
# 359
extern "C" char *strtok_r(char *__restrict__ , const char *__restrict__ , char **__restrict__ ) throw()
# 361
 __attribute((__nonnull__(2, 3))); 
# 367
char *strcasestr(char * , const char * ) throw() __asm__("strcasestr")
# 368
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 369
const char *strcasestr(const char * , const char * ) throw() __asm__("strcasestr")
# 371
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 382 "/usr/include/string.h" 3
extern "C" void *memmem(const void * , size_t , const void * , size_t ) throw()
# 384
 __attribute((__pure__)) __attribute((__nonnull__(1, 3))); 
# 388
extern "C" void *__mempcpy(void *__restrict__ , const void *__restrict__ , size_t ) throw()
# 390
 __attribute((__nonnull__(1, 2))); 
# 391
extern "C" void *mempcpy(void *__restrict__ , const void *__restrict__ , size_t ) throw()
# 393
 __attribute((__nonnull__(1, 2))); 
# 399
extern "C" size_t strlen(const char * ) throw()
# 400
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 406
extern "C" size_t strnlen(const char * , size_t ) throw()
# 407
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 413
extern "C" char *strerror(int ) throw(); 
# 438 "/usr/include/string.h" 3
extern "C" char *strerror_r(int , char * , size_t ) throw()
# 439
 __attribute((__nonnull__(2))); 
# 445
extern "C" char *strerror_l(int , __locale_t ) throw(); 
# 451
extern "C" void __bzero(void * , size_t ) throw() __attribute((__nonnull__(1))); 
# 455
extern "C" void bcopy(const void * , void * , size_t ) throw()
# 456
 __attribute((__nonnull__(1, 2))); 
# 459
extern "C" void bzero(void * , size_t ) throw() __attribute((__nonnull__(1))); 
# 462
extern "C" int bcmp(const void * , const void * , size_t ) throw()
# 463
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 469
extern char *index(char * , int ) throw() __asm__("index")
# 470
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 471
extern const char *index(const char * , int ) throw() __asm__("index")
# 472
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 497 "/usr/include/string.h" 3
extern char *rindex(char * , int ) throw() __asm__("rindex")
# 498
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 499
extern const char *rindex(const char * , int ) throw() __asm__("rindex")
# 500
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 523 "/usr/include/string.h" 3
extern "C" int ffs(int ) throw() __attribute((const)); 
# 528
extern "C" int ffsl(long ) throw() __attribute((const)); 
# 530
__extension__ extern "C" int ffsll(long long ) throw()
# 531
 __attribute((const)); 
# 536
extern "C" int strcasecmp(const char * , const char * ) throw()
# 537
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 540
extern "C" int strncasecmp(const char * , const char * , size_t ) throw()
# 541
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 547
extern "C" int strcasecmp_l(const char * , const char * , __locale_t ) throw()
# 549
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 3))); 
# 551
extern "C" int strncasecmp_l(const char * , const char * , size_t , __locale_t ) throw()
# 553
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 4))); 
# 559
extern "C" char *strsep(char **__restrict__ , const char *__restrict__ ) throw()
# 561
 __attribute((__nonnull__(1, 2))); 
# 566
extern "C" char *strsignal(int ) throw(); 
# 569
extern "C" char *__stpcpy(char *__restrict__ , const char *__restrict__ ) throw()
# 570
 __attribute((__nonnull__(1, 2))); 
# 571
extern "C" char *stpcpy(char *__restrict__ , const char *__restrict__ ) throw()
# 572
 __attribute((__nonnull__(1, 2))); 
# 576
extern "C" char *__stpncpy(char *__restrict__ , const char *__restrict__ , size_t ) throw()
# 578
 __attribute((__nonnull__(1, 2))); 
# 579
extern "C" char *stpncpy(char *__restrict__ , const char *__restrict__ , size_t ) throw()
# 581
 __attribute((__nonnull__(1, 2))); 
# 586
extern "C" int strverscmp(const char * , const char * ) throw()
# 587
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 590
extern "C" char *strfry(char * ) throw() __attribute((__nonnull__(1))); 
# 593
extern "C" void *memfrob(void * , size_t ) throw() __attribute((__nonnull__(1))); 
# 601
char *basename(char * ) throw() __asm__("basename")
# 602
 __attribute((__nonnull__(1))); 
# 603
const char *basename(const char * ) throw() __asm__("basename")
# 604
 __attribute((__nonnull__(1))); 
# 31 "/usr/include/bits/types.h" 3
extern "C" { typedef unsigned char __u_char; }
# 32
extern "C" { typedef unsigned short __u_short; }
# 33
extern "C" { typedef unsigned __u_int; }
# 34
extern "C" { typedef unsigned long __u_long; }
# 37
extern "C" { typedef signed char __int8_t; }
# 38
extern "C" { typedef unsigned char __uint8_t; }
# 39
extern "C" { typedef signed short __int16_t; }
# 40
extern "C" { typedef unsigned short __uint16_t; }
# 41
extern "C" { typedef signed int __int32_t; }
# 42
extern "C" { typedef unsigned __uint32_t; }
# 44
extern "C" { typedef signed long __int64_t; }
# 45
extern "C" { typedef unsigned long __uint64_t; }
# 53
extern "C" { typedef long __quad_t; }
# 54
extern "C" { typedef unsigned long __u_quad_t; }
# 134 "/usr/include/bits/types.h" 3
extern "C" { typedef unsigned long __dev_t; }
# 135
extern "C" { typedef unsigned __uid_t; }
# 136
extern "C" { typedef unsigned __gid_t; }
# 137
extern "C" { typedef unsigned long __ino_t; }
# 138
extern "C" { typedef unsigned long __ino64_t; }
# 139
extern "C" { typedef unsigned __mode_t; }
# 140
extern "C" { typedef unsigned long __nlink_t; }
# 141
extern "C" { typedef long __off_t; }
# 142
extern "C" { typedef long __off64_t; }
# 143
extern "C" { typedef int __pid_t; }
# 144
extern "C" { typedef struct { int __val[2]; } __fsid_t; }
# 145
extern "C" { typedef long __clock_t; }
# 146
extern "C" { typedef unsigned long __rlim_t; }
# 147
extern "C" { typedef unsigned long __rlim64_t; }
# 148
extern "C" { typedef unsigned __id_t; }
# 149
extern "C" { typedef long __time_t; }
# 150
extern "C" { typedef unsigned __useconds_t; }
# 151
extern "C" { typedef long __suseconds_t; }
# 153
extern "C" { typedef int __daddr_t; }
# 154
extern "C" { typedef long __swblk_t; }
# 155
extern "C" { typedef int __key_t; }
# 158
extern "C" { typedef int __clockid_t; }
# 161
extern "C" { typedef void *__timer_t; }
# 164
extern "C" { typedef long __blksize_t; }
# 169
extern "C" { typedef long __blkcnt_t; }
# 170
extern "C" { typedef long __blkcnt64_t; }
# 173
extern "C" { typedef unsigned long __fsblkcnt_t; }
# 174
extern "C" { typedef unsigned long __fsblkcnt64_t; }
# 177
extern "C" { typedef unsigned long __fsfilcnt_t; }
# 178
extern "C" { typedef unsigned long __fsfilcnt64_t; }
# 180
extern "C" { typedef long __ssize_t; }
# 184
extern "C" { typedef __off64_t __loff_t; }
# 185
extern "C" { typedef __quad_t *__qaddr_t; }
# 186
extern "C" { typedef char *__caddr_t; }
# 189
extern "C" { typedef long __intptr_t; }
# 192
extern "C" { typedef unsigned __socklen_t; }
# 60 "/usr/include/time.h" 3
extern "C" { typedef __clock_t clock_t; }
# 76 "/usr/include/time.h" 3
extern "C" { typedef __time_t time_t; }
# 92 "/usr/include/time.h" 3
extern "C" { typedef __clockid_t clockid_t; }
# 104 "/usr/include/time.h" 3
extern "C" { typedef __timer_t timer_t; }
# 120 "/usr/include/time.h" 3
extern "C" { struct timespec { 
# 122
__time_t tv_sec; 
# 123
long tv_nsec; 
# 124
}; }
# 133
extern "C" { struct tm { 
# 135
int tm_sec; 
# 136
int tm_min; 
# 137
int tm_hour; 
# 138
int tm_mday; 
# 139
int tm_mon; 
# 140
int tm_year; 
# 141
int tm_wday; 
# 142
int tm_yday; 
# 143
int tm_isdst; 
# 146
long tm_gmtoff; 
# 147
const char *tm_zone; 
# 152
}; }
# 161
extern "C" { struct itimerspec { 
# 163
timespec it_interval; 
# 164
timespec it_value; 
# 165
}; }
# 168
struct sigevent; 
# 174
extern "C" { typedef __pid_t pid_t; }
# 183
extern "C" clock_t clock() throw(); 
# 186
extern "C" time_t time(time_t * ) throw(); 
# 189
extern "C" double difftime(time_t , time_t ) throw()
# 190
 __attribute((const)); 
# 193
extern "C" time_t mktime(tm * ) throw(); 
# 199
extern "C" size_t strftime(char *__restrict__ , size_t , const char *__restrict__ , const tm *__restrict__ ) throw(); 
# 207
extern "C" char *strptime(const char *__restrict__ , const char *__restrict__ , tm * ) throw(); 
# 217
extern "C" size_t strftime_l(char *__restrict__ , size_t , const char *__restrict__ , const tm *__restrict__ , __locale_t ) throw(); 
# 224
extern "C" char *strptime_l(const char *__restrict__ , const char *__restrict__ , tm * , __locale_t ) throw(); 
# 233
extern "C" tm *gmtime(const time_t * ) throw(); 
# 237
extern "C" tm *localtime(const time_t * ) throw(); 
# 243
extern "C" tm *gmtime_r(const time_t *__restrict__ , tm *__restrict__ ) throw(); 
# 248
extern "C" tm *localtime_r(const time_t *__restrict__ , tm *__restrict__ ) throw(); 
# 255
extern "C" char *asctime(const tm * ) throw(); 
# 258
extern "C" char *ctime(const time_t * ) throw(); 
# 266
extern "C" char *asctime_r(const tm *__restrict__ , char *__restrict__ ) throw(); 
# 270
extern "C" char *ctime_r(const time_t *__restrict__ , char *__restrict__ ) throw(); 
# 276
extern "C" { extern char *__tzname[2]; } 
# 277
extern "C" { extern int __daylight; } 
# 278
extern "C" { extern long __timezone; } 
# 283
extern "C" { extern char *tzname[2]; } 
# 287
extern "C" void tzset() throw(); 
# 291
extern "C" { extern int daylight; } 
# 292
extern "C" { extern long timezone; } 
# 298
extern "C" int stime(const time_t * ) throw(); 
# 313 "/usr/include/time.h" 3
extern "C" time_t timegm(tm * ) throw(); 
# 316
extern "C" time_t timelocal(tm * ) throw(); 
# 319
extern "C" int dysize(int ) throw() __attribute((const)); 
# 328 "/usr/include/time.h" 3
extern "C" int nanosleep(const timespec * , timespec * ); 
# 333
extern "C" int clock_getres(clockid_t , timespec * ) throw(); 
# 336
extern "C" int clock_gettime(clockid_t , timespec * ) throw(); 
# 339
extern "C" int clock_settime(clockid_t , const timespec * ) throw(); 
# 347
extern "C" int clock_nanosleep(clockid_t , int , const timespec * , timespec * ); 
# 352
extern "C" int clock_getcpuclockid(pid_t , clockid_t * ) throw(); 
# 357
extern "C" int timer_create(clockid_t , sigevent *__restrict__ , timer_t *__restrict__ ) throw(); 
# 362
extern "C" int timer_delete(timer_t ) throw(); 
# 365
extern "C" int timer_settime(timer_t , int , const itimerspec *__restrict__ , itimerspec *__restrict__ ) throw(); 
# 370
extern "C" int timer_gettime(timer_t , itimerspec * ) throw(); 
# 374
extern "C" int timer_getoverrun(timer_t ) throw(); 
# 390 "/usr/include/time.h" 3
extern "C" { extern int getdate_err; } 
# 399 "/usr/include/time.h" 3
extern "C" tm *getdate(const char * ); 
# 413 "/usr/include/time.h" 3
extern "C" int getdate_r(const char *__restrict__ , tm *__restrict__ ); 
# 69 "/usr/local/cuda/bin/..//include/common_functions.h"
extern "C" clock_t clock() throw(); 
# 70
extern "C" void *memset(void *, int, size_t) throw(); 
# 71
extern "C" void *memcpy(void *, const void *, size_t) throw(); 
# 141 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" int abs(int) throw(); 
# 142
extern "C" long labs(long) throw(); 
# 143
extern "C" long long llabs(long long) throw(); 
# 186 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double fabs(double ) throw(); 
# 227 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float fabsf(float ) throw(); 
# 228
extern "C" int min(int, int); 
# 229
extern "C" unsigned umin(unsigned, unsigned); 
# 230
extern "C" long long llmin(long long, long long); 
# 231
extern "C" unsigned long long ullmin(unsigned long long, unsigned long long); 
# 247 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float fminf(float , float ) throw(); 
# 263 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double fmin(double , double ) throw(); 
# 264
extern "C" int max(int, int); 
# 265
extern "C" unsigned umax(unsigned, unsigned); 
# 266
extern "C" long long llmax(long long, long long); 
# 267
extern "C" unsigned long long ullmax(unsigned long long, unsigned long long); 
# 283 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float fmaxf(float , float ) throw(); 
# 299 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double fmax(double, double) throw(); 
# 340 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double sin(double ) throw(); 
# 373 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double cos(double ) throw(); 
# 388 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" void sincos(double , double * , double * ) throw(); 
# 404 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" void sincosf(float , float * , float * ) throw(); 
# 445 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double tan(double ) throw(); 
# 514 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double sqrt(double ) throw(); 
# 583 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double rsqrt(double ); 
# 652 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float rsqrtf(float ); 
# 703 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double log2(double ) throw(); 
# 724 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double exp2(double ) throw(); 
# 745 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float exp2f(float ) throw(); 
# 766 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double exp10(double ) throw(); 
# 788 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float exp10f(float ) throw(); 
# 829 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double expm1(double ) throw(); 
# 870 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float expm1f(float ) throw(); 
# 921 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float log2f(float ) throw(); 
# 972 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double log10(double ) throw(); 
# 1043 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double log(double ) throw(); 
# 1136 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double log1p(double ) throw(); 
# 1229 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float log1pf(float ) throw(); 
# 1301 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double floor(double ) throw(); 
# 1340 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double exp(double ) throw(); 
# 1371 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double cosh(double ) throw(); 
# 1401 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double sinh(double ) throw(); 
# 1431 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double tanh(double ) throw(); 
# 1465 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double acosh(double ) throw(); 
# 1499 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float acoshf(float ) throw(); 
# 1511 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double asinh(double ) throw(); 
# 1523 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float asinhf(float ) throw(); 
# 1573 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double atanh(double ) throw(); 
# 1623 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float atanhf(float ) throw(); 
# 1679 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double ldexp(double , int ) throw(); 
# 1735 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float ldexpf(float , int ) throw(); 
# 1786 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double logb(double ) throw(); 
# 1837 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float logbf(float ) throw(); 
# 1863 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" int ilogb(double ) throw(); 
# 1889 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" int ilogbf(float ) throw(); 
# 1961 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double scalbn(double , int ) throw(); 
# 2033 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float scalbnf(float , int ) throw(); 
# 2105 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double scalbln(double , long ) throw(); 
# 2177 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float scalblnf(float , long ) throw(); 
# 2252 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double frexp(double , int * ) throw(); 
# 2327 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float frexpf(float , int * ) throw(); 
# 2340 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double round(double ) throw(); 
# 2353 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float roundf(float ) throw(); 
# 2367 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" long lround(double ) throw(); 
# 2381 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" long lroundf(float ) throw(); 
# 2395 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" long long llround(double ) throw(); 
# 2409 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" long long llroundf(float ) throw(); 
# 2420 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double rint(double ) throw(); 
# 2431 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float rintf(float ) throw(); 
# 2443 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" long lrint(double ) throw(); 
# 2455 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" long lrintf(float ) throw(); 
# 2467 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" long long llrint(double ) throw(); 
# 2479 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" long long llrintf(float ) throw(); 
# 2528 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double nearbyint(double ) throw(); 
# 2577 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float nearbyintf(float ) throw(); 
# 2636 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double ceil(double ) throw(); 
# 2647 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double trunc(double ) throw(); 
# 2658 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float truncf(float ) throw(); 
# 2680 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double fdim(double , double ) throw(); 
# 2702 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float fdimf(float , float ) throw(); 
# 2735 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double atan2(double , double ) throw(); 
# 2766 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double atan(double ) throw(); 
# 2789 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double acos(double ) throw(); 
# 2821 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double asin(double ) throw(); 
# 2861 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double hypot(double , double ) throw(); 
# 2904 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float hypotf(float , float ) throw(); 
# 2989 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double cbrt(double ) throw(); 
# 3071 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float cbrtf(float ) throw(); 
# 3120 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double rcbrt(double ); 
# 3169 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float rcbrtf(float ); 
# 3229 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double sinpi(double ); 
# 3289 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float sinpif(float ); 
# 3341 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double cospi(double ); 
# 3393 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float cospif(float ); 
# 3423 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" void sincospi(double , double * , double * ); 
# 3453 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" void sincospif(float , float * , float * ); 
# 3761 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double pow(double , double ) throw(); 
# 3817 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double modf(double , double * ) throw(); 
# 3876 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double fmod(double , double ) throw(); 
# 3961 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double remainder(double , double ) throw(); 
# 4047 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float remainderf(float , float ) throw(); 
# 4097 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double remquo(double , double , int * ) throw(); 
# 4147 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float remquof(float , float , int * ) throw(); 
# 4185 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double j0(double ) throw(); 
# 4223 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float j0f(float ) throw(); 
# 4280 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double j1(double ) throw(); 
# 4337 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float j1f(float ) throw(); 
# 4376 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double jn(int , double ) throw(); 
# 4415 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float jnf(int , float ) throw(); 
# 4463 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double y0(double ) throw(); 
# 4511 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float y0f(float ) throw(); 
# 4559 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double y1(double ) throw(); 
# 4607 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float y1f(float ) throw(); 
# 4656 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double yn(int , double ) throw(); 
# 4705 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float ynf(int , float ) throw(); 
# 4783 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double erf(double ) throw(); 
# 4861 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float erff(float ) throw(); 
# 4918 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double erfinv(double ); 
# 4975 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float erfinvf(float ); 
# 5009 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double erfc(double ) throw(); 
# 5043 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float erfcf(float ) throw(); 
# 5167 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double lgamma(double ) throw(); 
# 5223 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double erfcinv(double ); 
# 5279 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float erfcinvf(float ); 
# 5337 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double normcdfinv(double ); 
# 5395 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float normcdfinvf(float ); 
# 5438 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double normcdf(double ); 
# 5481 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float normcdff(float ); 
# 5556 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double erfcx(double ); 
# 5631 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float erfcxf(float ); 
# 5760 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float lgammaf(float ) throw(); 
# 5865 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double tgamma(double ) throw(); 
# 5970 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float tgammaf(float ) throw(); 
# 5979 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double copysign(double , double ) throw(); 
# 5988 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float copysignf(float , float ) throw(); 
# 6021 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double nextafter(double , double ) throw(); 
# 6054 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float nextafterf(float , float ) throw(); 
# 6066 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double nan(const char * ) throw(); 
# 6078 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float nanf(const char * ) throw(); 
# 6079
extern "C" int __isinff(float) throw(); 
# 6080
extern "C" int __isnanf(float) throw(); 
# 6089 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" int __finite(double) throw(); 
# 6090
extern "C" int __finitef(float) throw(); 
# 6091
extern "C" int __signbit(double) throw(); 
# 6092
extern "C" int __isnan(double) throw(); 
# 6093
extern "C" int __isinf(double) throw(); 
# 6096
extern "C" int __signbitf(float) throw(); 
# 6250 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" double fma(double , double , double ) throw(); 
# 6404 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float fmaf(float , float , float ) throw(); 
# 6409
extern "C" int __signbitl(long double) throw(); 
# 6415
extern "C" int __finitel(long double) throw(); 
# 6416
extern "C" int __isinfl(long double) throw(); 
# 6417
extern "C" int __isnanl(long double) throw(); 
# 6464 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float acosf(float ) throw(); 
# 6504 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float asinf(float ) throw(); 
# 6544 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float atanf(float ) throw(); 
# 6577 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float atan2f(float , float ) throw(); 
# 6601 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float cosf(float ) throw(); 
# 6643 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float sinf(float ) throw(); 
# 6685 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float tanf(float ) throw(); 
# 6709 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float coshf(float ) throw(); 
# 6750 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float sinhf(float ) throw(); 
# 6780 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float tanhf(float ) throw(); 
# 6831 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float logf(float ) throw(); 
# 6881 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float expf(float ) throw(); 
# 6932 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float log10f(float ) throw(); 
# 6987 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float modff(float , float * ) throw(); 
# 7295 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float powf(float , float ) throw(); 
# 7364 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float sqrtf(float ) throw(); 
# 7423 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float ceilf(float ) throw(); 
# 7495 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float floorf(float ) throw(); 
# 7554 "/usr/local/cuda/bin/..//include/math_functions.h"
extern "C" float fmodf(float , float ) throw(); 
# 31 "/usr/include/bits/mathdef.h" 3
extern "C" { typedef float float_t; }
# 32
extern "C" { typedef double double_t; }
# 55 "/usr/include/bits/mathcalls.h" 3
extern "C" double acos(double ) throw(); extern "C" double __acos(double ) throw(); 
# 57
extern "C" double asin(double ) throw(); extern "C" double __asin(double ) throw(); 
# 59
extern "C" double atan(double ) throw(); extern "C" double __atan(double ) throw(); 
# 61
extern "C" double atan2(double , double ) throw(); extern "C" double __atan2(double , double ) throw(); 
# 64
extern "C" double cos(double ) throw(); extern "C" double __cos(double ) throw(); 
# 66
extern "C" double sin(double ) throw(); extern "C" double __sin(double ) throw(); 
# 68
extern "C" double tan(double ) throw(); extern "C" double __tan(double ) throw(); 
# 73
extern "C" double cosh(double ) throw(); extern "C" double __cosh(double ) throw(); 
# 75
extern "C" double sinh(double ) throw(); extern "C" double __sinh(double ) throw(); 
# 77
extern "C" double tanh(double ) throw(); extern "C" double __tanh(double ) throw(); 
# 82
extern "C" void sincos(double , double * , double * ) throw(); extern "C" void __sincos(double , double * , double * ) throw(); 
# 89
extern "C" double acosh(double ) throw(); extern "C" double __acosh(double ) throw(); 
# 91
extern "C" double asinh(double ) throw(); extern "C" double __asinh(double ) throw(); 
# 93
extern "C" double atanh(double ) throw(); extern "C" double __atanh(double ) throw(); 
# 101
extern "C" double exp(double ) throw(); extern "C" double __exp(double ) throw(); 
# 104
extern "C" double frexp(double , int * ) throw(); extern "C" double __frexp(double , int * ) throw(); 
# 107
extern "C" double ldexp(double , int ) throw(); extern "C" double __ldexp(double , int ) throw(); 
# 110
extern "C" double log(double ) throw(); extern "C" double __log(double ) throw(); 
# 113
extern "C" double log10(double ) throw(); extern "C" double __log10(double ) throw(); 
# 116
extern "C" double modf(double , double * ) throw(); extern "C" double __modf(double , double * ) throw(); 
# 121
extern "C" double exp10(double ) throw(); extern "C" double __exp10(double ) throw(); 
# 123
extern "C" double pow10(double ) throw(); extern "C" double __pow10(double ) throw(); 
# 129
extern "C" double expm1(double ) throw(); extern "C" double __expm1(double ) throw(); 
# 132
extern "C" double log1p(double ) throw(); extern "C" double __log1p(double ) throw(); 
# 135
extern "C" double logb(double ) throw(); extern "C" double __logb(double ) throw(); 
# 142
extern "C" double exp2(double ) throw(); extern "C" double __exp2(double ) throw(); 
# 145
extern "C" double log2(double ) throw(); extern "C" double __log2(double ) throw(); 
# 154
extern "C" double pow(double , double ) throw(); extern "C" double __pow(double , double ) throw(); 
# 157
extern "C" double sqrt(double ) throw(); extern "C" double __sqrt(double ) throw(); 
# 163
extern "C" double hypot(double , double ) throw(); extern "C" double __hypot(double , double ) throw(); 
# 170
extern "C" double cbrt(double ) throw(); extern "C" double __cbrt(double ) throw(); 
# 179
extern "C" double ceil(double ) throw() __attribute((const)); extern "C" double __ceil(double ) throw() __attribute((const)); 
# 182
extern "C" double fabs(double ) throw() __attribute((const)); extern "C" double __fabs(double ) throw() __attribute((const)); 
# 185
extern "C" double floor(double ) throw() __attribute((const)); extern "C" double __floor(double ) throw() __attribute((const)); 
# 188
extern "C" double fmod(double , double ) throw(); extern "C" double __fmod(double , double ) throw(); 
# 193
extern "C" int __isinf(double ) throw() __attribute((const)); 
# 196
extern "C" int __finite(double ) throw() __attribute((const)); 
# 202
extern "C" int isinf(double ) throw() __attribute((const)); 
# 205
extern "C" int finite(double ) throw() __attribute((const)); 
# 208
extern "C" double drem(double , double ) throw(); extern "C" double __drem(double , double ) throw(); 
# 212
extern "C" double significand(double ) throw(); extern "C" double __significand(double ) throw(); 
# 218
extern "C" double copysign(double , double ) throw() __attribute((const)); extern "C" double __copysign(double , double ) throw() __attribute((const)); 
# 225
extern "C" double nan(const char * ) throw() __attribute((const)); extern "C" double __nan(const char * ) throw() __attribute((const)); 
# 231
extern "C" int __isnan(double ) throw() __attribute((const)); 
# 235
extern "C" int isnan(double ) throw() __attribute((const)); 
# 238
extern "C" double j0(double) throw(); extern "C" double __j0(double) throw(); 
# 239
extern "C" double j1(double) throw(); extern "C" double __j1(double) throw(); 
# 240
extern "C" double jn(int, double) throw(); extern "C" double __jn(int, double) throw(); 
# 241
extern "C" double y0(double) throw(); extern "C" double __y0(double) throw(); 
# 242
extern "C" double y1(double) throw(); extern "C" double __y1(double) throw(); 
# 243
extern "C" double yn(int, double) throw(); extern "C" double __yn(int, double) throw(); 
# 250
extern "C" double erf(double) throw(); extern "C" double __erf(double) throw(); 
# 251
extern "C" double erfc(double) throw(); extern "C" double __erfc(double) throw(); 
# 252
extern "C" double lgamma(double) throw(); extern "C" double __lgamma(double) throw(); 
# 259
extern "C" double tgamma(double) throw(); extern "C" double __tgamma(double) throw(); 
# 265
extern "C" double gamma(double) throw(); extern "C" double __gamma(double) throw(); 
# 272
extern "C" double lgamma_r(double, int * ) throw(); extern "C" double __lgamma_r(double, int * ) throw(); 
# 280
extern "C" double rint(double ) throw(); extern "C" double __rint(double ) throw(); 
# 283
extern "C" double nextafter(double , double ) throw() __attribute((const)); extern "C" double __nextafter(double , double ) throw() __attribute((const)); 
# 285
extern "C" double nexttoward(double , long double ) throw() __attribute((const)); extern "C" double __nexttoward(double , long double ) throw() __attribute((const)); 
# 289
extern "C" double remainder(double , double ) throw(); extern "C" double __remainder(double , double ) throw(); 
# 293
extern "C" double scalbn(double , int ) throw(); extern "C" double __scalbn(double , int ) throw(); 
# 297
extern "C" int ilogb(double ) throw(); extern "C" int __ilogb(double ) throw(); 
# 302
extern "C" double scalbln(double , long ) throw(); extern "C" double __scalbln(double , long ) throw(); 
# 306
extern "C" double nearbyint(double ) throw(); extern "C" double __nearbyint(double ) throw(); 
# 310
extern "C" double round(double ) throw() __attribute((const)); extern "C" double __round(double ) throw() __attribute((const)); 
# 314
extern "C" double trunc(double ) throw() __attribute((const)); extern "C" double __trunc(double ) throw() __attribute((const)); 
# 319
extern "C" double remquo(double , double , int * ) throw(); extern "C" double __remquo(double , double , int * ) throw(); 
# 326
extern "C" long lrint(double ) throw(); extern "C" long __lrint(double ) throw(); 
# 327
extern "C" long long llrint(double ) throw(); extern "C" long long __llrint(double ) throw(); 
# 331
extern "C" long lround(double ) throw(); extern "C" long __lround(double ) throw(); 
# 332
extern "C" long long llround(double ) throw(); extern "C" long long __llround(double ) throw(); 
# 336
extern "C" double fdim(double , double ) throw(); extern "C" double __fdim(double , double ) throw(); 
# 339
extern "C" double fmax(double , double ) throw(); extern "C" double __fmax(double , double ) throw(); 
# 342
extern "C" double fmin(double , double ) throw(); extern "C" double __fmin(double , double ) throw(); 
# 346
extern "C" int __fpclassify(double ) throw()
# 347
 __attribute((const)); 
# 350
extern "C" int __signbit(double ) throw()
# 351
 __attribute((const)); 
# 355
extern "C" double fma(double , double , double ) throw(); extern "C" double __fma(double , double , double ) throw(); 
# 364
extern "C" double scalb(double , double ) throw(); extern "C" double __scalb(double , double ) throw(); 
# 55 "/usr/include/bits/mathcalls.h" 3
extern "C" float acosf(float ) throw(); extern "C" float __acosf(float ) throw(); 
# 57
extern "C" float asinf(float ) throw(); extern "C" float __asinf(float ) throw(); 
# 59
extern "C" float atanf(float ) throw(); extern "C" float __atanf(float ) throw(); 
# 61
extern "C" float atan2f(float , float ) throw(); extern "C" float __atan2f(float , float ) throw(); 
# 64
extern "C" float cosf(float ) throw(); 
# 66
extern "C" float sinf(float ) throw(); 
# 68
extern "C" float tanf(float ) throw(); 
# 73
extern "C" float coshf(float ) throw(); extern "C" float __coshf(float ) throw(); 
# 75
extern "C" float sinhf(float ) throw(); extern "C" float __sinhf(float ) throw(); 
# 77
extern "C" float tanhf(float ) throw(); extern "C" float __tanhf(float ) throw(); 
# 83
extern "C" void sincosf(float , float * , float * ) throw(); 
# 89 "/usr/include/bits/mathcalls.h" 3
extern "C" float acoshf(float ) throw(); extern "C" float __acoshf(float ) throw(); 
# 91
extern "C" float asinhf(float ) throw(); extern "C" float __asinhf(float ) throw(); 
# 93
extern "C" float atanhf(float ) throw(); extern "C" float __atanhf(float ) throw(); 
# 101
extern "C" float expf(float ) throw(); 
# 104
extern "C" float frexpf(float , int * ) throw(); extern "C" float __frexpf(float , int * ) throw(); 
# 107
extern "C" float ldexpf(float , int ) throw(); extern "C" float __ldexpf(float , int ) throw(); 
# 110
extern "C" float logf(float ) throw(); 
# 113
extern "C" float log10f(float ) throw(); 
# 116
extern "C" float modff(float , float * ) throw(); extern "C" float __modff(float , float * ) throw(); 
# 121
extern "C" float exp10f(float ) throw(); 
# 123
extern "C" float pow10f(float ) throw(); extern "C" float __pow10f(float ) throw(); 
# 129
extern "C" float expm1f(float ) throw(); extern "C" float __expm1f(float ) throw(); 
# 132
extern "C" float log1pf(float ) throw(); extern "C" float __log1pf(float ) throw(); 
# 135
extern "C" float logbf(float ) throw(); extern "C" float __logbf(float ) throw(); 
# 142
extern "C" float exp2f(float ) throw(); extern "C" float __exp2f(float ) throw(); 
# 145
extern "C" float log2f(float ) throw(); 
# 154
extern "C" float powf(float , float ) throw(); 
# 157
extern "C" float sqrtf(float ) throw(); extern "C" float __sqrtf(float ) throw(); 
# 163
extern "C" float hypotf(float , float ) throw(); extern "C" float __hypotf(float , float ) throw(); 
# 170
extern "C" float cbrtf(float ) throw(); extern "C" float __cbrtf(float ) throw(); 
# 179
extern "C" float ceilf(float ) throw() __attribute((const)); extern "C" float __ceilf(float ) throw() __attribute((const)); 
# 182
extern "C" float fabsf(float ) throw() __attribute((const)); extern "C" float __fabsf(float ) throw() __attribute((const)); 
# 185
extern "C" float floorf(float ) throw() __attribute((const)); extern "C" float __floorf(float ) throw() __attribute((const)); 
# 188
extern "C" float fmodf(float , float ) throw(); extern "C" float __fmodf(float , float ) throw(); 
# 193
extern "C" int __isinff(float ) throw() __attribute((const)); 
# 196
extern "C" int __finitef(float ) throw() __attribute((const)); 
# 202
extern "C" int isinff(float ) throw() __attribute((const)); 
# 205
extern "C" int finitef(float ) throw() __attribute((const)); 
# 208
extern "C" float dremf(float , float ) throw(); extern "C" float __dremf(float , float ) throw(); 
# 212
extern "C" float significandf(float ) throw(); extern "C" float __significandf(float ) throw(); 
# 218
extern "C" float copysignf(float , float ) throw() __attribute((const)); extern "C" float __copysignf(float , float ) throw() __attribute((const)); 
# 225
extern "C" float nanf(const char * ) throw() __attribute((const)); extern "C" float __nanf(const char * ) throw() __attribute((const)); 
# 231
extern "C" int __isnanf(float ) throw() __attribute((const)); 
# 235
extern "C" int isnanf(float ) throw() __attribute((const)); 
# 238
extern "C" float j0f(float) throw(); extern "C" float __j0f(float) throw(); 
# 239
extern "C" float j1f(float) throw(); extern "C" float __j1f(float) throw(); 
# 240
extern "C" float jnf(int, float) throw(); extern "C" float __jnf(int, float) throw(); 
# 241
extern "C" float y0f(float) throw(); extern "C" float __y0f(float) throw(); 
# 242
extern "C" float y1f(float) throw(); extern "C" float __y1f(float) throw(); 
# 243
extern "C" float ynf(int, float) throw(); extern "C" float __ynf(int, float) throw(); 
# 250
extern "C" float erff(float) throw(); extern "C" float __erff(float) throw(); 
# 251
extern "C" float erfcf(float) throw(); extern "C" float __erfcf(float) throw(); 
# 252
extern "C" float lgammaf(float) throw(); extern "C" float __lgammaf(float) throw(); 
# 259
extern "C" float tgammaf(float) throw(); extern "C" float __tgammaf(float) throw(); 
# 265
extern "C" float gammaf(float) throw(); extern "C" float __gammaf(float) throw(); 
# 272
extern "C" float lgammaf_r(float, int * ) throw(); extern "C" float __lgammaf_r(float, int * ) throw(); 
# 280
extern "C" float rintf(float ) throw(); extern "C" float __rintf(float ) throw(); 
# 283
extern "C" float nextafterf(float , float ) throw() __attribute((const)); extern "C" float __nextafterf(float , float ) throw() __attribute((const)); 
# 285
extern "C" float nexttowardf(float , long double ) throw() __attribute((const)); extern "C" float __nexttowardf(float , long double ) throw() __attribute((const)); 
# 289
extern "C" float remainderf(float , float ) throw(); extern "C" float __remainderf(float , float ) throw(); 
# 293
extern "C" float scalbnf(float , int ) throw(); extern "C" float __scalbnf(float , int ) throw(); 
# 297
extern "C" int ilogbf(float ) throw(); extern "C" int __ilogbf(float ) throw(); 
# 302
extern "C" float scalblnf(float , long ) throw(); extern "C" float __scalblnf(float , long ) throw(); 
# 306
extern "C" float nearbyintf(float ) throw(); extern "C" float __nearbyintf(float ) throw(); 
# 310
extern "C" float roundf(float ) throw() __attribute((const)); extern "C" float __roundf(float ) throw() __attribute((const)); 
# 314
extern "C" float truncf(float ) throw() __attribute((const)); extern "C" float __truncf(float ) throw() __attribute((const)); 
# 319
extern "C" float remquof(float , float , int * ) throw(); extern "C" float __remquof(float , float , int * ) throw(); 
# 326
extern "C" long lrintf(float ) throw(); extern "C" long __lrintf(float ) throw(); 
# 327
extern "C" long long llrintf(float ) throw(); extern "C" long long __llrintf(float ) throw(); 
# 331
extern "C" long lroundf(float ) throw(); extern "C" long __lroundf(float ) throw(); 
# 332
extern "C" long long llroundf(float ) throw(); extern "C" long long __llroundf(float ) throw(); 
# 336
extern "C" float fdimf(float , float ) throw(); extern "C" float __fdimf(float , float ) throw(); 
# 339
extern "C" float fmaxf(float , float ) throw(); extern "C" float __fmaxf(float , float ) throw(); 
# 342
extern "C" float fminf(float , float ) throw(); extern "C" float __fminf(float , float ) throw(); 
# 346
extern "C" int __fpclassifyf(float ) throw()
# 347
 __attribute((const)); 
# 350
extern "C" int __signbitf(float ) throw()
# 351
 __attribute((const)); 
# 355
extern "C" float fmaf(float , float , float ) throw(); extern "C" float __fmaf(float , float , float ) throw(); 
# 364
extern "C" float scalbf(float , float ) throw(); extern "C" float __scalbf(float , float ) throw(); 
# 55 "/usr/include/bits/mathcalls.h" 3
extern "C" long double acosl(long double ) throw(); extern "C" long double __acosl(long double ) throw(); 
# 57
extern "C" long double asinl(long double ) throw(); extern "C" long double __asinl(long double ) throw(); 
# 59
extern "C" long double atanl(long double ) throw(); extern "C" long double __atanl(long double ) throw(); 
# 61
extern "C" long double atan2l(long double , long double ) throw(); extern "C" long double __atan2l(long double , long double ) throw(); 
# 64
extern "C" long double cosl(long double ) throw(); extern "C" long double __cosl(long double ) throw(); 
# 66
extern "C" long double sinl(long double ) throw(); extern "C" long double __sinl(long double ) throw(); 
# 68
extern "C" long double tanl(long double ) throw(); extern "C" long double __tanl(long double ) throw(); 
# 73
extern "C" long double coshl(long double ) throw(); extern "C" long double __coshl(long double ) throw(); 
# 75
extern "C" long double sinhl(long double ) throw(); extern "C" long double __sinhl(long double ) throw(); 
# 77
extern "C" long double tanhl(long double ) throw(); extern "C" long double __tanhl(long double ) throw(); 
# 83
extern "C" void sincosl(long double , long double * , long double * ) throw(); 
# 83 "/usr/include/bits/mathcalls.h" 3
extern "C" void __sincosl(long double , long double * , long double * ) throw(); 
# 89 "/usr/include/bits/mathcalls.h" 3
extern "C" long double acoshl(long double ) throw(); extern "C" long double __acoshl(long double ) throw(); 
# 91
extern "C" long double asinhl(long double ) throw(); extern "C" long double __asinhl(long double ) throw(); 
# 93
extern "C" long double atanhl(long double ) throw(); extern "C" long double __atanhl(long double ) throw(); 
# 101
extern "C" long double expl(long double ) throw(); extern "C" long double __expl(long double ) throw(); 
# 104
extern "C" long double frexpl(long double , int * ) throw(); extern "C" long double __frexpl(long double , int * ) throw(); 
# 107
extern "C" long double ldexpl(long double , int ) throw(); extern "C" long double __ldexpl(long double , int ) throw(); 
# 110
extern "C" long double logl(long double ) throw(); extern "C" long double __logl(long double ) throw(); 
# 113
extern "C" long double log10l(long double ) throw(); extern "C" long double __log10l(long double ) throw(); 
# 116
extern "C" long double modfl(long double , long double * ) throw(); extern "C" long double __modfl(long double , long double * ) throw(); 
# 121
extern "C" long double exp10l(long double ) throw(); extern "C" long double __exp10l(long double ) throw(); 
# 123
extern "C" long double pow10l(long double ) throw(); extern "C" long double __pow10l(long double ) throw(); 
# 129
extern "C" long double expm1l(long double ) throw(); extern "C" long double __expm1l(long double ) throw(); 
# 132
extern "C" long double log1pl(long double ) throw(); extern "C" long double __log1pl(long double ) throw(); 
# 135
extern "C" long double logbl(long double ) throw(); extern "C" long double __logbl(long double ) throw(); 
# 142
extern "C" long double exp2l(long double ) throw(); extern "C" long double __exp2l(long double ) throw(); 
# 145
extern "C" long double log2l(long double ) throw(); extern "C" long double __log2l(long double ) throw(); 
# 154
extern "C" long double powl(long double , long double ) throw(); extern "C" long double __powl(long double , long double ) throw(); 
# 157
extern "C" long double sqrtl(long double ) throw(); extern "C" long double __sqrtl(long double ) throw(); 
# 163
extern "C" long double hypotl(long double , long double ) throw(); extern "C" long double __hypotl(long double , long double ) throw(); 
# 170
extern "C" long double cbrtl(long double ) throw(); extern "C" long double __cbrtl(long double ) throw(); 
# 179
extern "C" long double ceill(long double ) throw() __attribute((const)); extern "C" long double __ceill(long double ) throw() __attribute((const)); 
# 182
extern "C" long double fabsl(long double ) throw() __attribute((const)); extern "C" long double __fabsl(long double ) throw() __attribute((const)); 
# 185
extern "C" long double floorl(long double ) throw() __attribute((const)); extern "C" long double __floorl(long double ) throw() __attribute((const)); 
# 188
extern "C" long double fmodl(long double , long double ) throw(); extern "C" long double __fmodl(long double , long double ) throw(); 
# 193
extern "C" int __isinfl(long double ) throw() __attribute((const)); 
# 196
extern "C" int __finitel(long double ) throw() __attribute((const)); 
# 202
extern "C" int isinfl(long double ) throw() __attribute((const)); 
# 205
extern "C" int finitel(long double ) throw() __attribute((const)); 
# 208
extern "C" long double dreml(long double , long double ) throw(); extern "C" long double __dreml(long double , long double ) throw(); 
# 212
extern "C" long double significandl(long double ) throw(); extern "C" long double __significandl(long double ) throw(); 
# 218
extern "C" long double copysignl(long double , long double ) throw() __attribute((const)); extern "C" long double __copysignl(long double , long double ) throw() __attribute((const)); 
# 225
extern "C" long double nanl(const char * ) throw() __attribute((const)); extern "C" long double __nanl(const char * ) throw() __attribute((const)); 
# 231
extern "C" int __isnanl(long double ) throw() __attribute((const)); 
# 235
extern "C" int isnanl(long double ) throw() __attribute((const)); 
# 238
extern "C" long double j0l(long double) throw(); extern "C" long double __j0l(long double) throw(); 
# 239
extern "C" long double j1l(long double) throw(); extern "C" long double __j1l(long double) throw(); 
# 240
extern "C" long double jnl(int, long double) throw(); extern "C" long double __jnl(int, long double) throw(); 
# 241
extern "C" long double y0l(long double) throw(); extern "C" long double __y0l(long double) throw(); 
# 242
extern "C" long double y1l(long double) throw(); extern "C" long double __y1l(long double) throw(); 
# 243
extern "C" long double ynl(int, long double) throw(); extern "C" long double __ynl(int, long double) throw(); 
# 250
extern "C" long double erfl(long double) throw(); extern "C" long double __erfl(long double) throw(); 
# 251
extern "C" long double erfcl(long double) throw(); extern "C" long double __erfcl(long double) throw(); 
# 252
extern "C" long double lgammal(long double) throw(); extern "C" long double __lgammal(long double) throw(); 
# 259
extern "C" long double tgammal(long double) throw(); extern "C" long double __tgammal(long double) throw(); 
# 265
extern "C" long double gammal(long double) throw(); extern "C" long double __gammal(long double) throw(); 
# 272
extern "C" long double lgammal_r(long double, int * ) throw(); extern "C" long double __lgammal_r(long double, int * ) throw(); 
# 280
extern "C" long double rintl(long double ) throw(); extern "C" long double __rintl(long double ) throw(); 
# 283
extern "C" long double nextafterl(long double , long double ) throw() __attribute((const)); extern "C" long double __nextafterl(long double , long double ) throw() __attribute((const)); 
# 285
extern "C" long double nexttowardl(long double , long double ) throw() __attribute((const)); extern "C" long double __nexttowardl(long double , long double ) throw() __attribute((const)); 
# 289
extern "C" long double remainderl(long double , long double ) throw(); extern "C" long double __remainderl(long double , long double ) throw(); 
# 293
extern "C" long double scalbnl(long double , int ) throw(); extern "C" long double __scalbnl(long double , int ) throw(); 
# 297
extern "C" int ilogbl(long double ) throw(); extern "C" int __ilogbl(long double ) throw(); 
# 302
extern "C" long double scalblnl(long double , long ) throw(); extern "C" long double __scalblnl(long double , long ) throw(); 
# 306
extern "C" long double nearbyintl(long double ) throw(); extern "C" long double __nearbyintl(long double ) throw(); 
# 310
extern "C" long double roundl(long double ) throw() __attribute((const)); extern "C" long double __roundl(long double ) throw() __attribute((const)); 
# 314
extern "C" long double truncl(long double ) throw() __attribute((const)); extern "C" long double __truncl(long double ) throw() __attribute((const)); 
# 319
extern "C" long double remquol(long double , long double , int * ) throw(); extern "C" long double __remquol(long double , long double , int * ) throw(); 
# 326
extern "C" long lrintl(long double ) throw(); extern "C" long __lrintl(long double ) throw(); 
# 327
extern "C" long long llrintl(long double ) throw(); extern "C" long long __llrintl(long double ) throw(); 
# 331
extern "C" long lroundl(long double ) throw(); extern "C" long __lroundl(long double ) throw(); 
# 332
extern "C" long long llroundl(long double ) throw(); extern "C" long long __llroundl(long double ) throw(); 
# 336
extern "C" long double fdiml(long double , long double ) throw(); extern "C" long double __fdiml(long double , long double ) throw(); 
# 339
extern "C" long double fmaxl(long double , long double ) throw(); extern "C" long double __fmaxl(long double , long double ) throw(); 
# 342
extern "C" long double fminl(long double , long double ) throw(); extern "C" long double __fminl(long double , long double ) throw(); 
# 346
extern "C" int __fpclassifyl(long double ) throw()
# 347
 __attribute((const)); 
# 350
extern "C" int __signbitl(long double ) throw()
# 351
 __attribute((const)); 
# 355
extern "C" long double fmal(long double , long double , long double ) throw(); extern "C" long double __fmal(long double , long double , long double ) throw(); 
# 364
extern "C" long double scalbl(long double , long double ) throw(); extern "C" long double __scalbl(long double , long double ) throw(); 
# 157 "/usr/include/math.h" 3
extern "C" { extern int signgam; } 
# 199 "/usr/include/math.h" 3
enum { 
# 200
FP_NAN, 
# 202
FP_INFINITE, 
# 204
FP_ZERO, 
# 206
FP_SUBNORMAL, 
# 208
FP_NORMAL
# 210
}; 
# 298 "/usr/include/math.h" 3
extern "C" { typedef 
# 292
enum { 
# 293
_IEEE_ = (-1), 
# 294
_SVID_ = 0, 
# 295
_XOPEN_, 
# 296
_POSIX_, 
# 297
_ISOC_
# 298
} _LIB_VERSION_TYPE; }
# 303
extern "C" { extern _LIB_VERSION_TYPE _LIB_VERSION; } 
# 314 "/usr/include/math.h" 3
extern "C" { struct __exception { 
# 319
int type; 
# 320
char *name; 
# 321
double arg1; 
# 322
double arg2; 
# 323
double retval; 
# 324
}; }
# 327
extern "C" int matherr(__exception * ) throw(); 
# 67 "/usr/include/bits/waitstatus.h" 3
extern "C" { union wait { 
# 69
int w_status; 
# 71
struct { 
# 73
unsigned __w_termsig:7; 
# 74
unsigned __w_coredump:1; 
# 75
unsigned __w_retcode:8; 
# 76
unsigned:16; 
# 84
} __wait_terminated; 
# 86
struct { 
# 88
unsigned __w_stopval:8; 
# 89
unsigned __w_stopsig:8; 
# 90
unsigned:16; 
# 97
} __wait_stopped; 
# 98
}; }
# 102 "/usr/include/stdlib.h" 3
extern "C" { typedef 
# 99
struct { 
# 100
int quot; 
# 101
int rem; 
# 102
} div_t; }
# 110
extern "C" { typedef 
# 107
struct { 
# 108
long quot; 
# 109
long rem; 
# 110
} ldiv_t; }
# 122
__extension__ extern "C" { typedef 
# 119
struct { 
# 120
long long quot; 
# 121
long long rem; 
# 122
} lldiv_t; }
# 140 "/usr/include/stdlib.h" 3
extern "C" size_t __ctype_get_mb_cur_max() throw(); 
# 145
extern "C" double atof(const char * ) throw()
# 146
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 148
extern "C" int atoi(const char * ) throw()
# 149
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 151
extern "C" long atol(const char * ) throw()
# 152
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 158
__extension__ extern "C" long long atoll(const char * ) throw()
# 159
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 165
extern "C" double strtod(const char *__restrict__ , char **__restrict__ ) throw()
# 167
 __attribute((__nonnull__(1))); 
# 173
extern "C" float strtof(const char *__restrict__ , char **__restrict__ ) throw()
# 174
 __attribute((__nonnull__(1))); 
# 176
extern "C" long double strtold(const char *__restrict__ , char **__restrict__ ) throw()
# 178
 __attribute((__nonnull__(1))); 
# 184
extern "C" long strtol(const char *__restrict__ , char **__restrict__ , int ) throw()
# 186
 __attribute((__nonnull__(1))); 
# 188
extern "C" unsigned long strtoul(const char *__restrict__ , char **__restrict__ , int ) throw()
# 190
 __attribute((__nonnull__(1))); 
# 196
__extension__ extern "C" long long strtoq(const char *__restrict__ , char **__restrict__ , int ) throw()
# 198
 __attribute((__nonnull__(1))); 
# 201
__extension__ extern "C" unsigned long long strtouq(const char *__restrict__ , char **__restrict__ , int ) throw()
# 203
 __attribute((__nonnull__(1))); 
# 210
__extension__ extern "C" long long strtoll(const char *__restrict__ , char **__restrict__ , int ) throw()
# 212
 __attribute((__nonnull__(1))); 
# 215
__extension__ extern "C" unsigned long long strtoull(const char *__restrict__ , char **__restrict__ , int ) throw()
# 217
 __attribute((__nonnull__(1))); 
# 240 "/usr/include/stdlib.h" 3
extern "C" long strtol_l(const char *__restrict__ , char **__restrict__ , int , __locale_t ) throw()
# 242
 __attribute((__nonnull__(1, 4))); 
# 244
extern "C" unsigned long strtoul_l(const char *__restrict__ , char **__restrict__ , int , __locale_t ) throw()
# 247
 __attribute((__nonnull__(1, 4))); 
# 250
__extension__ extern "C" long long strtoll_l(const char *__restrict__ , char **__restrict__ , int , __locale_t ) throw()
# 253
 __attribute((__nonnull__(1, 4))); 
# 256
__extension__ extern "C" unsigned long long strtoull_l(const char *__restrict__ , char **__restrict__ , int , __locale_t ) throw()
# 259
 __attribute((__nonnull__(1, 4))); 
# 261
extern "C" double strtod_l(const char *__restrict__ , char **__restrict__ , __locale_t ) throw()
# 263
 __attribute((__nonnull__(1, 3))); 
# 265
extern "C" float strtof_l(const char *__restrict__ , char **__restrict__ , __locale_t ) throw()
# 267
 __attribute((__nonnull__(1, 3))); 
# 269
extern "C" long double strtold_l(const char *__restrict__ , char **__restrict__ , __locale_t ) throw()
# 272
 __attribute((__nonnull__(1, 3))); 
# 311 "/usr/include/stdlib.h" 3
extern "C" char *l64a(long ) throw(); 
# 314
extern "C" long a64l(const char * ) throw()
# 315
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 34 "/usr/include/sys/types.h" 3
extern "C" { typedef __u_char u_char; }
# 35
extern "C" { typedef __u_short u_short; }
# 36
extern "C" { typedef __u_int u_int; }
# 37
extern "C" { typedef __u_long u_long; }
# 38
extern "C" { typedef __quad_t quad_t; }
# 39
extern "C" { typedef __u_quad_t u_quad_t; }
# 40
extern "C" { typedef __fsid_t fsid_t; }
# 45
extern "C" { typedef __loff_t loff_t; }
# 49
extern "C" { typedef __ino_t ino_t; }
# 56
extern "C" { typedef __ino64_t ino64_t; }
# 61
extern "C" { typedef __dev_t dev_t; }
# 66
extern "C" { typedef __gid_t gid_t; }
# 71
extern "C" { typedef __mode_t mode_t; }
# 76
extern "C" { typedef __nlink_t nlink_t; }
# 81
extern "C" { typedef __uid_t uid_t; }
# 87
extern "C" { typedef __off_t off_t; }
# 94
extern "C" { typedef __off64_t off64_t; }
# 105 "/usr/include/sys/types.h" 3
extern "C" { typedef __id_t id_t; }
# 110
extern "C" { typedef __ssize_t ssize_t; }
# 116
extern "C" { typedef __daddr_t daddr_t; }
# 117
extern "C" { typedef __caddr_t caddr_t; }
# 123
extern "C" { typedef __key_t key_t; }
# 137 "/usr/include/sys/types.h" 3
extern "C" { typedef __useconds_t useconds_t; }
# 141
extern "C" { typedef __suseconds_t suseconds_t; }
# 151 "/usr/include/sys/types.h" 3
extern "C" { typedef unsigned long ulong; }
# 152
extern "C" { typedef unsigned short ushort; }
# 153
extern "C" { typedef unsigned uint; }
# 195 "/usr/include/sys/types.h" 3
extern "C" { typedef signed char int8_t __attribute((__mode__(__QI__))); }
# 196
extern "C" { typedef short int16_t __attribute((__mode__(__HI__))); }
# 197
extern "C" { typedef int int32_t __attribute((__mode__(__SI__))); }
# 198
extern "C" { typedef long int64_t __attribute((__mode__(__DI__))); }
# 201
extern "C" { typedef unsigned char u_int8_t __attribute((__mode__(__QI__))); }
# 202
extern "C" { typedef unsigned short u_int16_t __attribute((__mode__(__HI__))); }
# 203
extern "C" { typedef unsigned u_int32_t __attribute((__mode__(__SI__))); }
# 204
extern "C" { typedef unsigned long u_int64_t __attribute((__mode__(__DI__))); }
# 206
extern "C" { typedef long register_t __attribute((__mode__(__word__))); }
# 24 "/usr/include/bits/sigset.h" 3
extern "C" { typedef int __sig_atomic_t; }
# 32
extern "C" { typedef 
# 30
struct { 
# 31
unsigned long __val[(1024) / ((8) * sizeof(unsigned long))]; 
# 32
} __sigset_t; }
# 38 "/usr/include/sys/select.h" 3
extern "C" { typedef __sigset_t sigset_t; }
# 75 "/usr/include/bits/time.h" 3
extern "C" { struct timeval { 
# 77
__time_t tv_sec; 
# 78
__suseconds_t tv_usec; 
# 79
}; }
# 55 "/usr/include/sys/select.h" 3
extern "C" { typedef long __fd_mask; }
# 78 "/usr/include/sys/select.h" 3
extern "C" { typedef 
# 68
struct { 
# 72
__fd_mask fds_bits[1024 / (8 * ((int)sizeof(__fd_mask)))]; 
# 78
} fd_set; }
# 85
extern "C" { typedef __fd_mask fd_mask; }
# 109 "/usr/include/sys/select.h" 3
extern "C" int select(int , fd_set *__restrict__ , fd_set *__restrict__ , fd_set *__restrict__ , timeval *__restrict__ ); 
# 121 "/usr/include/sys/select.h" 3
extern "C" int pselect(int , fd_set *__restrict__ , fd_set *__restrict__ , fd_set *__restrict__ , const timespec *__restrict__ , const __sigset_t *__restrict__ ); 
# 31 "/usr/include/sys/sysmacros.h" 3
__extension__ extern "C" unsigned gnu_dev_major(unsigned long long ) throw(); 
# 34
__extension__ extern "C" unsigned gnu_dev_minor(unsigned long long ) throw(); 
# 37
__extension__ extern "C" unsigned long long gnu_dev_makedev(unsigned , unsigned ) throw(); 
# 229 "/usr/include/sys/types.h" 3
extern "C" { typedef __blksize_t blksize_t; }
# 236
extern "C" { typedef __blkcnt_t blkcnt_t; }
# 240
extern "C" { typedef __fsblkcnt_t fsblkcnt_t; }
# 244
extern "C" { typedef __fsfilcnt_t fsfilcnt_t; }
# 263 "/usr/include/sys/types.h" 3
extern "C" { typedef __blkcnt64_t blkcnt64_t; }
# 264
extern "C" { typedef __fsblkcnt64_t fsblkcnt64_t; }
# 265
extern "C" { typedef __fsfilcnt64_t fsfilcnt64_t; }
# 50 "/usr/include/bits/pthreadtypes.h" 3
extern "C" { typedef unsigned long pthread_t; }
# 57
extern "C" { typedef 
# 54
union { 
# 55
char __size[56]; 
# 56
long __align; 
# 57
} pthread_attr_t; }
# 65
extern "C" { typedef 
# 61
struct __pthread_internal_list { 
# 63
__pthread_internal_list *__prev; 
# 64
__pthread_internal_list *__next; 
# 65
} __pthread_list_t; }
# 104 "/usr/include/bits/pthreadtypes.h" 3
extern "C" { typedef 
# 77 "/usr/include/bits/pthreadtypes.h" 3
union { 
# 78
struct __pthread_mutex_s { 
# 80
int __lock; 
# 81
unsigned __count; 
# 82
int __owner; 
# 84
unsigned __nusers; 
# 88
int __kind; 
# 90
int __spins; 
# 91
__pthread_list_t __list; 
# 101 "/usr/include/bits/pthreadtypes.h" 3
} __data; 
# 102
char __size[40]; 
# 103
long __align; 
# 104
} pthread_mutex_t; }
# 110
extern "C" { typedef 
# 107
union { 
# 108
char __size[4]; 
# 109
int __align; 
# 110
} pthread_mutexattr_t; }
# 130
extern "C" { typedef 
# 116
union { 
# 118
struct { 
# 119
int __lock; 
# 120
unsigned __futex; 
# 121
__extension__ unsigned long long __total_seq; 
# 122
__extension__ unsigned long long __wakeup_seq; 
# 123
__extension__ unsigned long long __woken_seq; 
# 124
void *__mutex; 
# 125
unsigned __nwaiters; 
# 126
unsigned __broadcast_seq; 
# 127
} __data; 
# 128
char __size[48]; 
# 129
__extension__ long long __align; 
# 130
} pthread_cond_t; }
# 136
extern "C" { typedef 
# 133
union { 
# 134
char __size[4]; 
# 135
int __align; 
# 136
} pthread_condattr_t; }
# 140
extern "C" { typedef unsigned pthread_key_t; }
# 144
extern "C" { typedef int pthread_once_t; }
# 189 "/usr/include/bits/pthreadtypes.h" 3
extern "C" { typedef 
# 151 "/usr/include/bits/pthreadtypes.h" 3
union { 
# 154
struct { 
# 155
int __lock; 
# 156
unsigned __nr_readers; 
# 157
unsigned __readers_wakeup; 
# 158
unsigned __writer_wakeup; 
# 159
unsigned __nr_readers_queued; 
# 160
unsigned __nr_writers_queued; 
# 161
int __writer; 
# 162
int __shared; 
# 163
unsigned long __pad1; 
# 164
unsigned long __pad2; 
# 167
unsigned __flags; 
# 168
} __data; 
# 187 "/usr/include/bits/pthreadtypes.h" 3
char __size[56]; 
# 188
long __align; 
# 189
} pthread_rwlock_t; }
# 195
extern "C" { typedef 
# 192
union { 
# 193
char __size[8]; 
# 194
long __align; 
# 195
} pthread_rwlockattr_t; }
# 201
extern "C" { typedef volatile int pthread_spinlock_t; }
# 210
extern "C" { typedef 
# 207
union { 
# 208
char __size[32]; 
# 209
long __align; 
# 210
} pthread_barrier_t; }
# 216
extern "C" { typedef 
# 213
union { 
# 214
char __size[4]; 
# 215
int __align; 
# 216
} pthread_barrierattr_t; }
# 327 "/usr/include/stdlib.h" 3
extern "C" long random() throw(); 
# 330
extern "C" void srandom(unsigned ) throw(); 
# 336
extern "C" char *initstate(unsigned , char * , size_t ) throw()
# 337
 __attribute((__nonnull__(2))); 
# 341
extern "C" char *setstate(char * ) throw() __attribute((__nonnull__(1))); 
# 349
extern "C" { struct random_data { 
# 351
int32_t *fptr; 
# 352
int32_t *rptr; 
# 353
int32_t *state; 
# 354
int rand_type; 
# 355
int rand_deg; 
# 356
int rand_sep; 
# 357
int32_t *end_ptr; 
# 358
}; }
# 360
extern "C" int random_r(random_data *__restrict__ , int32_t *__restrict__ ) throw()
# 361
 __attribute((__nonnull__(1, 2))); 
# 363
extern "C" int srandom_r(unsigned , random_data * ) throw()
# 364
 __attribute((__nonnull__(2))); 
# 366
extern "C" int initstate_r(unsigned , char *__restrict__ , size_t , random_data *__restrict__ ) throw()
# 369
 __attribute((__nonnull__(2, 4))); 
# 371
extern "C" int setstate_r(char *__restrict__ , random_data *__restrict__ ) throw()
# 373
 __attribute((__nonnull__(1, 2))); 
# 380
extern "C" int rand() throw(); 
# 382
extern "C" void srand(unsigned ) throw(); 
# 387
extern "C" int rand_r(unsigned * ) throw(); 
# 395
extern "C" double drand48() throw(); 
# 396
extern "C" double erand48(unsigned short  [3]) throw() __attribute((__nonnull__(1))); 
# 399
extern "C" long lrand48() throw(); 
# 400
extern "C" long nrand48(unsigned short  [3]) throw()
# 401
 __attribute((__nonnull__(1))); 
# 404
extern "C" long mrand48() throw(); 
# 405
extern "C" long jrand48(unsigned short  [3]) throw()
# 406
 __attribute((__nonnull__(1))); 
# 409
extern "C" void srand48(long ) throw(); 
# 410
extern "C" unsigned short *seed48(unsigned short  [3]) throw()
# 411
 __attribute((__nonnull__(1))); 
# 412
extern "C" void lcong48(unsigned short  [7]) throw() __attribute((__nonnull__(1))); 
# 418
extern "C" { struct drand48_data { 
# 420
unsigned short __x[3]; 
# 421
unsigned short __old_x[3]; 
# 422
unsigned short __c; 
# 423
unsigned short __init; 
# 424
unsigned long long __a; 
# 425
}; }
# 428
extern "C" int drand48_r(drand48_data *__restrict__ , double *__restrict__ ) throw()
# 429
 __attribute((__nonnull__(1, 2))); 
# 430
extern "C" int erand48_r(unsigned short  [3], drand48_data *__restrict__ , double *__restrict__ ) throw()
# 432
 __attribute((__nonnull__(1, 2))); 
# 435
extern "C" int lrand48_r(drand48_data *__restrict__ , long *__restrict__ ) throw()
# 437
 __attribute((__nonnull__(1, 2))); 
# 438
extern "C" int nrand48_r(unsigned short  [3], drand48_data *__restrict__ , long *__restrict__ ) throw()
# 441
 __attribute((__nonnull__(1, 2))); 
# 444
extern "C" int mrand48_r(drand48_data *__restrict__ , long *__restrict__ ) throw()
# 446
 __attribute((__nonnull__(1, 2))); 
# 447
extern "C" int jrand48_r(unsigned short  [3], drand48_data *__restrict__ , long *__restrict__ ) throw()
# 450
 __attribute((__nonnull__(1, 2))); 
# 453
extern "C" int srand48_r(long , drand48_data * ) throw()
# 454
 __attribute((__nonnull__(2))); 
# 456
extern "C" int seed48_r(unsigned short  [3], drand48_data * ) throw()
# 457
 __attribute((__nonnull__(1, 2))); 
# 459
extern "C" int lcong48_r(unsigned short  [7], drand48_data * ) throw()
# 461
 __attribute((__nonnull__(1, 2))); 
# 471
extern "C" void *malloc(size_t ) throw() __attribute((__malloc__)); 
# 473
extern "C" void *calloc(size_t , size_t ) throw()
# 474
 __attribute((__malloc__)); 
# 485
extern "C" void *realloc(void * , size_t ) throw()
# 486
 __attribute((__warn_unused_result__)); 
# 488
extern "C" void free(void * ) throw(); 
# 493
extern "C" void cfree(void * ) throw(); 
# 33 "/usr/include/alloca.h" 3
extern "C" void *alloca(size_t ) throw(); 
# 503 "/usr/include/stdlib.h" 3
extern "C" void *valloc(size_t ) throw() __attribute((__malloc__)); 
# 508
extern "C" int posix_memalign(void ** , size_t , size_t ) throw()
# 509
 __attribute((__nonnull__(1))); 
# 514
extern "C" void abort() throw() __attribute((__noreturn__)); 
# 518
extern "C" int atexit(void (* )(void)) throw() __attribute((__nonnull__(1))); 
# 525
int at_quick_exit(void (* )(void)) throw() __asm__("at_quick_exit")
# 526
 __attribute((__nonnull__(1))); 
# 536
extern "C" int on_exit(void (* )(int , void * ), void * ) throw()
# 537
 __attribute((__nonnull__(1))); 
# 544
extern "C" void exit(int ) throw() __attribute((__noreturn__)); 
# 552
extern "C" void quick_exit(int ) throw() __attribute((__noreturn__)); 
# 560
extern "C" void _Exit(int ) throw() __attribute((__noreturn__)); 
# 567
extern "C" char *getenv(const char * ) throw() __attribute((__nonnull__(1))); 
# 572
extern "C" char *__secure_getenv(const char * ) throw()
# 573
 __attribute((__nonnull__(1))); 
# 579
extern "C" int putenv(char * ) throw() __attribute((__nonnull__(1))); 
# 585
extern "C" int setenv(const char * , const char * , int ) throw()
# 586
 __attribute((__nonnull__(2))); 
# 589
extern "C" int unsetenv(const char * ) throw() __attribute((__nonnull__(1))); 
# 596
extern "C" int clearenv() throw(); 
# 606 "/usr/include/stdlib.h" 3
extern "C" char *mktemp(char * ) throw() __attribute((__nonnull__(1))); 
# 620 "/usr/include/stdlib.h" 3
extern "C" int mkstemp(char * ) __attribute((__nonnull__(1))); 
# 630 "/usr/include/stdlib.h" 3
extern "C" int mkstemp64(char * ) __attribute((__nonnull__(1))); 
# 642 "/usr/include/stdlib.h" 3
extern "C" int mkstemps(char * , int ) __attribute((__nonnull__(1))); 
# 652 "/usr/include/stdlib.h" 3
extern "C" int mkstemps64(char * , int )
# 653
 __attribute((__nonnull__(1))); 
# 663 "/usr/include/stdlib.h" 3
extern "C" char *mkdtemp(char * ) throw() __attribute((__nonnull__(1))); 
# 674 "/usr/include/stdlib.h" 3
extern "C" int mkostemp(char * , int ) __attribute((__nonnull__(1))); 
# 684 "/usr/include/stdlib.h" 3
extern "C" int mkostemp64(char * , int ) __attribute((__nonnull__(1))); 
# 694 "/usr/include/stdlib.h" 3
extern "C" int mkostemps(char * , int , int )
# 695
 __attribute((__nonnull__(1))); 
# 706 "/usr/include/stdlib.h" 3
extern "C" int mkostemps64(char * , int , int )
# 707
 __attribute((__nonnull__(1))); 
# 717
extern "C" int system(const char * ); 
# 724
extern "C" char *canonicalize_file_name(const char * ) throw()
# 725
 __attribute((__nonnull__(1))); 
# 734 "/usr/include/stdlib.h" 3
extern "C" char *realpath(const char *__restrict__ , char *__restrict__ ) throw(); 
# 742
extern "C" { typedef int (*__compar_fn_t)(const void *, const void *); }
# 745
extern "C" { typedef __compar_fn_t comparison_fn_t; }
# 749
extern "C" { typedef int (*__compar_d_fn_t)(const void *, const void *, void *); }
# 755
extern "C" void *bsearch(const void * , const void * , size_t , size_t , __compar_fn_t )
# 757
 __attribute((__nonnull__(1, 2, 5))); 
# 761
extern "C" void qsort(void * , size_t , size_t , __compar_fn_t )
# 762
 __attribute((__nonnull__(1, 4))); 
# 764
extern "C" void qsort_r(void * , size_t , size_t , __compar_d_fn_t , void * )
# 766
 __attribute((__nonnull__(1, 4))); 
# 771
extern "C" int abs(int ) throw() __attribute((const)); 
# 772
extern "C" long labs(long ) throw() __attribute((const)); 
# 776
__extension__ extern "C" long long llabs(long long ) throw()
# 777
 __attribute((const)); 
# 785
extern "C" div_t div(int , int ) throw()
# 786
 __attribute((const)); 
# 787
extern "C" ldiv_t ldiv(long , long ) throw()
# 788
 __attribute((const)); 
# 793
__extension__ extern "C" lldiv_t lldiv(long long , long long ) throw()
# 795
 __attribute((const)); 
# 808 "/usr/include/stdlib.h" 3
extern "C" char *ecvt(double , int , int *__restrict__ , int *__restrict__ ) throw()
# 809
 __attribute((__nonnull__(3, 4))); 
# 814
extern "C" char *fcvt(double , int , int *__restrict__ , int *__restrict__ ) throw()
# 815
 __attribute((__nonnull__(3, 4))); 
# 820
extern "C" char *gcvt(double , int , char * ) throw()
# 821
 __attribute((__nonnull__(3))); 
# 826
extern "C" char *qecvt(long double , int , int *__restrict__ , int *__restrict__ ) throw()
# 828
 __attribute((__nonnull__(3, 4))); 
# 829
extern "C" char *qfcvt(long double , int , int *__restrict__ , int *__restrict__ ) throw()
# 831
 __attribute((__nonnull__(3, 4))); 
# 832
extern "C" char *qgcvt(long double , int , char * ) throw()
# 833
 __attribute((__nonnull__(3))); 
# 838
extern "C" int ecvt_r(double , int , int *__restrict__ , int *__restrict__ , char *__restrict__ , size_t ) throw()
# 840
 __attribute((__nonnull__(3, 4, 5))); 
# 841
extern "C" int fcvt_r(double , int , int *__restrict__ , int *__restrict__ , char *__restrict__ , size_t ) throw()
# 843
 __attribute((__nonnull__(3, 4, 5))); 
# 845
extern "C" int qecvt_r(long double , int , int *__restrict__ , int *__restrict__ , char *__restrict__ , size_t ) throw()
# 848
 __attribute((__nonnull__(3, 4, 5))); 
# 849
extern "C" int qfcvt_r(long double , int , int *__restrict__ , int *__restrict__ , char *__restrict__ , size_t ) throw()
# 852
 __attribute((__nonnull__(3, 4, 5))); 
# 860
extern "C" int mblen(const char * , size_t ) throw(); 
# 863
extern "C" int mbtowc(wchar_t *__restrict__ , const char *__restrict__ , size_t ) throw(); 
# 867
extern "C" int wctomb(char * , wchar_t ) throw(); 
# 871
extern "C" size_t mbstowcs(wchar_t *__restrict__ , const char *__restrict__ , size_t ) throw(); 
# 874
extern "C" size_t wcstombs(char *__restrict__ , const wchar_t *__restrict__ , size_t ) throw(); 
# 885
extern "C" int rpmatch(const char * ) throw() __attribute((__nonnull__(1))); 
# 896 "/usr/include/stdlib.h" 3
extern "C" int getsubopt(char **__restrict__ , char *const *__restrict__ , char **__restrict__ ) throw()
# 899
 __attribute((__nonnull__(1, 2, 3))); 
# 905
extern "C" void setkey(const char * ) throw() __attribute((__nonnull__(1))); 
# 913
extern "C" int posix_openpt(int ); 
# 921
extern "C" int grantpt(int ) throw(); 
# 925
extern "C" int unlockpt(int ) throw(); 
# 930
extern "C" char *ptsname(int ) throw(); 
# 937
extern "C" int ptsname_r(int , char * , size_t ) throw()
# 938
 __attribute((__nonnull__(2))); 
# 941
extern "C" int getpt(); 
# 948
extern "C" int getloadavg(double  [], int ) throw()
# 949
 __attribute((__nonnull__(1))); 
# 69 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 71
template< class _Iterator, class _Container> class __normal_iterator; 
# 74
}
# 76
namespace std __attribute((__visibility__("default"))) { 
# 78
struct __true_type { }; 
# 79
struct __false_type { }; 
# 81
template< bool __T0> 
# 82
struct __truth_type { 
# 83
typedef __false_type __type; }; 
# 86
template<> struct __truth_type< true>  { 
# 87
typedef __true_type __type; }; 
# 91
template< class _Sp, class _Tp> 
# 92
struct __traitor { 
# 94
enum { __value = ((bool)_Sp::__value) || ((bool)_Tp::__value)}; 
# 95
typedef typename __truth_type< __value> ::__type __type; 
# 96
}; 
# 99
template< class , class > 
# 100
struct __are_same { 
# 102
enum { __value}; 
# 103
typedef __false_type __type; 
# 104
}; 
# 106
template< class _Tp> 
# 107
struct __are_same< _Tp, _Tp>  { 
# 109
enum { __value = 1}; 
# 110
typedef __true_type __type; 
# 111
}; 
# 114
template< class _Tp> 
# 115
struct __is_void { 
# 117
enum { __value}; 
# 118
typedef __false_type __type; 
# 119
}; 
# 122
template<> struct __is_void< void>  { 
# 124
enum { __value = 1}; 
# 125
typedef __true_type __type; 
# 126
}; 
# 131
template< class _Tp> 
# 132
struct __is_integer { 
# 134
enum { __value}; 
# 135
typedef __false_type __type; 
# 136
}; 
# 142
template<> struct __is_integer< bool>  { 
# 144
enum { __value = 1}; 
# 145
typedef __true_type __type; 
# 146
}; 
# 149
template<> struct __is_integer< char>  { 
# 151
enum { __value = 1}; 
# 152
typedef __true_type __type; 
# 153
}; 
# 156
template<> struct __is_integer< signed char>  { 
# 158
enum { __value = 1}; 
# 159
typedef __true_type __type; 
# 160
}; 
# 163
template<> struct __is_integer< unsigned char>  { 
# 165
enum { __value = 1}; 
# 166
typedef __true_type __type; 
# 167
}; 
# 171
template<> struct __is_integer< wchar_t>  { 
# 173
enum { __value = 1}; 
# 174
typedef __true_type __type; 
# 175
}; 
# 195 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/cpp_type_traits.h" 3
template<> struct __is_integer< short>  { 
# 197
enum { __value = 1}; 
# 198
typedef __true_type __type; 
# 199
}; 
# 202
template<> struct __is_integer< unsigned short>  { 
# 204
enum { __value = 1}; 
# 205
typedef __true_type __type; 
# 206
}; 
# 209
template<> struct __is_integer< int>  { 
# 211
enum { __value = 1}; 
# 212
typedef __true_type __type; 
# 213
}; 
# 216
template<> struct __is_integer< unsigned>  { 
# 218
enum { __value = 1}; 
# 219
typedef __true_type __type; 
# 220
}; 
# 223
template<> struct __is_integer< long>  { 
# 225
enum { __value = 1}; 
# 226
typedef __true_type __type; 
# 227
}; 
# 230
template<> struct __is_integer< unsigned long>  { 
# 232
enum { __value = 1}; 
# 233
typedef __true_type __type; 
# 234
}; 
# 237
template<> struct __is_integer< long long>  { 
# 239
enum { __value = 1}; 
# 240
typedef __true_type __type; 
# 241
}; 
# 244
template<> struct __is_integer< unsigned long long>  { 
# 246
enum { __value = 1}; 
# 247
typedef __true_type __type; 
# 248
}; 
# 253
template< class _Tp> 
# 254
struct __is_floating { 
# 256
enum { __value}; 
# 257
typedef __false_type __type; 
# 258
}; 
# 262
template<> struct __is_floating< float>  { 
# 264
enum { __value = 1}; 
# 265
typedef __true_type __type; 
# 266
}; 
# 269
template<> struct __is_floating< double>  { 
# 271
enum { __value = 1}; 
# 272
typedef __true_type __type; 
# 273
}; 
# 276
template<> struct __is_floating< long double>  { 
# 278
enum { __value = 1}; 
# 279
typedef __true_type __type; 
# 280
}; 
# 285
template< class _Tp> 
# 286
struct __is_pointer { 
# 288
enum { __value}; 
# 289
typedef __false_type __type; 
# 290
}; 
# 292
template< class _Tp> 
# 293
struct __is_pointer< _Tp *>  { 
# 295
enum { __value = 1}; 
# 296
typedef __true_type __type; 
# 297
}; 
# 302
template< class _Tp> 
# 303
struct __is_normal_iterator { 
# 305
enum { __value}; 
# 306
typedef __false_type __type; 
# 307
}; 
# 309
template< class _Iterator, class _Container> 
# 310
struct __is_normal_iterator< __gnu_cxx::__normal_iterator< _Iterator, _Container> >  { 
# 313
enum { __value = 1}; 
# 314
typedef __true_type __type; 
# 315
}; 
# 320
template< class _Tp> 
# 321
struct __is_arithmetic : public __traitor< __is_integer< _Tp> , __is_floating< _Tp> >  { 
# 323
}; 
# 328
template< class _Tp> 
# 329
struct __is_fundamental : public __traitor< __is_void< _Tp> , __is_arithmetic< _Tp> >  { 
# 331
}; 
# 336
template< class _Tp> 
# 337
struct __is_scalar : public __traitor< __is_arithmetic< _Tp> , __is_pointer< _Tp> >  { 
# 339
}; 
# 344
template< class _Tp> 
# 345
struct __is_char { 
# 347
enum { __value}; 
# 348
typedef __false_type __type; 
# 349
}; 
# 352
template<> struct __is_char< char>  { 
# 354
enum { __value = 1}; 
# 355
typedef __true_type __type; 
# 356
}; 
# 360
template<> struct __is_char< wchar_t>  { 
# 362
enum { __value = 1}; 
# 363
typedef __true_type __type; 
# 364
}; 
# 367
template< class _Tp> 
# 368
struct __is_byte { 
# 370
enum { __value}; 
# 371
typedef __false_type __type; 
# 372
}; 
# 375
template<> struct __is_byte< char>  { 
# 377
enum { __value = 1}; 
# 378
typedef __true_type __type; 
# 379
}; 
# 382
template<> struct __is_byte< signed char>  { 
# 384
enum { __value = 1}; 
# 385
typedef __true_type __type; 
# 386
}; 
# 389
template<> struct __is_byte< unsigned char>  { 
# 391
enum { __value = 1}; 
# 392
typedef __true_type __type; 
# 393
}; 
# 398
template< class _Tp> 
# 399
struct __is_move_iterator { 
# 401
enum { __value}; 
# 402
typedef __false_type __type; 
# 403
}; 
# 417 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/cpp_type_traits.h" 3
}
# 37 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/ext/type_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 40
template< bool __T1, class > 
# 41
struct __enable_if { 
# 42
}; 
# 44
template< class _Tp> 
# 45
struct __enable_if< true, _Tp>  { 
# 46
typedef _Tp __type; }; 
# 50
template< bool _Cond, class _Iftrue, class _Iffalse> 
# 51
struct __conditional_type { 
# 52
typedef _Iftrue __type; }; 
# 54
template< class _Iftrue, class _Iffalse> 
# 55
struct __conditional_type< false, _Iftrue, _Iffalse>  { 
# 56
typedef _Iffalse __type; }; 
# 60
template< class _Tp> 
# 61
struct __add_unsigned { 
# 64
private: typedef __enable_if< std::__is_integer< _Tp> ::__value, _Tp>  __if_type; 
# 67
public: typedef typename __enable_if< std::__is_integer< _Tp> ::__value, _Tp> ::__type __type; 
# 68
}; 
# 71
template<> struct __add_unsigned< char>  { 
# 72
typedef unsigned char __type; }; 
# 75
template<> struct __add_unsigned< signed char>  { 
# 76
typedef unsigned char __type; }; 
# 79
template<> struct __add_unsigned< short>  { 
# 80
typedef unsigned short __type; }; 
# 83
template<> struct __add_unsigned< int>  { 
# 84
typedef unsigned __type; }; 
# 87
template<> struct __add_unsigned< long>  { 
# 88
typedef unsigned long __type; }; 
# 91
template<> struct __add_unsigned< long long>  { 
# 92
typedef unsigned long long __type; }; 
# 96
template<> struct __add_unsigned< bool> ; 
# 99
template<> struct __add_unsigned< wchar_t> ; 
# 103
template< class _Tp> 
# 104
struct __remove_unsigned { 
# 107
private: typedef __enable_if< std::__is_integer< _Tp> ::__value, _Tp>  __if_type; 
# 110
public: typedef typename __enable_if< std::__is_integer< _Tp> ::__value, _Tp> ::__type __type; 
# 111
}; 
# 114
template<> struct __remove_unsigned< char>  { 
# 115
typedef signed char __type; }; 
# 118
template<> struct __remove_unsigned< unsigned char>  { 
# 119
typedef signed char __type; }; 
# 122
template<> struct __remove_unsigned< unsigned short>  { 
# 123
typedef short __type; }; 
# 126
template<> struct __remove_unsigned< unsigned>  { 
# 127
typedef int __type; }; 
# 130
template<> struct __remove_unsigned< unsigned long>  { 
# 131
typedef long __type; }; 
# 134
template<> struct __remove_unsigned< unsigned long long>  { 
# 135
typedef long long __type; }; 
# 139
template<> struct __remove_unsigned< bool> ; 
# 142
template<> struct __remove_unsigned< wchar_t> ; 
# 146
template < typename _Type >
    inline bool
    __is_null_pointer ( _Type * __ptr )
    { return __ptr == 0; }
# 151
template < typename _Type >
    inline bool
    __is_null_pointer ( _Type )
    { return false; }
# 158
template< class _Tp, bool __T2 = std::__is_integer< _Tp> ::__value> 
# 159
struct __promote { 
# 160
typedef double __type; }; 
# 162
template< class _Tp> 
# 163
struct __promote< _Tp, false>  { 
# 164
typedef _Tp __type; }; 
# 166
template< class _Tp, class _Up> 
# 167
struct __promote_2 { 
# 170
private: typedef typename __promote< _Tp> ::__type __type1; 
# 171
typedef typename __promote< _Up> ::__type __type2; 
# 174
public: typedef __typeof__(__type1() + __type2()) __type; 
# 175
}; 
# 177
template< class _Tp, class _Up, class _Vp> 
# 178
struct __promote_3 { 
# 181
private: typedef typename __promote< _Tp> ::__type __type1; 
# 182
typedef typename __promote< _Up> ::__type __type2; 
# 183
typedef typename __promote< _Vp> ::__type __type3; 
# 186
public: typedef __typeof__((__type1() + __type2()) + __type3()) __type; 
# 187
}; 
# 189
template< class _Tp, class _Up, class _Vp, class _Wp> 
# 190
struct __promote_4 { 
# 193
private: typedef typename __promote< _Tp> ::__type __type1; 
# 194
typedef typename __promote< _Up> ::__type __type2; 
# 195
typedef typename __promote< _Vp> ::__type __type3; 
# 196
typedef typename __promote< _Wp> ::__type __type4; 
# 199
public: typedef __typeof__(((__type1() + __type2()) + __type3()) + __type4()) __type; 
# 200
}; 
# 202
}
# 77 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cmath" 3
namespace std __attribute((__visibility__("default"))) { 
# 81
template < typename _Tp >
    _Tp __cmath_power ( _Tp, unsigned int );
# 84
template < typename _Tp >
    inline _Tp
    __pow_helper ( _Tp __x, int __n )
    {
      return __n < 0
        ? _Tp ( 1 ) / __cmath_power ( __x, - __n )
        : __cmath_power ( __x, __n );
    }
# 94
inline double abs(double __x) 
# 95
{ return __builtin_fabs(__x); } 
# 98
inline float abs(float __x) 
# 99
{ return __builtin_fabsf(__x); } 
# 102
inline long double abs(long double __x) 
# 103
{ return __builtin_fabsl(__x); } 
# 105
using ::acos;
# 108
inline float acos(float __x) 
# 109
{ return __builtin_acosf(__x); } 
# 112
inline long double acos(long double __x) 
# 113
{ return __builtin_acosl(__x); } 
# 115
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    acos ( _Tp __x )
    { return __builtin_acos ( __x ); }
# 121
using ::asin;
# 124
inline float asin(float __x) 
# 125
{ return __builtin_asinf(__x); } 
# 128
inline long double asin(long double __x) 
# 129
{ return __builtin_asinl(__x); } 
# 131
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    asin ( _Tp __x )
    { return __builtin_asin ( __x ); }
# 137
using ::atan;
# 140
inline float atan(float __x) 
# 141
{ return __builtin_atanf(__x); } 
# 144
inline long double atan(long double __x) 
# 145
{ return __builtin_atanl(__x); } 
# 147
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    atan ( _Tp __x )
    { return __builtin_atan ( __x ); }
# 153
using ::atan2;
# 156
inline float atan2(float __y, float __x) 
# 157
{ return __builtin_atan2f(__y, __x); } 
# 160
inline long double atan2(long double __y, long double __x) 
# 161
{ return __builtin_atan2l(__y, __x); } 
# 163
template < typename _Tp, typename _Up >
    inline
    typename __gnu_cxx :: __promote_2 <
    typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value
        && __is_arithmetic < _Up > :: __value,
        _Tp > :: __type, _Up > :: __type
    atan2 ( _Tp __y, _Up __x )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return atan2 ( __type ( __y ), __type ( __x ) );
    }
# 175
using ::ceil;
# 178
inline float ceil(float __x) 
# 179
{ return __builtin_ceilf(__x); } 
# 182
inline long double ceil(long double __x) 
# 183
{ return __builtin_ceill(__x); } 
# 185
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    ceil ( _Tp __x )
    { return __builtin_ceil ( __x ); }
# 191
using ::cos;
# 194
inline float cos(float __x) 
# 195
{ return __builtin_cosf(__x); } 
# 198
inline long double cos(long double __x) 
# 199
{ return __builtin_cosl(__x); } 
# 201
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    cos ( _Tp __x )
    { return __builtin_cos ( __x ); }
# 207
using ::cosh;
# 210
inline float cosh(float __x) 
# 211
{ return __builtin_coshf(__x); } 
# 214
inline long double cosh(long double __x) 
# 215
{ return __builtin_coshl(__x); } 
# 217
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    cosh ( _Tp __x )
    { return __builtin_cosh ( __x ); }
# 223
using ::exp;
# 226
inline float exp(float __x) 
# 227
{ return __builtin_expf(__x); } 
# 230
inline long double exp(long double __x) 
# 231
{ return __builtin_expl(__x); } 
# 233
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    exp ( _Tp __x )
    { return __builtin_exp ( __x ); }
# 239
using ::fabs;
# 242
inline float fabs(float __x) 
# 243
{ return __builtin_fabsf(__x); } 
# 246
inline long double fabs(long double __x) 
# 247
{ return __builtin_fabsl(__x); } 
# 249
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    fabs ( _Tp __x )
    { return __builtin_fabs ( __x ); }
# 255
using ::floor;
# 258
inline float floor(float __x) 
# 259
{ return __builtin_floorf(__x); } 
# 262
inline long double floor(long double __x) 
# 263
{ return __builtin_floorl(__x); } 
# 265
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    floor ( _Tp __x )
    { return __builtin_floor ( __x ); }
# 271
using ::fmod;
# 274
inline float fmod(float __x, float __y) 
# 275
{ return __builtin_fmodf(__x, __y); } 
# 278
inline long double fmod(long double __x, long double __y) 
# 279
{ return __builtin_fmodl(__x, __y); } 
# 281
using ::frexp;
# 284
inline float frexp(float __x, int *__exp) 
# 285
{ return __builtin_frexpf(__x, __exp); } 
# 288
inline long double frexp(long double __x, int *__exp) 
# 289
{ return __builtin_frexpl(__x, __exp); } 
# 291
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    frexp ( _Tp __x, int * __exp )
    { return __builtin_frexp ( __x, __exp ); }
# 297
using ::ldexp;
# 300
inline float ldexp(float __x, int __exp) 
# 301
{ return __builtin_ldexpf(__x, __exp); } 
# 304
inline long double ldexp(long double __x, int __exp) 
# 305
{ return __builtin_ldexpl(__x, __exp); } 
# 307
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
  ldexp ( _Tp __x, int __exp )
  { return __builtin_ldexp ( __x, __exp ); }
# 313
using ::log;
# 316
inline float log(float __x) 
# 317
{ return __builtin_logf(__x); } 
# 320
inline long double log(long double __x) 
# 321
{ return __builtin_logl(__x); } 
# 323
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    log ( _Tp __x )
    { return __builtin_log ( __x ); }
# 329
using ::log10;
# 332
inline float log10(float __x) 
# 333
{ return __builtin_log10f(__x); } 
# 336
inline long double log10(long double __x) 
# 337
{ return __builtin_log10l(__x); } 
# 339
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    log10 ( _Tp __x )
    { return __builtin_log10 ( __x ); }
# 345
using ::modf;
# 348
inline float modf(float __x, float *__iptr) 
# 349
{ return __builtin_modff(__x, __iptr); } 
# 352
inline long double modf(long double __x, long double *__iptr) 
# 353
{ return __builtin_modfl(__x, __iptr); } 
# 355
using ::pow;
# 358
inline float pow(float __x, float __y) 
# 359
{ return __builtin_powf(__x, __y); } 
# 362
inline long double pow(long double __x, long double __y) 
# 363
{ return __builtin_powl(__x, __y); } 
# 369
inline double pow(double __x, int __i) 
# 370
{ return __builtin_powi(__x, __i); } 
# 373
inline float pow(float __x, int __n) 
# 374
{ return __builtin_powif(__x, __n); } 
# 377
inline long double pow(long double __x, int __n) 
# 378
{ return __builtin_powil(__x, __n); } 
# 381
template < typename _Tp, typename _Up >
    inline
    typename __gnu_cxx :: __promote_2 <
    typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value
        && __is_arithmetic < _Up > :: __value,
        _Tp > :: __type, _Up > :: __type
    pow ( _Tp __x, _Up __y )
    {
      typedef typename __gnu_cxx :: __promote_2 < _Tp, _Up > :: __type __type;
      return pow ( __type ( __x ), __type ( __y ) );
    }
# 393
using ::sin;
# 396
inline float sin(float __x) 
# 397
{ return __builtin_sinf(__x); } 
# 400
inline long double sin(long double __x) 
# 401
{ return __builtin_sinl(__x); } 
# 403
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    sin ( _Tp __x )
    { return __builtin_sin ( __x ); }
# 409
using ::sinh;
# 412
inline float sinh(float __x) 
# 413
{ return __builtin_sinhf(__x); } 
# 416
inline long double sinh(long double __x) 
# 417
{ return __builtin_sinhl(__x); } 
# 419
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    sinh ( _Tp __x )
    { return __builtin_sinh ( __x ); }
# 425
using ::sqrt;
# 428
inline float sqrt(float __x) 
# 429
{ return __builtin_sqrtf(__x); } 
# 432
inline long double sqrt(long double __x) 
# 433
{ return __builtin_sqrtl(__x); } 
# 435
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    sqrt ( _Tp __x )
    { return __builtin_sqrt ( __x ); }
# 441
using ::tan;
# 444
inline float tan(float __x) 
# 445
{ return __builtin_tanf(__x); } 
# 448
inline long double tan(long double __x) 
# 449
{ return __builtin_tanl(__x); } 
# 451
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    tan ( _Tp __x )
    { return __builtin_tan ( __x ); }
# 457
using ::tanh;
# 460
inline float tanh(float __x) 
# 461
{ return __builtin_tanhf(__x); } 
# 464
inline long double tanh(long double __x) 
# 465
{ return __builtin_tanhl(__x); } 
# 467
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value,
        double > :: __type
    tanh ( _Tp __x )
    { return __builtin_tanh ( __x ); }
# 473
}
# 492 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cmath" 3
namespace std __attribute((__visibility__("default"))) { 
# 494
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    fpclassify ( _Tp __f )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_fpclassify ( FP_NAN, FP_INFINITE, FP_NORMAL,
      FP_SUBNORMAL, FP_ZERO, __type ( __f ) );
    }
# 504
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    isfinite ( _Tp __f )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_isfinite ( __type ( __f ) );
    }
# 513
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    isinf ( _Tp __f )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_isinf ( __type ( __f ) );
    }
# 522
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    isnan ( _Tp __f )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_isnan ( __type ( __f ) );
    }
# 531
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    isnormal ( _Tp __f )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_isnormal ( __type ( __f ) );
    }
# 540
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    signbit ( _Tp __f )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_signbit ( __type ( __f ) );
    }
# 549
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    isgreater ( _Tp __f1, _Tp __f2 )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_isgreater ( __type ( __f1 ), __type ( __f2 ) );
    }
# 558
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    isgreaterequal ( _Tp __f1, _Tp __f2 )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_isgreaterequal ( __type ( __f1 ), __type ( __f2 ) );
    }
# 567
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    isless ( _Tp __f1, _Tp __f2 )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_isless ( __type ( __f1 ), __type ( __f2 ) );
    }
# 576
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    islessequal ( _Tp __f1, _Tp __f2 )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_islessequal ( __type ( __f1 ), __type ( __f2 ) );
    }
# 585
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    islessgreater ( _Tp __f1, _Tp __f2 )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_islessgreater ( __type ( __f1 ), __type ( __f2 ) );
    }
# 594
template < typename _Tp >
    inline typename __gnu_cxx :: __enable_if < __is_arithmetic < _Tp > :: __value,
        int > :: __type
    isunordered ( _Tp __f1, _Tp __f2 )
    {
      typedef typename __gnu_cxx :: __promote < _Tp > :: __type __type;
      return __builtin_isunordered ( __type ( __f1 ), __type ( __f2 ) );
    }
# 603
}
# 35 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/cmath.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 37
template < typename _Tp >
    inline _Tp
    __cmath_power ( _Tp __x, unsigned int __n )
    {
      _Tp __y = __n % 2 ? __x : _Tp ( 1 );

      while ( __n >>= 1 )
        {
          __x = __x * __x;
          if ( __n % 2 )
            __y = __y * __x;
        }

      return __y;
    }
# 53
}
# 49 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cstddef" 3
namespace std __attribute((__visibility__("default"))) { 
# 51
using ::ptrdiff_t;
# 52
using ::size_t;
# 54
}
# 100 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cstdlib" 3
namespace std __attribute((__visibility__("default"))) { 
# 102
using ::div_t;
# 103
using ::ldiv_t;
# 105
using ::abort;
# 106
using ::abs;
# 107
using ::atexit;
# 108
using ::atof;
# 109
using ::atoi;
# 110
using ::atol;
# 111
using ::bsearch;
# 112
using ::calloc;
# 113
using ::div;
# 114
using ::exit;
# 115
using ::free;
# 116
using ::getenv;
# 117
using ::labs;
# 118
using ::ldiv;
# 119
using ::malloc;
# 121
using ::mblen;
# 122
using ::mbstowcs;
# 123
using ::mbtowc;
# 125
using ::qsort;
# 126
using ::rand;
# 127
using ::realloc;
# 128
using ::srand;
# 129
using ::strtod;
# 130
using ::strtol;
# 131
using ::strtoul;
# 132
using ::system;
# 134
using ::wcstombs;
# 135
using ::wctomb;
# 139
inline long abs(long __i) { return labs(__i); } 
# 142
inline ldiv_t div(long __i, long __j) { return ldiv(__i, __j); } 
# 144
}
# 157 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cstdlib" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 160
using ::lldiv_t;
# 166
using ::_Exit;
# 170
inline long long abs(long long __x) { return (__x >= (0)) ? __x : (-__x); } 
# 173
using ::llabs;
# 176
inline lldiv_t div(long long __n, long long __d) 
# 177
{ lldiv_t __q; (__q.quot) = (__n / __d); (__q.rem) = (__n % __d); return __q; } 
# 179
using ::lldiv;
# 190 "/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cstdlib" 3
using ::atoll;
# 191
using ::strtoll;
# 192
using ::strtoull;
# 194
using ::strtof;
# 195
using ::strtold;
# 197
}
# 199
namespace std __attribute((__visibility__("default"))) { 
# 202
using __gnu_cxx::lldiv_t;
# 204
using __gnu_cxx::_Exit;
# 205
using __gnu_cxx::abs;
# 207
using __gnu_cxx::llabs;
# 208
using __gnu_cxx::div;
# 209
using __gnu_cxx::lldiv;
# 211
using __gnu_cxx::atoll;
# 212
using __gnu_cxx::strtof;
# 213
using __gnu_cxx::strtoll;
# 214
using __gnu_cxx::strtoull;
# 215
using __gnu_cxx::strtold;
# 217
}
# 7614 "/usr/local/cuda/bin/..//include/math_functions.h"
namespace __gnu_cxx { 
# 7616
extern inline long long abs(long long); 
# 7617
}
# 7620
namespace std { 
# 7622
template< class T> extern inline T __pow_helper(T, int); 
# 7623
template< class T> extern inline T __cmath_power(T, unsigned); 
# 7624
}
# 7626
using std::abs;
# 7627
using std::fabs;
# 7628
using std::ceil;
# 7629
using std::floor;
# 7630
using std::sqrt;
# 7631
using std::pow;
# 7632
using std::log;
# 7633
using std::log10;
# 7634
using std::fmod;
# 7635
using std::modf;
# 7636
using std::exp;
# 7637
using std::frexp;
# 7638
using std::ldexp;
# 7639
using std::asin;
# 7640
using std::sin;
# 7641
using std::sinh;
# 7642
using std::acos;
# 7643
using std::cos;
# 7644
using std::cosh;
# 7645
using std::atan;
# 7646
using std::atan2;
# 7647
using std::tan;
# 7648
using std::tanh;
# 7818 "/usr/local/cuda/bin/..//include/math_functions.h"
namespace std { 
# 7828 "/usr/local/cuda/bin/..//include/math_functions.h"
extern inline long abs(long); 
# 7829
extern inline float abs(float); 
# 7830
extern inline double abs(double); 
# 7831
extern inline float fabs(float); 
# 7832
extern inline float ceil(float); 
# 7833
extern inline float floor(float); 
# 7834
extern inline float sqrt(float); 
# 7835
extern inline float pow(float, float); 
# 7836
extern inline float pow(float, int); 
# 7837
extern inline double pow(double, int); 
# 7838
extern inline float log(float); 
# 7839
extern inline float log10(float); 
# 7840
extern inline float fmod(float, float); 
# 7841
extern inline float modf(float, float *); 
# 7842
extern inline float exp(float); 
# 7843
extern inline float frexp(float, int *); 
# 7844
extern inline float ldexp(float, int); 
# 7845
extern inline float asin(float); 
# 7846
extern inline float sin(float); 
# 7847
extern inline float sinh(float); 
# 7848
extern inline float acos(float); 
# 7849
extern inline float cos(float); 
# 7850
extern inline float cosh(float); 
# 7851
extern inline float atan(float); 
# 7852
extern inline float atan2(float, float); 
# 7853
extern inline float tan(float); 
# 7854
extern inline float tanh(float); 
# 7857
}
# 7860
static inline float logb(float a) 
# 7861
{ 
# 7862
return logbf(a); 
# 7863
} 
# 7865
static inline int ilogb(float a) 
# 7866
{ 
# 7867
return ilogbf(a); 
# 7868
} 
# 7870
static inline float scalbn(float a, int b) 
# 7871
{ 
# 7872
return scalbnf(a, b); 
# 7873
} 
# 7875
static inline float scalbln(float a, long b) 
# 7876
{ 
# 7877
return scalblnf(a, b); 
# 7878
} 
# 7880
static inline float exp2(float a) 
# 7881
{ 
# 7882
return exp2f(a); 
# 7883
} 
# 7885
static inline float exp10(float a) 
# 7886
{ 
# 7887
return exp10f(a); 
# 7888
} 
# 7890
static inline float expm1(float a) 
# 7891
{ 
# 7892
return expm1f(a); 
# 7893
} 
# 7895
static inline float log2(float a) 
# 7896
{ 
# 7897
return log2f(a); 
# 7898
} 
# 7900
static inline float log1p(float a) 
# 7901
{ 
# 7902
return log1pf(a); 
# 7903
} 
# 7905
static inline float rsqrt(float a) 
# 7906
{ 
# 7907
return rsqrtf(a); 
# 7908
} 
# 7910
static inline float acosh(float a) 
# 7911
{ 
# 7912
return acoshf(a); 
# 7913
} 
# 7915
static inline float asinh(float a) 
# 7916
{ 
# 7917
return asinhf(a); 
# 7918
} 
# 7920
static inline float atanh(float a) 
# 7921
{ 
# 7922
return atanhf(a); 
# 7923
} 
# 7925
static inline float hypot(float a, float b) 
# 7926
{ 
# 7927
return hypotf(a, b); 
# 7928
} 
# 7930
static inline float cbrt(float a) 
# 7931
{ 
# 7932
return cbrtf(a); 
# 7933
} 
# 7935
static inline float rcbrt(float a) 
# 7936
{ 
# 7937
return rcbrtf(a); 
# 7938
} 
# 7940
static inline float sinpi(float a) 
# 7941
{ 
# 7942
return sinpif(a); 
# 7943
} 
# 7945
static inline float cospi(float a) 
# 7946
{ 
# 7947
return cospif(a); 
# 7948
} 
# 7950
static inline void sincospi(float a, float *sptr, float *cptr) 
# 7951
{ 
# 7952
sincospif(a, sptr, cptr); 
# 7953
} 
# 7955
static inline void sincos(float a, float *sptr, float *cptr) 
# 7956
{ 
# 7957
sincosf(a, sptr, cptr); 
# 7958
} 
# 7960
static inline float j0(float a) 
# 7961
{ 
# 7962
return j0f(a); 
# 7963
} 
# 7965
static inline float j1(float a) 
# 7966
{ 
# 7967
return j1f(a); 
# 7968
} 
# 7970
static inline float jn(int n, float a) 
# 7971
{ 
# 7972
return jnf(n, a); 
# 7973
} 
# 7975
static inline float y0(float a) 
# 7976
{ 
# 7977
return y0f(a); 
# 7978
} 
# 7980
static inline float y1(float a) 
# 7981
{ 
# 7982
return y1f(a); 
# 7983
} 
# 7985
static inline float yn(int n, float a) 
# 7986
{ 
# 7987
return ynf(n, a); 
# 7988
} 
# 7990
static inline float erf(float a) 
# 7991
{ 
# 7992
return erff(a); 
# 7993
} 
# 7995
static inline float erfinv(float a) 
# 7996
{ 
# 7997
return erfinvf(a); 
# 7998
} 
# 8000
static inline float erfc(float a) 
# 8001
{ 
# 8002
return erfcf(a); 
# 8003
} 
# 8005
static inline float erfcinv(float a) 
# 8006
{ 
# 8007
return erfcinvf(a); 
# 8008
} 
# 8010
static inline float normcdfinv(float a) 
# 8011
{ 
# 8012
return normcdfinvf(a); 
# 8013
} 
# 8015
static inline float normcdf(float a) 
# 8016
{ 
# 8017
return normcdff(a); 
# 8018
} 
# 8020
static inline float erfcx(float a) 
# 8021
{ 
# 8022
return erfcxf(a); 
# 8023
} 
# 8025
static inline float lgamma(float a) 
# 8026
{ 
# 8027
return lgammaf(a); 
# 8028
} 
# 8030
static inline float tgamma(float a) 
# 8031
{ 
# 8032
return tgammaf(a); 
# 8033
} 
# 8035
static inline float copysign(float a, float b) 
# 8036
{ 
# 8037
return copysignf(a, b); 
# 8038
} 
# 8040
static inline double copysign(double a, float b) 
# 8041
{ 
# 8042
return copysign(a, (double)b); 
# 8043
} 
# 8045
static inline float copysign(float a, double b) 
# 8046
{ 
# 8047
return copysignf(a, (float)b); 
# 8048
} 
# 8050
static inline float nextafter(float a, float b) 
# 8051
{ 
# 8052
return nextafterf(a, b); 
# 8053
} 
# 8055
static inline float remainder(float a, float b) 
# 8056
{ 
# 8057
return remainderf(a, b); 
# 8058
} 
# 8060
static inline float remquo(float a, float b, int *quo) 
# 8061
{ 
# 8062
return remquof(a, b, quo); 
# 8063
} 
# 8065
static inline float round(float a) 
# 8066
{ 
# 8067
return roundf(a); 
# 8068
} 
# 8070
static inline long lround(float a) 
# 8071
{ 
# 8072
return lroundf(a); 
# 8073
} 
# 8075
static inline long long llround(float a) 
# 8076
{ 
# 8077
return llroundf(a); 
# 8078
} 
# 8080
static inline float trunc(float a) 
# 8081
{ 
# 8082
return truncf(a); 
# 8083
} 
# 8085
static inline float rint(float a) 
# 8086
{ 
# 8087
return rintf(a); 
# 8088
} 
# 8090
static inline long lrint(float a) 
# 8091
{ 
# 8092
return lrintf(a); 
# 8093
} 
# 8095
static inline long long llrint(float a) 
# 8096
{ 
# 8097
return llrintf(a); 
# 8098
} 
# 8100
static inline float nearbyint(float a) 
# 8101
{ 
# 8102
return nearbyintf(a); 
# 8103
} 
# 8105
static inline float fdim(float a, float b) 
# 8106
{ 
# 8107
return fdimf(a, b); 
# 8108
} 
# 8110
static inline float fma(float a, float b, float c) 
# 8111
{ 
# 8112
return fmaf(a, b, c); 
# 8113
} 
# 8115
static inline float fmax(float a, float b) 
# 8116
{ 
# 8117
return fmaxf(a, b); 
# 8118
} 
# 8120
static inline float fmin(float a, float b) 
# 8121
{ 
# 8122
return fminf(a, b); 
# 8123
} 
# 8125
static inline unsigned min(unsigned a, unsigned b) 
# 8126
{ 
# 8127
return umin(a, b); 
# 8128
} 
# 8130
static inline unsigned min(int a, unsigned b) 
# 8131
{ 
# 8132
return umin((unsigned)a, b); 
# 8133
} 
# 8135
static inline unsigned min(unsigned a, int b) 
# 8136
{ 
# 8137
return umin(a, (unsigned)b); 
# 8138
} 
# 8140
static inline long long min(long long a, long long b) 
# 8141
{ 
# 8142
return llmin(a, b); 
# 8143
} 
# 8145
static inline unsigned long long min(unsigned long long a, unsigned long long b) 
# 8146
{ 
# 8147
return ullmin(a, b); 
# 8148
} 
# 8150
static inline unsigned long long min(long long a, unsigned long long b) 
# 8151
{ 
# 8152
return ullmin((unsigned long long)a, b); 
# 8153
} 
# 8155
static inline unsigned long long min(unsigned long long a, long long b) 
# 8156
{ 
# 8157
return ullmin(a, (unsigned long long)b); 
# 8158
} 
# 8160
static inline float min(float a, float b) 
# 8161
{ 
# 8162
return fminf(a, b); 
# 8163
} 
# 8165
static inline double min(double a, double b) 
# 8166
{ 
# 8167
return fmin(a, b); 
# 8168
} 
# 8170
static inline double min(float a, double b) 
# 8171
{ 
# 8172
return fmin((double)a, b); 
# 8173
} 
# 8175
static inline double min(double a, float b) 
# 8176
{ 
# 8177
return fmin(a, (double)b); 
# 8178
} 
# 8180
static inline unsigned max(unsigned a, unsigned b) 
# 8181
{ 
# 8182
return umax(a, b); 
# 8183
} 
# 8185
static inline unsigned max(int a, unsigned b) 
# 8186
{ 
# 8187
return umax((unsigned)a, b); 
# 8188
} 
# 8190
static inline unsigned max(unsigned a, int b) 
# 8191
{ 
# 8192
return umax(a, (unsigned)b); 
# 8193
} 
# 8195
static inline long long max(long long a, long long b) 
# 8196
{ 
# 8197
return llmax(a, b); 
# 8198
} 
# 8200
static inline unsigned long long max(unsigned long long a, unsigned long long b) 
# 8201
{ 
# 8202
return ullmax(a, b); 
# 8203
} 
# 8205
static inline unsigned long long max(long long a, unsigned long long b) 
# 8206
{ 
# 8207
return ullmax((unsigned long long)a, b); 
# 8208
} 
# 8210
static inline unsigned long long max(unsigned long long a, long long b) 
# 8211
{ 
# 8212
return ullmax(a, (unsigned long long)b); 
# 8213
} 
# 8215
static inline float max(float a, float b) 
# 8216
{ 
# 8217
return fmaxf(a, b); 
# 8218
} 
# 8220
static inline double max(double a, double b) 
# 8221
{ 
# 8222
return fmax(a, b); 
# 8223
} 
# 8225
static inline double max(float a, double b) 
# 8226
{ 
# 8227
return fmax((double)a, b); 
# 8228
} 
# 8230
static inline double max(double a, float b) 
# 8231
{ 
# 8232
return fmax(a, (double)b); 
# 8233
} 
# 73 "/usr/local/cuda/bin/..//include/cuda_surface_types.h"
template< class T, int dim = 1> 
# 74
struct surface : public surfaceReference { 
# 76
surface() 
# 77
{ 
# 78
(channelDesc) = cudaCreateChannelDesc< T> (); 
# 79
} 
# 81
surface(cudaChannelFormatDesc desc) 
# 82
{ 
# 83
(channelDesc) = desc; 
# 84
} 
# 85
}; 
# 87
template< int dim> 
# 88
struct surface< void, dim>  : public surfaceReference { 
# 90
surface() 
# 91
{ 
# 92
(channelDesc) = cudaCreateChannelDesc< void> (); 
# 93
} 
# 94
}; 
# 73 "/usr/local/cuda/bin/..//include/cuda_texture_types.h"
template< class T, int texType = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
# 74
struct texture : public textureReference { 
# 76
texture(int norm = 0, cudaTextureFilterMode 
# 77
fMode = cudaFilterModePoint, cudaTextureAddressMode 
# 78
aMode = cudaAddressModeClamp) 
# 79
{ 
# 80
(normalized) = norm; 
# 81
(filterMode) = fMode; 
# 82
((addressMode)[0]) = aMode; 
# 83
((addressMode)[1]) = aMode; 
# 84
((addressMode)[2]) = aMode; 
# 85
(channelDesc) = cudaCreateChannelDesc< T> (); 
# 86
(sRGB) = 0; 
# 87
} 
# 89
texture(int norm, cudaTextureFilterMode 
# 90
fMode, cudaTextureAddressMode 
# 91
aMode, cudaChannelFormatDesc 
# 92
desc) 
# 93
{ 
# 94
(normalized) = norm; 
# 95
(filterMode) = fMode; 
# 96
((addressMode)[0]) = aMode; 
# 97
((addressMode)[1]) = aMode; 
# 98
((addressMode)[2]) = aMode; 
# 99
(channelDesc) = desc; 
# 100
(sRGB) = 0; 
# 101
} 
# 102
}; 
# 2285 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline int mulhi(int a, int b) 
# 2286
{int volatile ___ = 1;(void)a;(void)b;
# 2288
::exit(___);}
#if 0
# 2286
{ 
# 2287
return __mulhi(a, b); 
# 2288
} 
#endif
# 2290 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline unsigned mulhi(unsigned a, unsigned b) 
# 2291
{int volatile ___ = 1;(void)a;(void)b;
# 2293
::exit(___);}
#if 0
# 2291
{ 
# 2292
return __umulhi(a, b); 
# 2293
} 
#endif
# 2295 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline unsigned mulhi(int a, unsigned b) 
# 2296
{int volatile ___ = 1;(void)a;(void)b;
# 2298
::exit(___);}
#if 0
# 2296
{ 
# 2297
return __umulhi((unsigned)a, b); 
# 2298
} 
#endif
# 2300 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline unsigned mulhi(unsigned a, int b) 
# 2301
{int volatile ___ = 1;(void)a;(void)b;
# 2303
::exit(___);}
#if 0
# 2301
{ 
# 2302
return __umulhi(a, (unsigned)b); 
# 2303
} 
#endif
# 2305 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline long long mul64hi(long long a, long long b) 
# 2306
{int volatile ___ = 1;(void)a;(void)b;
# 2308
::exit(___);}
#if 0
# 2306
{ 
# 2307
return __mul64hi(a, b); 
# 2308
} 
#endif
# 2310 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, unsigned long long b) 
# 2311
{int volatile ___ = 1;(void)a;(void)b;
# 2313
::exit(___);}
#if 0
# 2311
{ 
# 2312
return __umul64hi(a, b); 
# 2313
} 
#endif
# 2315 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline unsigned long long mul64hi(long long a, unsigned long long b) 
# 2316
{int volatile ___ = 1;(void)a;(void)b;
# 2318
::exit(___);}
#if 0
# 2316
{ 
# 2317
return __umul64hi((unsigned long long)a, b); 
# 2318
} 
#endif
# 2320 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, long long b) 
# 2321
{int volatile ___ = 1;(void)a;(void)b;
# 2323
::exit(___);}
#if 0
# 2321
{ 
# 2322
return __umul64hi(a, (unsigned long long)b); 
# 2323
} 
#endif
# 2325 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline int float_as_int(float a) 
# 2326
{int volatile ___ = 1;(void)a;
# 2328
::exit(___);}
#if 0
# 2326
{ 
# 2327
return __float_as_int(a); 
# 2328
} 
#endif
# 2330 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline float int_as_float(int a) 
# 2331
{int volatile ___ = 1;(void)a;
# 2333
::exit(___);}
#if 0
# 2331
{ 
# 2332
return __int_as_float(a); 
# 2333
} 
#endif
# 2335 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline float saturate(float a) 
# 2336
{int volatile ___ = 1;(void)a;
# 2338
::exit(___);}
#if 0
# 2336
{ 
# 2337
return __saturatef(a); 
# 2338
} 
#endif
# 2340 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline int mul24(int a, int b) 
# 2341
{int volatile ___ = 1;(void)a;(void)b;
# 2343
::exit(___);}
#if 0
# 2341
{ 
# 2342
return __mul24(a, b); 
# 2343
} 
#endif
# 2345 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline unsigned umul24(unsigned a, unsigned b) 
# 2346
{int volatile ___ = 1;(void)a;(void)b;
# 2348
::exit(___);}
#if 0
# 2346
{ 
# 2347
return __umul24(a, b); 
# 2348
} 
#endif
# 2350 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline void trap() 
# 2351
{int volatile ___ = 1;
# 2353
::exit(___);}
#if 0
# 2351
{ 
# 2352
__trap(); 
# 2353
} 
#endif
# 2356 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline void brkpt(int c = 0) 
# 2357
{int volatile ___ = 1;(void)c;
# 2359
::exit(___);}
#if 0
# 2357
{ 
# 2358
__brkpt(c); 
# 2359
} 
#endif
# 2361 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline void syncthreads() 
# 2362
{int volatile ___ = 1;
# 2364
::exit(___);}
#if 0
# 2362
{ 
# 2363
__syncthreads(); 
# 2364
} 
#endif
# 2366 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline void prof_trigger(int e) 
# 2367
{int volatile ___ = 1;(void)e;
# 2384
::exit(___);}
#if 0
# 2367
{ 
# 2368
if (e == 0) { __prof_trigger(0); } else { 
# 2369
if (e == 1) { __prof_trigger(1); } else { 
# 2370
if (e == 2) { __prof_trigger(2); } else { 
# 2371
if (e == 3) { __prof_trigger(3); } else { 
# 2372
if (e == 4) { __prof_trigger(4); } else { 
# 2373
if (e == 5) { __prof_trigger(5); } else { 
# 2374
if (e == 6) { __prof_trigger(6); } else { 
# 2375
if (e == 7) { __prof_trigger(7); } else { 
# 2376
if (e == 8) { __prof_trigger(8); } else { 
# 2377
if (e == 9) { __prof_trigger(9); } else { 
# 2378
if (e == 10) { __prof_trigger(10); } else { 
# 2379
if (e == 11) { __prof_trigger(11); } else { 
# 2380
if (e == 12) { __prof_trigger(12); } else { 
# 2381
if (e == 13) { __prof_trigger(13); } else { 
# 2382
if (e == 14) { __prof_trigger(14); } else { 
# 2383
if (e == 15) { __prof_trigger(15); }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  
# 2384
} 
#endif
# 2386 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline void threadfence(bool global = true) 
# 2387
{int volatile ___ = 1;(void)global;
# 2389
::exit(___);}
#if 0
# 2387
{ 
# 2388
global ? __threadfence() : __threadfence_block(); 
# 2389
} 
#endif
# 2391 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline int float2int(float a, cudaRoundMode mode = cudaRoundZero) 
# 2392
{int volatile ___ = 1;(void)a;(void)mode;
# 2397
::exit(___);}
#if 0
# 2392
{ 
# 2393
return (mode == (cudaRoundNearest)) ? __float2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2int_rd(a) : __float2int_rz(a))); 
# 2397
} 
#endif
# 2399 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline unsigned float2uint(float a, cudaRoundMode mode = cudaRoundZero) 
# 2400
{int volatile ___ = 1;(void)a;(void)mode;
# 2405
::exit(___);}
#if 0
# 2400
{ 
# 2401
return (mode == (cudaRoundNearest)) ? __float2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2uint_rd(a) : __float2uint_rz(a))); 
# 2405
} 
#endif
# 2407 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline float int2float(int a, cudaRoundMode mode = cudaRoundNearest) 
# 2408
{int volatile ___ = 1;(void)a;(void)mode;
# 2413
::exit(___);}
#if 0
# 2408
{ 
# 2409
return (mode == (cudaRoundZero)) ? __int2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __int2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __int2float_rd(a) : __int2float_rn(a))); 
# 2413
} 
#endif
# 2415 "/usr/local/cuda/bin/..//include/device_functions.h"
__attribute__((unused)) static inline float uint2float(unsigned a, cudaRoundMode mode = cudaRoundNearest) 
# 2416
{int volatile ___ = 1;(void)a;(void)mode;
# 2421
::exit(___);}
#if 0
# 2416
{ 
# 2417
return (mode == (cudaRoundZero)) ? __uint2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __uint2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __uint2float_rd(a) : __uint2float_rn(a))); 
# 2421
} 
#endif
# 96 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline int atomicAdd(int *address, int val) 
# 97
{int volatile ___ = 1;(void)address;(void)val;
# 99
::exit(___);}
#if 0
# 97
{ 
# 98
return __iAtomicAdd(address, val); 
# 99
} 
#endif
# 101 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAdd(unsigned *address, unsigned val) 
# 102
{int volatile ___ = 1;(void)address;(void)val;
# 104
::exit(___);}
#if 0
# 102
{ 
# 103
return __uAtomicAdd(address, val); 
# 104
} 
#endif
# 106 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline int atomicSub(int *address, int val) 
# 107
{int volatile ___ = 1;(void)address;(void)val;
# 109
::exit(___);}
#if 0
# 107
{ 
# 108
return __iAtomicAdd(address, (unsigned)(-((int)val))); 
# 109
} 
#endif
# 111 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicSub(unsigned *address, unsigned val) 
# 112
{int volatile ___ = 1;(void)address;(void)val;
# 114
::exit(___);}
#if 0
# 112
{ 
# 113
return __uAtomicAdd(address, (unsigned)(-((int)val))); 
# 114
} 
#endif
# 116 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline int atomicExch(int *address, int val) 
# 117
{int volatile ___ = 1;(void)address;(void)val;
# 119
::exit(___);}
#if 0
# 117
{ 
# 118
return __iAtomicExch(address, val); 
# 119
} 
#endif
# 121 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicExch(unsigned *address, unsigned val) 
# 122
{int volatile ___ = 1;(void)address;(void)val;
# 124
::exit(___);}
#if 0
# 122
{ 
# 123
return __uAtomicExch(address, val); 
# 124
} 
#endif
# 126 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline float atomicExch(float *address, float val) 
# 127
{int volatile ___ = 1;(void)address;(void)val;
# 129
::exit(___);}
#if 0
# 127
{ 
# 128
return __fAtomicExch(address, val); 
# 129
} 
#endif
# 131 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline int atomicMin(int *address, int val) 
# 132
{int volatile ___ = 1;(void)address;(void)val;
# 134
::exit(___);}
#if 0
# 132
{ 
# 133
return __iAtomicMin(address, val); 
# 134
} 
#endif
# 136 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMin(unsigned *address, unsigned val) 
# 137
{int volatile ___ = 1;(void)address;(void)val;
# 139
::exit(___);}
#if 0
# 137
{ 
# 138
return __uAtomicMin(address, val); 
# 139
} 
#endif
# 141 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline int atomicMax(int *address, int val) 
# 142
{int volatile ___ = 1;(void)address;(void)val;
# 144
::exit(___);}
#if 0
# 142
{ 
# 143
return __iAtomicMax(address, val); 
# 144
} 
#endif
# 146 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMax(unsigned *address, unsigned val) 
# 147
{int volatile ___ = 1;(void)address;(void)val;
# 149
::exit(___);}
#if 0
# 147
{ 
# 148
return __uAtomicMax(address, val); 
# 149
} 
#endif
# 151 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicInc(unsigned *address, unsigned val) 
# 152
{int volatile ___ = 1;(void)address;(void)val;
# 154
::exit(___);}
#if 0
# 152
{ 
# 153
return __uAtomicInc(address, val); 
# 154
} 
#endif
# 156 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicDec(unsigned *address, unsigned val) 
# 157
{int volatile ___ = 1;(void)address;(void)val;
# 159
::exit(___);}
#if 0
# 157
{ 
# 158
return __uAtomicDec(address, val); 
# 159
} 
#endif
# 161 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline int atomicAnd(int *address, int val) 
# 162
{int volatile ___ = 1;(void)address;(void)val;
# 164
::exit(___);}
#if 0
# 162
{ 
# 163
return __iAtomicAnd(address, val); 
# 164
} 
#endif
# 166 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAnd(unsigned *address, unsigned val) 
# 167
{int volatile ___ = 1;(void)address;(void)val;
# 169
::exit(___);}
#if 0
# 167
{ 
# 168
return __uAtomicAnd(address, val); 
# 169
} 
#endif
# 171 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline int atomicOr(int *address, int val) 
# 172
{int volatile ___ = 1;(void)address;(void)val;
# 174
::exit(___);}
#if 0
# 172
{ 
# 173
return __iAtomicOr(address, val); 
# 174
} 
#endif
# 176 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicOr(unsigned *address, unsigned val) 
# 177
{int volatile ___ = 1;(void)address;(void)val;
# 179
::exit(___);}
#if 0
# 177
{ 
# 178
return __uAtomicOr(address, val); 
# 179
} 
#endif
# 181 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline int atomicXor(int *address, int val) 
# 182
{int volatile ___ = 1;(void)address;(void)val;
# 184
::exit(___);}
#if 0
# 182
{ 
# 183
return __iAtomicXor(address, val); 
# 184
} 
#endif
# 186 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicXor(unsigned *address, unsigned val) 
# 187
{int volatile ___ = 1;(void)address;(void)val;
# 189
::exit(___);}
#if 0
# 187
{ 
# 188
return __uAtomicXor(address, val); 
# 189
} 
#endif
# 191 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline int atomicCAS(int *address, int compare, int val) 
# 192
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
# 194
::exit(___);}
#if 0
# 192
{ 
# 193
return __iAtomicCAS(address, compare, val); 
# 194
} 
#endif
# 196 "/usr/local/cuda/bin/..//include/sm_11_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) 
# 197
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
# 199
::exit(___);}
#if 0
# 197
{ 
# 198
return __uAtomicCAS(address, compare, val); 
# 199
} 
#endif
# 81 "/usr/local/cuda/bin/..//include/sm_12_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAdd(unsigned long long *address, unsigned long long val) 
# 82
{int volatile ___ = 1;(void)address;(void)val;
# 84
::exit(___);}
#if 0
# 82
{ 
# 83
return __ullAtomicAdd(address, val); 
# 84
} 
#endif
# 86 "/usr/local/cuda/bin/..//include/sm_12_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicExch(unsigned long long *address, unsigned long long val) 
# 87
{int volatile ___ = 1;(void)address;(void)val;
# 89
::exit(___);}
#if 0
# 87
{ 
# 88
return __ullAtomicExch(address, val); 
# 89
} 
#endif
# 91 "/usr/local/cuda/bin/..//include/sm_12_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicCAS(unsigned long long *address, unsigned long long compare, unsigned long long val) 
# 92
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
# 94
::exit(___);}
#if 0
# 92
{ 
# 93
return __ullAtomicCAS(address, compare, val); 
# 94
} 
#endif
# 96 "/usr/local/cuda/bin/..//include/sm_12_atomic_functions.h"
__attribute__((unused)) static inline bool any(bool cond) 
# 97
{int volatile ___ = 1;(void)cond;
# 99
::exit(___);}
#if 0
# 97
{ 
# 98
return (bool)__any((int)cond); 
# 99
} 
#endif
# 101 "/usr/local/cuda/bin/..//include/sm_12_atomic_functions.h"
__attribute__((unused)) static inline bool all(bool cond) 
# 102
{int volatile ___ = 1;(void)cond;
# 104
::exit(___);}
#if 0
# 102
{ 
# 103
return (bool)__all((int)cond); 
# 104
} 
#endif
# 1133 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline double fma(double a, double b, double c, cudaRoundMode mode) 
# 1134
{int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;
# 1139
::exit(___);}
#if 0
# 1134
{ 
# 1135
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
# 1139
} 
#endif
# 1141 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest) 
# 1142
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 1147
::exit(___);}
#if 0
# 1142
{ 
# 1143
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
# 1147
} 
#endif
# 1149 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest) 
# 1150
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 1155
::exit(___);}
#if 0
# 1150
{ 
# 1151
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
# 1155
} 
#endif
# 1157 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest) 
# 1158
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 1163
::exit(___);}
#if 0
# 1158
{ 
# 1159
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
# 1163
} 
#endif
# 1165 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline int double2int(double a, cudaRoundMode mode = cudaRoundZero) 
# 1166
{int volatile ___ = 1;(void)a;(void)mode;
# 1171
::exit(___);}
#if 0
# 1166
{ 
# 1167
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
# 1171
} 
#endif
# 1173 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero) 
# 1174
{int volatile ___ = 1;(void)a;(void)mode;
# 1179
::exit(___);}
#if 0
# 1174
{ 
# 1175
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
# 1179
} 
#endif
# 1181 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline long long double2ll(double a, cudaRoundMode mode = cudaRoundZero) 
# 1182
{int volatile ___ = 1;(void)a;(void)mode;
# 1187
::exit(___);}
#if 0
# 1182
{ 
# 1183
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
# 1187
} 
#endif
# 1189 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline unsigned long long double2ull(double a, cudaRoundMode mode = cudaRoundZero) 
# 1190
{int volatile ___ = 1;(void)a;(void)mode;
# 1195
::exit(___);}
#if 0
# 1190
{ 
# 1191
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
# 1195
} 
#endif
# 1197 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline double ll2double(long long a, cudaRoundMode mode = cudaRoundNearest) 
# 1198
{int volatile ___ = 1;(void)a;(void)mode;
# 1203
::exit(___);}
#if 0
# 1198
{ 
# 1199
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
# 1203
} 
#endif
# 1205 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline double ull2double(unsigned long long a, cudaRoundMode mode = cudaRoundNearest) 
# 1206
{int volatile ___ = 1;(void)a;(void)mode;
# 1211
::exit(___);}
#if 0
# 1206
{ 
# 1207
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
# 1211
} 
#endif
# 1213 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest) 
# 1214
{int volatile ___ = 1;(void)a;(void)mode;
# 1216
::exit(___);}
#if 0
# 1214
{ 
# 1215
return (double)a; 
# 1216
} 
#endif
# 1218 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest) 
# 1219
{int volatile ___ = 1;(void)a;(void)mode;
# 1221
::exit(___);}
#if 0
# 1219
{ 
# 1220
return (double)a; 
# 1221
} 
#endif
# 1223 "/usr/local/cuda/bin/..//include/sm_13_double_functions.h"
__attribute__((unused)) static inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest) 
# 1224
{int volatile ___ = 1;(void)a;(void)mode;
# 1226
::exit(___);}
#if 0
# 1224
{ 
# 1225
return (double)a; 
# 1226
} 
#endif
# 77 "/usr/local/cuda/bin/..//include/sm_20_atomic_functions.h"
__attribute__((unused)) static inline float atomicAdd(float *address, float val) 
# 78
{int volatile ___ = 1;(void)address;(void)val;
# 80
::exit(___);}
#if 0
# 78
{ 
# 79
return __fAtomicAdd(address, val); 
# 80
} 
#endif
# 83 "/usr/local/cuda/bin/..//include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMin(long long *address, long long val) 
# 84
{int volatile ___ = 1;(void)address;(void)val;
# 86
::exit(___);}
#if 0
# 84
{ 
# 85
return __illAtomicMin(address, val); 
# 86
} 
#endif
# 88 "/usr/local/cuda/bin/..//include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMax(long long *address, long long val) 
# 89
{int volatile ___ = 1;(void)address;(void)val;
# 91
::exit(___);}
#if 0
# 89
{ 
# 90
return __illAtomicMax(address, val); 
# 91
} 
#endif
# 93 "/usr/local/cuda/bin/..//include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMin(unsigned long long *address, unsigned long long val) 
# 94
{int volatile ___ = 1;(void)address;(void)val;
# 96
::exit(___);}
#if 0
# 94
{ 
# 95
return __ullAtomicMin(address, val); 
# 96
} 
#endif
# 98 "/usr/local/cuda/bin/..//include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMax(unsigned long long *address, unsigned long long val) 
# 99
{int volatile ___ = 1;(void)address;(void)val;
# 101
::exit(___);}
#if 0
# 99
{ 
# 100
return __ullAtomicMax(address, val); 
# 101
} 
#endif
# 103 "/usr/local/cuda/bin/..//include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAnd(unsigned long long *address, unsigned long long val) 
# 104
{int volatile ___ = 1;(void)address;(void)val;
# 106
::exit(___);}
#if 0
# 104
{ 
# 105
return __ullAtomicAnd(address, val); 
# 106
} 
#endif
# 108 "/usr/local/cuda/bin/..//include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicOr(unsigned long long *address, unsigned long long val) 
# 109
{int volatile ___ = 1;(void)address;(void)val;
# 111
::exit(___);}
#if 0
# 109
{ 
# 110
return __ullAtomicOr(address, val); 
# 111
} 
#endif
# 113 "/usr/local/cuda/bin/..//include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicXor(unsigned long long *address, unsigned long long val) 
# 114
{int volatile ___ = 1;(void)address;(void)val;
# 116
::exit(___);}
#if 0
# 114
{ 
# 115
return __ullAtomicXor(address, val); 
# 116
} 
#endif
# 407 "/usr/local/cuda/bin/..//include/sm_20_intrinsics.h"
__attribute__((unused)) static inline unsigned ballot(bool pred) 
# 408
{int volatile ___ = 1;(void)pred;
# 410
::exit(___);}
#if 0
# 408
{ 
# 409
return __ballot((int)pred); 
# 410
} 
#endif
# 412 "/usr/local/cuda/bin/..//include/sm_20_intrinsics.h"
__attribute__((unused)) static inline int syncthreads_count(bool pred) 
# 413
{int volatile ___ = 1;(void)pred;
# 415
::exit(___);}
#if 0
# 413
{ 
# 414
return __syncthreads_count((int)pred); 
# 415
} 
#endif
# 417 "/usr/local/cuda/bin/..//include/sm_20_intrinsics.h"
__attribute__((unused)) static inline bool syncthreads_and(bool pred) 
# 418
{int volatile ___ = 1;(void)pred;
# 420
::exit(___);}
#if 0
# 418
{ 
# 419
return (bool)__syncthreads_and((int)pred); 
# 420
} 
#endif
# 422 "/usr/local/cuda/bin/..//include/sm_20_intrinsics.h"
__attribute__((unused)) static inline bool syncthreads_or(bool pred) 
# 423
{int volatile ___ = 1;(void)pred;
# 425
::exit(___);}
#if 0
# 423
{ 
# 424
return (bool)__syncthreads_or((int)pred); 
# 425
} 
#endif
# 430 "/usr/local/cuda/bin/..//include/sm_20_intrinsics.h"
__attribute__((unused)) static inline unsigned __isGlobal(const void *ptr) 
# 431
{int volatile ___ = 1;(void)ptr;
# 444
::exit(___);}
#if 0
# 431
{ 
# 432
unsigned ret; 
# 433
__asm__ volatile("{ \n\t    .reg .pred p; \n\t    isspacep.global p, %1; \n\t    selp.u32 %0, 1, 0, p;  \n\t} \n\t" : "=r" (ret) : "l" (ptr)); 
# 443
return ret; 
# 444
} 
#endif
# 93 "/usr/local/cuda/bin/..//include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl(int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
# 98
::exit(___);}
#if 0
# 93
{ 
# 94
int ret, c; 
# 95
c = (((32 - width) << 8) | 31); 
# 96
__asm__ volatile("shfl.idx.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (var), "r" (srcLane), "r" (c)); 
# 97
return ret; 
# 98
} 
#endif
# 100 "/usr/local/cuda/bin/..//include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_up(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 105
::exit(___);}
#if 0
# 100
{ 
# 101
int ret, c; 
# 102
c = ((32 - width) << 8); 
# 103
__asm__ volatile("shfl.up.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (var), "r" (delta), "r" (c)); 
# 104
return ret; 
# 105
} 
#endif
# 107 "/usr/local/cuda/bin/..//include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_down(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 112
::exit(___);}
#if 0
# 107
{ 
# 108
int ret, c; 
# 109
c = (((32 - width) << 8) | 31); 
# 110
__asm__ volatile("shfl.down.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (var), "r" (delta), "r" (c)); 
# 111
return ret; 
# 112
} 
#endif
# 114 "/usr/local/cuda/bin/..//include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_xor(int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
# 119
::exit(___);}
#if 0
# 114
{ 
# 115
int ret, c; 
# 116
c = (((32 - width) << 8) | 31); 
# 117
__asm__ volatile("shfl.bfly.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (var), "r" (laneMask), "r" (c)); 
# 118
return ret; 
# 119
} 
#endif
# 121 "/usr/local/cuda/bin/..//include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl(float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
# 127
::exit(___);}
#if 0
# 121
{ 
# 122
float ret; 
# 123
int c; 
# 124
c = (((32 - width) << 8) | 31); 
# 125
__asm__ volatile("shfl.idx.b32 %0, %1, %2, %3;" : "=f" (ret) : "f" (var), "r" (srcLane), "r" (c)); 
# 126
return ret; 
# 127
} 
#endif
# 129 "/usr/local/cuda/bin/..//include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_up(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 135
::exit(___);}
#if 0
# 129
{ 
# 130
float ret; 
# 131
int c; 
# 132
c = ((32 - width) << 8); 
# 133
__asm__ volatile("shfl.up.b32 %0, %1, %2, %3;" : "=f" (ret) : "f" (var), "r" (delta), "r" (c)); 
# 134
return ret; 
# 135
} 
#endif
# 137 "/usr/local/cuda/bin/..//include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_down(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 143
::exit(___);}
#if 0
# 137
{ 
# 138
float ret; 
# 139
int c; 
# 140
c = (((32 - width) << 8) | 31); 
# 141
__asm__ volatile("shfl.down.b32 %0, %1, %2, %3;" : "=f" (ret) : "f" (var), "r" (delta), "r" (c)); 
# 142
return ret; 
# 143
} 
#endif
# 145 "/usr/local/cuda/bin/..//include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_xor(float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
# 151
::exit(___);}
#if 0
# 145
{ 
# 146
float ret; 
# 147
int c; 
# 148
c = (((32 - width) << 8) | 31); 
# 149
__asm__ volatile("shfl.bfly.b32 %0, %1, %2, %3;" : "=f" (ret) : "f" (var), "r" (laneMask), "r" (c)); 
# 150
return ret; 
# 151
} 
#endif
# 91 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 91
{ unsigned ret; __asm__ volatile("ld.global.nc.s8 %0, [%1];" : "=r" (ret) : "l" (ptr)); return (char)ret; } 
#endif
# 92 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 92
{ unsigned short ret; __asm__ volatile("ld.global.nc.s16 %0, [%1];" : "=h" (ret) : "l" (ptr)); return (short)ret; } 
#endif
# 93 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 93
{ unsigned ret; __asm__ volatile("ld.global.nc.s32 %0, [%1];" : "=r" (ret) : "l" (ptr)); return (int)ret; } 
#endif
# 94 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldg(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 94
{ unsigned long long ret; __asm__ volatile("ld.global.nc.s64 %0, [%1];" : "=l" (ret) : "l" (ptr)); return (long long)ret; } 
#endif
# 95 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 95
{ char2 ret; int2 tmp; __asm__ volatile("ld.global.nc.v2.s8 {%0,%1}, [%2];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (ptr)); (ret.x) = ((char)(tmp.x)); (ret.y) = ((char)(tmp.y)); return ret; } 
#endif
# 96 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 96
{ char4 ret; int4 tmp; __asm__ volatile("ld.global.nc.v4.s8 {%0,%1,%2,%3}, [%4];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (ptr)); (ret.x) = ((char)(tmp.x)); (ret.y) = ((char)(tmp.y)); (ret.z) = ((char)(tmp.z)); (ret.w) = ((char)(tmp.w)); return ret; } 
#endif
# 97 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 97
{ short2 ret; __asm__ volatile("ld.global.nc.v2.s16 {%0,%1}, [%2];" : "=h" (ret.x), "=h" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 98 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 98
{ short4 ret; __asm__ volatile("ld.global.nc.v4.s16 {%0,%1,%2,%3}, [%4];" : "=h" (ret.x), "=h" (ret.y), "=h" (ret.z), "=h" (ret.w) : "l" (ptr)); return ret; } 
#endif
# 99 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 99
{ int2 ret; __asm__ volatile("ld.global.nc.v2.s32 {%0,%1}, [%2];" : "=r" (ret.x), "=r" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 100 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 100
{ int4 ret; __asm__ volatile("ld.global.nc.v4.s32 {%0,%1,%2,%3}, [%4];" : "=r" (ret.x), "=r" (ret.y), "=r" (ret.z), "=r" (ret.w) : "l" (ptr)); return ret; } 
#endif
# 101 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 101
{ longlong2 ret; __asm__ volatile("ld.global.nc.v2.s64 %0, [%1];" : "=l" (ret.x), "=l" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 103 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 103
{ unsigned ret; __asm__ volatile("ld.global.nc.u8 %0, [%1];" : "=r" (ret) : "l" (ptr)); return (unsigned char)ret; } 
#endif
# 104 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 104
{ unsigned short ret; __asm__ volatile("ld.global.nc.u16 %0, [%1];" : "=h" (ret) : "l" (ptr)); return ret; } 
#endif
# 105 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 105
{ unsigned ret; __asm__ volatile("ld.global.nc.u32 %0, [%1];" : "=r" (ret) : "l" (ptr)); return ret; } 
#endif
# 106 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldg(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 106
{ unsigned long long ret; __asm__ volatile("ld.global.nc.u64 %0, [%1];" : "=l" (ret) : "l" (ptr)); return ret; } 
#endif
# 107 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 107
{ uchar2 ret; uint2 tmp; __asm__ volatile("ld.global.nc.v2.u8 {%0,%1}, [%2];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (ptr)); (ret.x) = ((unsigned char)(tmp.x)); (ret.y) = ((unsigned char)(tmp.y)); return ret; } 
#endif
# 108 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 108
{ uchar4 ret; uint4 tmp; __asm__ volatile("ld.global.nc.v4.u8 {%0,%1,%2,%3}, [%4];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (ptr)); (ret.x) = ((unsigned char)(tmp.x)); (ret.y) = ((unsigned char)(tmp.y)); (ret.z) = ((unsigned char)(tmp.z)); (ret.w) = ((unsigned char)(tmp.w)); return ret; } 
#endif
# 109 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 109
{ ushort2 ret; __asm__ volatile("ld.global.nc.v2.u16 {%0,%1}, [%2];" : "=h" (ret.x), "=h" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 110 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 110
{ ushort4 ret; __asm__ volatile("ld.global.nc.v4.u16 {%0,%1,%2,%3}, [%4];" : "=h" (ret.x), "=h" (ret.y), "=h" (ret.z), "=h" (ret.w) : "l" (ptr)); return ret; } 
#endif
# 111 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 111
{ uint2 ret; __asm__ volatile("ld.global.nc.v2.u32 {%0,%1}, [%2];" : "=r" (ret.x), "=r" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 112 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 112
{ uint4 ret; __asm__ volatile("ld.global.nc.v4.u32 {%0,%1,%2,%3}, [%4];" : "=r" (ret.x), "=r" (ret.y), "=r" (ret.z), "=r" (ret.w) : "l" (ptr)); return ret; } 
#endif
# 113 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 113
{ ulonglong2 ret; __asm__ volatile("ld.global.nc.v2.u64 %0, [%1];" : "=l" (ret.x), "=l" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 115 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 115
{ float ret; __asm__ volatile("ld.global.nc.f32 %0, [%1];" : "=f" (ret) : "l" (ptr)); return ret; } 
#endif
# 116 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 116
{ double ret; __asm__ volatile("ld.global.nc.f64 %0, [%1];" : "=d" (ret) : "l" (ptr)); return ret; } 
#endif
# 117 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 117
{ float2 ret; __asm__ volatile("ld.global.nc.v2.f32 {%0,%1}, [%2];" : "=f" (ret.x), "=f" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 118 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 118
{ float4 ret; __asm__ volatile("ld.global.nc.v4.f32 {%0,%1,%2,%3}, [%4];" : "=f" (ret.x), "=f" (ret.y), "=f" (ret.z), "=f" (ret.w) : "l" (ptr)); return ret; } 
#endif
# 119 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 119
{ double2 ret; __asm__ volatile("ld.global.nc.v2.f64 {%0,%1}, [%2];" : "=d" (ret.x), "=d" (ret.y) : "l" (ptr)); return ret; } 
#endif
# 130 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) 
# 131
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
# 135
::exit(___);}
#if 0
# 131
{ 
# 132
unsigned ret; 
# 133
__asm__ volatile("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (lo), "r" (hi), "r" (shift)); 
# 134
return ret; 
# 135
} 
#endif
# 136 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) 
# 137
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
# 141
::exit(___);}
#if 0
# 137
{ 
# 138
unsigned ret; 
# 139
__asm__ volatile("shf.l.clamp.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (lo), "r" (hi), "r" (shift)); 
# 140
return ret; 
# 141
} 
#endif
# 144 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) 
# 145
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
# 149
::exit(___);}
#if 0
# 145
{ 
# 146
unsigned ret; 
# 147
__asm__ volatile("shf.r.wrap.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (lo), "r" (hi), "r" (shift)); 
# 148
return ret; 
# 149
} 
#endif
# 150 "/usr/local/cuda/bin/..//include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) 
# 151
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
# 155
::exit(___);}
#if 0
# 151
{ 
# 152
unsigned ret; 
# 153
__asm__ volatile("shf.r.clamp.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (lo), "r" (hi), "r" (shift)); 
# 154
return ret; 
# 155
} 
#endif
# 99 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 100
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(T *res, surface< void, 1>  surf, int x, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 101
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)s;(void)mode;
# 108
::exit(___);}
#if 0
# 101
{ 
# 102
(s == 1) ? ((void)((*((uchar1 *)res)) = __surf1Dreadc1(surf, x, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((ushort1 *)res)) = __surf1Dreads1(surf, x, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((uint1 *)res)) = __surf1Dreadu1(surf, x, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((uint2 *)res)) = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((uint4 *)res)) = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap))) : ((void)0))))); 
# 108
} 
#endif
# 110 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 111
__attribute((always_inline)) __attribute__((unused)) static inline T surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 112
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 118
::exit(___);}
#if 0
# 112
{ 
# 113
T tmp; 
# 115
surf1Dread(&tmp, surf, x, (int)sizeof(T), mode); 
# 117
return tmp; 
# 118
} 
#endif
# 120 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 121
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(T *res, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 122
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)mode;
# 124
::exit(___);}
#if 0
# 122
{ 
# 123
(*res) = surf1Dread< T> (surf, x, mode); 
# 124
} 
#endif
# 127 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 127
__attribute((always_inline)) __attribute__((unused)) inline char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 128
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 130
::exit(___);}
#if 0
# 128
{ 
# 129
return (char)(__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x); 
# 130
} 
#endif
# 133 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 133
__attribute((always_inline)) __attribute__((unused)) inline signed char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 134
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 136
::exit(___);}
#if 0
# 134
{ 
# 135
return (signed char)(__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x); 
# 136
} 
#endif
# 139 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 139
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 140
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 142
::exit(___);}
#if 0
# 140
{ 
# 141
return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x; 
# 142
} 
#endif
# 145 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 145
__attribute((always_inline)) __attribute__((unused)) inline char1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 146
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 148
::exit(___);}
#if 0
# 146
{ 
# 147
return make_char1((signed char)(__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x)); 
# 148
} 
#endif
# 151 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 151
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 152
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 154
::exit(___);}
#if 0
# 152
{ 
# 153
return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap); 
# 154
} 
#endif
# 157 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 157
__attribute((always_inline)) __attribute__((unused)) inline char2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 158
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 162
::exit(___);}
#if 0
# 158
{ 
# 159
uchar2 tmp = __surf1Dreadc2(surf, x, cudaBoundaryModeTrap); 
# 161
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 162
} 
#endif
# 165 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 165
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 166
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 168
::exit(___);}
#if 0
# 166
{ 
# 167
return __surf1Dreadc2(surf, x, cudaBoundaryModeTrap); 
# 168
} 
#endif
# 171 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 171
__attribute((always_inline)) __attribute__((unused)) inline char4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 172
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 176
::exit(___);}
#if 0
# 172
{ 
# 173
uchar4 tmp = __surf1Dreadc4(surf, x, cudaBoundaryModeTrap); 
# 175
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 176
} 
#endif
# 179 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 179
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 180
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 182
::exit(___);}
#if 0
# 180
{ 
# 181
return __surf1Dreadc4(surf, x, cudaBoundaryModeTrap); 
# 182
} 
#endif
# 185 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 185
__attribute((always_inline)) __attribute__((unused)) inline short surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 186
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 188
::exit(___);}
#if 0
# 186
{ 
# 187
return (short)(__surf1Dreads1(surf, x, cudaBoundaryModeTrap).x); 
# 188
} 
#endif
# 191 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 191
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 192
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 194
::exit(___);}
#if 0
# 192
{ 
# 193
return __surf1Dreads1(surf, x, cudaBoundaryModeTrap).x; 
# 194
} 
#endif
# 197 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 197
__attribute((always_inline)) __attribute__((unused)) inline short1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 198
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 200
::exit(___);}
#if 0
# 198
{ 
# 199
return make_short1((signed short)(__surf1Dreads1(surf, x, cudaBoundaryModeTrap).x)); 
# 200
} 
#endif
# 203 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 203
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 204
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 206
::exit(___);}
#if 0
# 204
{ 
# 205
return __surf1Dreads1(surf, x, cudaBoundaryModeTrap); 
# 206
} 
#endif
# 209 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 209
__attribute((always_inline)) __attribute__((unused)) inline short2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 210
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 214
::exit(___);}
#if 0
# 210
{ 
# 211
ushort2 tmp = __surf1Dreads2(surf, x, cudaBoundaryModeTrap); 
# 213
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 214
} 
#endif
# 217 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 217
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 218
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 220
::exit(___);}
#if 0
# 218
{ 
# 219
return __surf1Dreads2(surf, x, cudaBoundaryModeTrap); 
# 220
} 
#endif
# 223 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 223
__attribute((always_inline)) __attribute__((unused)) inline short4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 224
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 228
::exit(___);}
#if 0
# 224
{ 
# 225
ushort4 tmp = __surf1Dreads4(surf, x, cudaBoundaryModeTrap); 
# 227
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 228
} 
#endif
# 231 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 231
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 232
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 234
::exit(___);}
#if 0
# 232
{ 
# 233
return __surf1Dreads4(surf, x, cudaBoundaryModeTrap); 
# 234
} 
#endif
# 237 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 237
__attribute((always_inline)) __attribute__((unused)) inline int surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 238
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 240
::exit(___);}
#if 0
# 238
{ 
# 239
return (int)(__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x); 
# 240
} 
#endif
# 243 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 243
__attribute((always_inline)) __attribute__((unused)) inline unsigned surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 244
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 246
::exit(___);}
#if 0
# 244
{ 
# 245
return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x; 
# 246
} 
#endif
# 249 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 249
__attribute((always_inline)) __attribute__((unused)) inline int1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 250
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 252
::exit(___);}
#if 0
# 250
{ 
# 251
return make_int1((signed int)(__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x)); 
# 252
} 
#endif
# 255 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 255
__attribute((always_inline)) __attribute__((unused)) inline uint1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 256
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 258
::exit(___);}
#if 0
# 256
{ 
# 257
return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap); 
# 258
} 
#endif
# 261 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 261
__attribute((always_inline)) __attribute__((unused)) inline int2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 262
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 266
::exit(___);}
#if 0
# 262
{ 
# 263
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
# 265
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 266
} 
#endif
# 269 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 269
__attribute((always_inline)) __attribute__((unused)) inline uint2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 270
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 272
::exit(___);}
#if 0
# 270
{ 
# 271
return __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
# 272
} 
#endif
# 275 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 275
__attribute((always_inline)) __attribute__((unused)) inline int4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 276
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 280
::exit(___);}
#if 0
# 276
{ 
# 277
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
# 279
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 280
} 
#endif
# 283 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 283
__attribute((always_inline)) __attribute__((unused)) inline uint4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 284
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 286
::exit(___);}
#if 0
# 284
{ 
# 285
return __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
# 286
} 
#endif
# 289 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 289
__attribute((always_inline)) __attribute__((unused)) inline long long surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 290
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 292
::exit(___);}
#if 0
# 290
{ 
# 291
return (long long)(__surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x); 
# 292
} 
#endif
# 295 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 295
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 296
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 298
::exit(___);}
#if 0
# 296
{ 
# 297
return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x; 
# 298
} 
#endif
# 301 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 301
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 302
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 304
::exit(___);}
#if 0
# 302
{ 
# 303
return make_longlong1((long long)(__surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x)); 
# 304
} 
#endif
# 307 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 307
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 308
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 310
::exit(___);}
#if 0
# 308
{ 
# 309
return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap); 
# 310
} 
#endif
# 313 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 313
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 314
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 318
::exit(___);}
#if 0
# 314
{ 
# 315
ulonglong2 tmp = __surf1Dreadl2(surf, x, cudaBoundaryModeTrap); 
# 317
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 318
} 
#endif
# 321 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111
__attribute((always_inline)) 
# 321
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 322
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 324
::exit(___);}
#if 0
# 322
{ 
# 323
return __surf1Dreadl2(surf, x, cudaBoundaryModeTrap); 
# 324
} 
#endif
# 387 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 387 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 388
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 390
::exit(___);}
#if 0
# 388
{ 
# 389
return __int_as_float((int)(__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x)); 
# 390
} 
#endif
# 393 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 393 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 394
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 396
::exit(___);}
#if 0
# 394
{ 
# 395
return make_float1(__int_as_float((int)(__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x))); 
# 396
} 
#endif
# 399 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 399 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 400
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 404
::exit(___);}
#if 0
# 400
{ 
# 401
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
# 403
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 404
} 
#endif
# 407 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 111 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 407 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
# 408
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 412
::exit(___);}
#if 0
# 408
{ 
# 409
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
# 411
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 412
} 
#endif
# 447 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 448
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(T *res, surface< void, 2>  surf, int x, int y, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 449
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)s;(void)mode;
# 456
::exit(___);}
#if 0
# 449
{ 
# 450
(s == 1) ? ((void)((*((uchar1 *)res)) = __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((ushort1 *)res)) = __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((uint1 *)res)) = __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((uint2 *)res)) = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((uint4 *)res)) = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap))) : ((void)0))))); 
# 456
} 
#endif
# 458 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 459
__attribute((always_inline)) __attribute__((unused)) static inline T surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 460
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 466
::exit(___);}
#if 0
# 460
{ 
# 461
T tmp; 
# 463
surf2Dread(&tmp, surf, x, y, (int)sizeof(T), mode); 
# 465
return tmp; 
# 466
} 
#endif
# 468 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 469
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(T *res, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 470
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)mode;
# 472
::exit(___);}
#if 0
# 470
{ 
# 471
(*res) = surf2Dread< T> (surf, x, y, mode); 
# 472
} 
#endif
# 475 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 475
__attribute((always_inline)) __attribute__((unused)) inline char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 476
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 478
::exit(___);}
#if 0
# 476
{ 
# 477
return (char)(__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x); 
# 478
} 
#endif
# 481 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 481
__attribute((always_inline)) __attribute__((unused)) inline signed char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 482
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 484
::exit(___);}
#if 0
# 482
{ 
# 483
return (signed char)(__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x); 
# 484
} 
#endif
# 487 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 487
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 488
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 490
::exit(___);}
#if 0
# 488
{ 
# 489
return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x; 
# 490
} 
#endif
# 493 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 493
__attribute((always_inline)) __attribute__((unused)) inline char1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 494
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 496
::exit(___);}
#if 0
# 494
{ 
# 495
return make_char1((signed char)(__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x)); 
# 496
} 
#endif
# 499 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 499
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 500
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 502
::exit(___);}
#if 0
# 500
{ 
# 501
return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap); 
# 502
} 
#endif
# 505 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 505
__attribute((always_inline)) __attribute__((unused)) inline char2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 506
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 510
::exit(___);}
#if 0
# 506
{ 
# 507
uchar2 tmp = __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap); 
# 509
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 510
} 
#endif
# 513 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 513
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 514
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 516
::exit(___);}
#if 0
# 514
{ 
# 515
return __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap); 
# 516
} 
#endif
# 519 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 519
__attribute((always_inline)) __attribute__((unused)) inline char4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 520
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 524
::exit(___);}
#if 0
# 520
{ 
# 521
uchar4 tmp = __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap); 
# 523
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 524
} 
#endif
# 527 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 527
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 528
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 530
::exit(___);}
#if 0
# 528
{ 
# 529
return __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap); 
# 530
} 
#endif
# 533 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 533
__attribute((always_inline)) __attribute__((unused)) inline short surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 534
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 536
::exit(___);}
#if 0
# 534
{ 
# 535
return (short)(__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x); 
# 536
} 
#endif
# 539 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 539
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 540
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 542
::exit(___);}
#if 0
# 540
{ 
# 541
return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x; 
# 542
} 
#endif
# 545 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 545
__attribute((always_inline)) __attribute__((unused)) inline short1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 546
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 548
::exit(___);}
#if 0
# 546
{ 
# 547
return make_short1((signed short)(__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x)); 
# 548
} 
#endif
# 551 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 551
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 552
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 554
::exit(___);}
#if 0
# 552
{ 
# 553
return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap); 
# 554
} 
#endif
# 557 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 557
__attribute((always_inline)) __attribute__((unused)) inline short2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 558
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 562
::exit(___);}
#if 0
# 558
{ 
# 559
ushort2 tmp = __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap); 
# 561
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 562
} 
#endif
# 565 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 565
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 566
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 568
::exit(___);}
#if 0
# 566
{ 
# 567
return __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap); 
# 568
} 
#endif
# 571 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 571
__attribute((always_inline)) __attribute__((unused)) inline short4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 572
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 576
::exit(___);}
#if 0
# 572
{ 
# 573
ushort4 tmp = __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap); 
# 575
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 576
} 
#endif
# 579 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 579
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 580
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 582
::exit(___);}
#if 0
# 580
{ 
# 581
return __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap); 
# 582
} 
#endif
# 585 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 585
__attribute((always_inline)) __attribute__((unused)) inline int surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 586
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 588
::exit(___);}
#if 0
# 586
{ 
# 587
return (int)(__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x); 
# 588
} 
#endif
# 591 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 591
__attribute((always_inline)) __attribute__((unused)) inline unsigned surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 592
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 594
::exit(___);}
#if 0
# 592
{ 
# 593
return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x; 
# 594
} 
#endif
# 597 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 597
__attribute((always_inline)) __attribute__((unused)) inline int1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 598
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 600
::exit(___);}
#if 0
# 598
{ 
# 599
return make_int1((signed int)(__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x)); 
# 600
} 
#endif
# 603 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 603
__attribute((always_inline)) __attribute__((unused)) inline uint1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 604
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 606
::exit(___);}
#if 0
# 604
{ 
# 605
return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap); 
# 606
} 
#endif
# 609 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 609
__attribute((always_inline)) __attribute__((unused)) inline int2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 610
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 614
::exit(___);}
#if 0
# 610
{ 
# 611
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
# 613
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 614
} 
#endif
# 617 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 617
__attribute((always_inline)) __attribute__((unused)) inline uint2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 618
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 620
::exit(___);}
#if 0
# 618
{ 
# 619
return __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
# 620
} 
#endif
# 623 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 623
__attribute((always_inline)) __attribute__((unused)) inline int4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 624
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 628
::exit(___);}
#if 0
# 624
{ 
# 625
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
# 627
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 628
} 
#endif
# 631 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 631
__attribute((always_inline)) __attribute__((unused)) inline uint4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 632
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 634
::exit(___);}
#if 0
# 632
{ 
# 633
return __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
# 634
} 
#endif
# 637 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 637
__attribute((always_inline)) __attribute__((unused)) inline long long surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 638
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 640
::exit(___);}
#if 0
# 638
{ 
# 639
return (long long)(__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x); 
# 640
} 
#endif
# 643 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 643
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 644
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 646
::exit(___);}
#if 0
# 644
{ 
# 645
return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x; 
# 646
} 
#endif
# 649 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 649
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 650
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 652
::exit(___);}
#if 0
# 650
{ 
# 651
return make_longlong1((long long)(__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x)); 
# 652
} 
#endif
# 655 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 655
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 656
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 658
::exit(___);}
#if 0
# 656
{ 
# 657
return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap); 
# 658
} 
#endif
# 661 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 661
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 662
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 666
::exit(___);}
#if 0
# 662
{ 
# 663
ulonglong2 tmp = __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap); 
# 665
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 666
} 
#endif
# 669 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459
__attribute((always_inline)) 
# 669
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 670
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 672
::exit(___);}
#if 0
# 670
{ 
# 671
return __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap); 
# 672
} 
#endif
# 735 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 735 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 736
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 738
::exit(___);}
#if 0
# 736
{ 
# 737
return __int_as_float((int)(__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x)); 
# 738
} 
#endif
# 741 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 741 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 742
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 744
::exit(___);}
#if 0
# 742
{ 
# 743
return make_float1(__int_as_float((int)(__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x))); 
# 744
} 
#endif
# 747 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 747 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 748
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 752
::exit(___);}
#if 0
# 748
{ 
# 749
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
# 751
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 752
} 
#endif
# 755 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 459 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 755 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
# 756
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 760
::exit(___);}
#if 0
# 756
{ 
# 757
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
# 759
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 760
} 
#endif
# 795 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 796
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(T *res, surface< void, 3>  surf, int x, int y, int z, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 797
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
# 804
::exit(___);}
#if 0
# 797
{ 
# 798
(s == 1) ? ((void)((*((uchar1 *)res)) = __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((ushort1 *)res)) = __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((uint1 *)res)) = __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((uint2 *)res)) = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((uint4 *)res)) = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap))) : ((void)0))))); 
# 804
} 
#endif
# 806 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 807
__attribute((always_inline)) __attribute__((unused)) static inline T surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 808
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 814
::exit(___);}
#if 0
# 808
{ 
# 809
T tmp; 
# 811
surf3Dread(&tmp, surf, x, y, z, (int)sizeof(T), mode); 
# 813
return tmp; 
# 814
} 
#endif
# 816 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 817
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(T *res, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 818
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 820
::exit(___);}
#if 0
# 818
{ 
# 819
(*res) = surf3Dread< T> (surf, x, y, z, mode); 
# 820
} 
#endif
# 823 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 823
__attribute((always_inline)) __attribute__((unused)) inline char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 824
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 826
::exit(___);}
#if 0
# 824
{ 
# 825
return (char)(__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x); 
# 826
} 
#endif
# 829 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 829
__attribute((always_inline)) __attribute__((unused)) inline signed char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 830
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 832
::exit(___);}
#if 0
# 830
{ 
# 831
return (signed char)(__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x); 
# 832
} 
#endif
# 835 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 835
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 836
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 838
::exit(___);}
#if 0
# 836
{ 
# 837
return __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x; 
# 838
} 
#endif
# 841 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 841
__attribute((always_inline)) __attribute__((unused)) inline char1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 842
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 844
::exit(___);}
#if 0
# 842
{ 
# 843
return make_char1((signed char)(__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x)); 
# 844
} 
#endif
# 847 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 847
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 848
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 850
::exit(___);}
#if 0
# 848
{ 
# 849
return __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap); 
# 850
} 
#endif
# 853 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 853
__attribute((always_inline)) __attribute__((unused)) inline char2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 854
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 858
::exit(___);}
#if 0
# 854
{ 
# 855
uchar2 tmp = __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap); 
# 857
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 858
} 
#endif
# 861 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 861
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 862
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 864
::exit(___);}
#if 0
# 862
{ 
# 863
return __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap); 
# 864
} 
#endif
# 867 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 867
__attribute((always_inline)) __attribute__((unused)) inline char4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 868
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 872
::exit(___);}
#if 0
# 868
{ 
# 869
uchar4 tmp = __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap); 
# 871
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 872
} 
#endif
# 875 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 875
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 876
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 878
::exit(___);}
#if 0
# 876
{ 
# 877
return __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap); 
# 878
} 
#endif
# 881 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 881
__attribute((always_inline)) __attribute__((unused)) inline short surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 882
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 884
::exit(___);}
#if 0
# 882
{ 
# 883
return (short)(__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x); 
# 884
} 
#endif
# 887 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 887
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 888
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 890
::exit(___);}
#if 0
# 888
{ 
# 889
return __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x; 
# 890
} 
#endif
# 893 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 893
__attribute((always_inline)) __attribute__((unused)) inline short1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 894
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 896
::exit(___);}
#if 0
# 894
{ 
# 895
return make_short1((signed short)(__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x)); 
# 896
} 
#endif
# 899 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 899
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 900
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 902
::exit(___);}
#if 0
# 900
{ 
# 901
return __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap); 
# 902
} 
#endif
# 905 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 905
__attribute((always_inline)) __attribute__((unused)) inline short2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 906
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 910
::exit(___);}
#if 0
# 906
{ 
# 907
ushort2 tmp = __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap); 
# 909
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 910
} 
#endif
# 913 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 913
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 914
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 916
::exit(___);}
#if 0
# 914
{ 
# 915
return __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap); 
# 916
} 
#endif
# 919 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 919
__attribute((always_inline)) __attribute__((unused)) inline short4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 920
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 924
::exit(___);}
#if 0
# 920
{ 
# 921
ushort4 tmp = __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap); 
# 923
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 924
} 
#endif
# 927 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 927
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 928
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 930
::exit(___);}
#if 0
# 928
{ 
# 929
return __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap); 
# 930
} 
#endif
# 933 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 933
__attribute((always_inline)) __attribute__((unused)) inline int surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 934
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 936
::exit(___);}
#if 0
# 934
{ 
# 935
return (int)(__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x); 
# 936
} 
#endif
# 939 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 939
__attribute((always_inline)) __attribute__((unused)) inline unsigned surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 940
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 942
::exit(___);}
#if 0
# 940
{ 
# 941
return __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x; 
# 942
} 
#endif
# 945 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 945
__attribute((always_inline)) __attribute__((unused)) inline int1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 946
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 948
::exit(___);}
#if 0
# 946
{ 
# 947
return make_int1((signed int)(__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x)); 
# 948
} 
#endif
# 951 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 951
__attribute((always_inline)) __attribute__((unused)) inline uint1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 952
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 954
::exit(___);}
#if 0
# 952
{ 
# 953
return __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap); 
# 954
} 
#endif
# 957 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 957
__attribute((always_inline)) __attribute__((unused)) inline int2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 958
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 962
::exit(___);}
#if 0
# 958
{ 
# 959
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
# 961
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 962
} 
#endif
# 965 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 965
__attribute((always_inline)) __attribute__((unused)) inline uint2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 966
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 968
::exit(___);}
#if 0
# 966
{ 
# 967
return __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
# 968
} 
#endif
# 971 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 971
__attribute((always_inline)) __attribute__((unused)) inline int4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 972
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 976
::exit(___);}
#if 0
# 972
{ 
# 973
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
# 975
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 976
} 
#endif
# 979 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 979
__attribute((always_inline)) __attribute__((unused)) inline uint4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 980
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 982
::exit(___);}
#if 0
# 980
{ 
# 981
return __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
# 982
} 
#endif
# 985 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 985
__attribute((always_inline)) __attribute__((unused)) inline long long surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 986
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 988
::exit(___);}
#if 0
# 986
{ 
# 987
return (long long)(__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x); 
# 988
} 
#endif
# 991 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 991
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 992
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 994
::exit(___);}
#if 0
# 992
{ 
# 993
return __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x; 
# 994
} 
#endif
# 997 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 997
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 998
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1000
::exit(___);}
#if 0
# 998
{ 
# 999
return make_longlong1((long long)(__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x)); 
# 1000
} 
#endif
# 1003 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 1003
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1004
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1006
::exit(___);}
#if 0
# 1004
{ 
# 1005
return __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap); 
# 1006
} 
#endif
# 1009 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 1009
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1010
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1014
::exit(___);}
#if 0
# 1010
{ 
# 1011
ulonglong2 tmp = __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap); 
# 1013
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 1014
} 
#endif
# 1017 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807
__attribute((always_inline)) 
# 1017
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1018
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1020
::exit(___);}
#if 0
# 1018
{ 
# 1019
return __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap); 
# 1020
} 
#endif
# 1083 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1083 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1084
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1086
::exit(___);}
#if 0
# 1084
{ 
# 1085
return __int_as_float((int)(__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x)); 
# 1086
} 
#endif
# 1089 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1089 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1090
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1092
::exit(___);}
#if 0
# 1090
{ 
# 1091
return make_float1(__int_as_float((int)(__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x))); 
# 1092
} 
#endif
# 1095 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1095 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1096
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1100
::exit(___);}
#if 0
# 1096
{ 
# 1097
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
# 1099
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 1100
} 
#endif
# 1103 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 807 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1103 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
# 1104
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1108
::exit(___);}
#if 0
# 1104
{ 
# 1105
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
# 1107
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 1108
} 
#endif
# 1143 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 1144
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(T *res, surface< void, 241>  surf, int x, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1145
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
# 1152
::exit(___);}
#if 0
# 1145
{ 
# 1146
(s == 1) ? ((void)((*((uchar1 *)res)) = __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((ushort1 *)res)) = __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((uint1 *)res)) = __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((uint2 *)res)) = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((uint4 *)res)) = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap))) : ((void)0))))); 
# 1152
} 
#endif
# 1154 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 1155
__attribute((always_inline)) __attribute__((unused)) static inline T surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1156
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1162
::exit(___);}
#if 0
# 1156
{ 
# 1157
T tmp; 
# 1159
surf1DLayeredread(&tmp, surf, x, layer, (int)sizeof(T), mode); 
# 1161
return tmp; 
# 1162
} 
#endif
# 1164 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 1165
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(T *res, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1166
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)mode;
# 1168
::exit(___);}
#if 0
# 1166
{ 
# 1167
(*res) = surf1DLayeredread< T> (surf, x, layer, mode); 
# 1168
} 
#endif
# 1171 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1171
__attribute((always_inline)) __attribute__((unused)) inline char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1172
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1174
::exit(___);}
#if 0
# 1172
{ 
# 1173
return (char)(__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x); 
# 1174
} 
#endif
# 1177 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1177
__attribute((always_inline)) __attribute__((unused)) inline signed char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1178
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1180
::exit(___);}
#if 0
# 1178
{ 
# 1179
return (signed char)(__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x); 
# 1180
} 
#endif
# 1183 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1183
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1184
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1186
::exit(___);}
#if 0
# 1184
{ 
# 1185
return __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x; 
# 1186
} 
#endif
# 1189 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1189
__attribute((always_inline)) __attribute__((unused)) inline char1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1190
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1192
::exit(___);}
#if 0
# 1190
{ 
# 1191
return make_char1((signed char)(__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x)); 
# 1192
} 
#endif
# 1195 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1195
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1196
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1198
::exit(___);}
#if 0
# 1196
{ 
# 1197
return __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap); 
# 1198
} 
#endif
# 1201 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1201
__attribute((always_inline)) __attribute__((unused)) inline char2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1202
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1206
::exit(___);}
#if 0
# 1202
{ 
# 1203
uchar2 tmp = __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap); 
# 1205
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 1206
} 
#endif
# 1209 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1209
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1210
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1212
::exit(___);}
#if 0
# 1210
{ 
# 1211
return __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap); 
# 1212
} 
#endif
# 1215 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1215
__attribute((always_inline)) __attribute__((unused)) inline char4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1216
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1220
::exit(___);}
#if 0
# 1216
{ 
# 1217
uchar4 tmp = __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap); 
# 1219
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 1220
} 
#endif
# 1223 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1223
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1224
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1226
::exit(___);}
#if 0
# 1224
{ 
# 1225
return __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap); 
# 1226
} 
#endif
# 1229 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1229
__attribute((always_inline)) __attribute__((unused)) inline short surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1230
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1232
::exit(___);}
#if 0
# 1230
{ 
# 1231
return (short)(__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x); 
# 1232
} 
#endif
# 1235 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1235
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1236
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1238
::exit(___);}
#if 0
# 1236
{ 
# 1237
return __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x; 
# 1238
} 
#endif
# 1241 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1241
__attribute((always_inline)) __attribute__((unused)) inline short1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1242
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1244
::exit(___);}
#if 0
# 1242
{ 
# 1243
return make_short1((signed short)(__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x)); 
# 1244
} 
#endif
# 1247 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1247
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1248
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1250
::exit(___);}
#if 0
# 1248
{ 
# 1249
return __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap); 
# 1250
} 
#endif
# 1253 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1253
__attribute((always_inline)) __attribute__((unused)) inline short2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1254
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1258
::exit(___);}
#if 0
# 1254
{ 
# 1255
ushort2 tmp = __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap); 
# 1257
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 1258
} 
#endif
# 1261 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1261
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1262
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1264
::exit(___);}
#if 0
# 1262
{ 
# 1263
return __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap); 
# 1264
} 
#endif
# 1267 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1267
__attribute((always_inline)) __attribute__((unused)) inline short4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1268
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1272
::exit(___);}
#if 0
# 1268
{ 
# 1269
ushort4 tmp = __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap); 
# 1271
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 1272
} 
#endif
# 1275 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1275
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1276
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1278
::exit(___);}
#if 0
# 1276
{ 
# 1277
return __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap); 
# 1278
} 
#endif
# 1281 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1281
__attribute((always_inline)) __attribute__((unused)) inline int surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1282
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1284
::exit(___);}
#if 0
# 1282
{ 
# 1283
return (int)(__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x); 
# 1284
} 
#endif
# 1287 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1287
__attribute((always_inline)) __attribute__((unused)) inline unsigned surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1288
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1290
::exit(___);}
#if 0
# 1288
{ 
# 1289
return __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x; 
# 1290
} 
#endif
# 1293 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1293
__attribute((always_inline)) __attribute__((unused)) inline int1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1294
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1296
::exit(___);}
#if 0
# 1294
{ 
# 1295
return make_int1((signed int)(__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x)); 
# 1296
} 
#endif
# 1299 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1299
__attribute((always_inline)) __attribute__((unused)) inline uint1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1300
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1302
::exit(___);}
#if 0
# 1300
{ 
# 1301
return __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap); 
# 1302
} 
#endif
# 1305 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1305
__attribute((always_inline)) __attribute__((unused)) inline int2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1306
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1310
::exit(___);}
#if 0
# 1306
{ 
# 1307
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
# 1309
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 1310
} 
#endif
# 1313 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1313
__attribute((always_inline)) __attribute__((unused)) inline uint2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1314
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1316
::exit(___);}
#if 0
# 1314
{ 
# 1315
return __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
# 1316
} 
#endif
# 1319 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1319
__attribute((always_inline)) __attribute__((unused)) inline int4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1320
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1324
::exit(___);}
#if 0
# 1320
{ 
# 1321
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
# 1323
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 1324
} 
#endif
# 1327 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1327
__attribute((always_inline)) __attribute__((unused)) inline uint4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1328
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1330
::exit(___);}
#if 0
# 1328
{ 
# 1329
return __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
# 1330
} 
#endif
# 1333 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1333
__attribute((always_inline)) __attribute__((unused)) inline long long surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1334
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1336
::exit(___);}
#if 0
# 1334
{ 
# 1335
return (long long)(__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x); 
# 1336
} 
#endif
# 1339 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1339
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1340
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1342
::exit(___);}
#if 0
# 1340
{ 
# 1341
return __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x; 
# 1342
} 
#endif
# 1345 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1345
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1346
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1348
::exit(___);}
#if 0
# 1346
{ 
# 1347
return make_longlong1((long long)(__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x)); 
# 1348
} 
#endif
# 1351 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1351
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1352
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1354
::exit(___);}
#if 0
# 1352
{ 
# 1353
return __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap); 
# 1354
} 
#endif
# 1357 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1357
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1358
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1362
::exit(___);}
#if 0
# 1358
{ 
# 1359
ulonglong2 tmp = __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap); 
# 1361
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 1362
} 
#endif
# 1365 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155
__attribute((always_inline)) 
# 1365
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1366
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1368
::exit(___);}
#if 0
# 1366
{ 
# 1367
return __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap); 
# 1368
} 
#endif
# 1431 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1431 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1432
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1434
::exit(___);}
#if 0
# 1432
{ 
# 1433
return __int_as_float((int)(__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x)); 
# 1434
} 
#endif
# 1437 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1437 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1438
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1440
::exit(___);}
#if 0
# 1438
{ 
# 1439
return make_float1(__int_as_float((int)(__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x))); 
# 1440
} 
#endif
# 1443 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1443 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1444
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1448
::exit(___);}
#if 0
# 1444
{ 
# 1445
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
# 1447
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 1448
} 
#endif
# 1451 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1155 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1451 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
# 1452
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 1456
::exit(___);}
#if 0
# 1452
{ 
# 1453
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
# 1455
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 1456
} 
#endif
# 1491 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 1492
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(T *res, surface< void, 242>  surf, int x, int y, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1493
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
# 1500
::exit(___);}
#if 0
# 1493
{ 
# 1494
(s == 1) ? ((void)((*((uchar1 *)res)) = __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((ushort1 *)res)) = __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((uint1 *)res)) = __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((uint2 *)res)) = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((uint4 *)res)) = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap))) : ((void)0))))); 
# 1500
} 
#endif
# 1502 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 1503
__attribute((always_inline)) __attribute__((unused)) static inline T surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1504
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1510
::exit(___);}
#if 0
# 1504
{ 
# 1505
T tmp; 
# 1507
surf2DLayeredread(&tmp, surf, x, y, layer, (int)sizeof(T), mode); 
# 1509
return tmp; 
# 1510
} 
#endif
# 1512 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 1513
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(T *res, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1514
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1516
::exit(___);}
#if 0
# 1514
{ 
# 1515
(*res) = surf2DLayeredread< T> (surf, x, y, layer, mode); 
# 1516
} 
#endif
# 1519 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1519
__attribute((always_inline)) __attribute__((unused)) inline char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1520
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1522
::exit(___);}
#if 0
# 1520
{ 
# 1521
return (char)(__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x); 
# 1522
} 
#endif
# 1525 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1525
__attribute((always_inline)) __attribute__((unused)) inline signed char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1526
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1528
::exit(___);}
#if 0
# 1526
{ 
# 1527
return (signed char)(__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x); 
# 1528
} 
#endif
# 1531 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1531
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1532
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1534
::exit(___);}
#if 0
# 1532
{ 
# 1533
return __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x; 
# 1534
} 
#endif
# 1537 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1537
__attribute((always_inline)) __attribute__((unused)) inline char1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1538
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1540
::exit(___);}
#if 0
# 1538
{ 
# 1539
return make_char1((signed char)(__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x)); 
# 1540
} 
#endif
# 1543 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1543
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1544
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1546
::exit(___);}
#if 0
# 1544
{ 
# 1545
return __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1546
} 
#endif
# 1549 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1549
__attribute((always_inline)) __attribute__((unused)) inline char2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1550
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1554
::exit(___);}
#if 0
# 1550
{ 
# 1551
uchar2 tmp = __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1553
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 1554
} 
#endif
# 1557 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1557
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1558
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1560
::exit(___);}
#if 0
# 1558
{ 
# 1559
return __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1560
} 
#endif
# 1563 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1563
__attribute((always_inline)) __attribute__((unused)) inline char4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1564
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1568
::exit(___);}
#if 0
# 1564
{ 
# 1565
uchar4 tmp = __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1567
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 1568
} 
#endif
# 1571 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1571
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1572
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1574
::exit(___);}
#if 0
# 1572
{ 
# 1573
return __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1574
} 
#endif
# 1577 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1577
__attribute((always_inline)) __attribute__((unused)) inline short surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1578
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1580
::exit(___);}
#if 0
# 1578
{ 
# 1579
return (short)(__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x); 
# 1580
} 
#endif
# 1583 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1583
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1584
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1586
::exit(___);}
#if 0
# 1584
{ 
# 1585
return __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x; 
# 1586
} 
#endif
# 1589 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1589
__attribute((always_inline)) __attribute__((unused)) inline short1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1590
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1592
::exit(___);}
#if 0
# 1590
{ 
# 1591
return make_short1((signed short)(__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x)); 
# 1592
} 
#endif
# 1595 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1595
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1596
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1598
::exit(___);}
#if 0
# 1596
{ 
# 1597
return __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1598
} 
#endif
# 1601 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1601
__attribute((always_inline)) __attribute__((unused)) inline short2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1602
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1606
::exit(___);}
#if 0
# 1602
{ 
# 1603
ushort2 tmp = __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1605
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 1606
} 
#endif
# 1609 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1609
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1610
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1612
::exit(___);}
#if 0
# 1610
{ 
# 1611
return __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1612
} 
#endif
# 1615 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1615
__attribute((always_inline)) __attribute__((unused)) inline short4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1616
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1620
::exit(___);}
#if 0
# 1616
{ 
# 1617
ushort4 tmp = __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1619
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 1620
} 
#endif
# 1623 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1623
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1624
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1626
::exit(___);}
#if 0
# 1624
{ 
# 1625
return __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1626
} 
#endif
# 1629 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1629
__attribute((always_inline)) __attribute__((unused)) inline int surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1630
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1632
::exit(___);}
#if 0
# 1630
{ 
# 1631
return (int)(__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x); 
# 1632
} 
#endif
# 1635 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1635
__attribute((always_inline)) __attribute__((unused)) inline unsigned surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1636
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1638
::exit(___);}
#if 0
# 1636
{ 
# 1637
return __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x; 
# 1638
} 
#endif
# 1641 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1641
__attribute((always_inline)) __attribute__((unused)) inline int1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1642
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1644
::exit(___);}
#if 0
# 1642
{ 
# 1643
return make_int1((signed int)(__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x)); 
# 1644
} 
#endif
# 1647 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1647
__attribute((always_inline)) __attribute__((unused)) inline uint1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1648
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1650
::exit(___);}
#if 0
# 1648
{ 
# 1649
return __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1650
} 
#endif
# 1653 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1653
__attribute((always_inline)) __attribute__((unused)) inline int2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1654
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1658
::exit(___);}
#if 0
# 1654
{ 
# 1655
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1657
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 1658
} 
#endif
# 1661 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1661
__attribute((always_inline)) __attribute__((unused)) inline uint2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1662
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1664
::exit(___);}
#if 0
# 1662
{ 
# 1663
return __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1664
} 
#endif
# 1667 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1667
__attribute((always_inline)) __attribute__((unused)) inline int4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1668
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1672
::exit(___);}
#if 0
# 1668
{ 
# 1669
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1671
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 1672
} 
#endif
# 1675 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1675
__attribute((always_inline)) __attribute__((unused)) inline uint4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1676
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1678
::exit(___);}
#if 0
# 1676
{ 
# 1677
return __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1678
} 
#endif
# 1681 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1681
__attribute((always_inline)) __attribute__((unused)) inline long long surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1682
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1684
::exit(___);}
#if 0
# 1682
{ 
# 1683
return (long long)(__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x); 
# 1684
} 
#endif
# 1687 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1687
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1688
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1690
::exit(___);}
#if 0
# 1688
{ 
# 1689
return __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x; 
# 1690
} 
#endif
# 1693 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1693
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1694
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1696
::exit(___);}
#if 0
# 1694
{ 
# 1695
return make_longlong1((long long)(__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x)); 
# 1696
} 
#endif
# 1699 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1699
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1700
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1702
::exit(___);}
#if 0
# 1700
{ 
# 1701
return __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1702
} 
#endif
# 1705 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1705
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1706
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1710
::exit(___);}
#if 0
# 1706
{ 
# 1707
ulonglong2 tmp = __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1709
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 1710
} 
#endif
# 1713 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503
__attribute((always_inline)) 
# 1713
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1714
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1716
::exit(___);}
#if 0
# 1714
{ 
# 1715
return __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1716
} 
#endif
# 1779 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1779 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1780
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1782
::exit(___);}
#if 0
# 1780
{ 
# 1781
return __int_as_float((int)(__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x)); 
# 1782
} 
#endif
# 1785 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1785 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1786
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1788
::exit(___);}
#if 0
# 1786
{ 
# 1787
return make_float1(__int_as_float((int)(__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x))); 
# 1788
} 
#endif
# 1791 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1791 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1792
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1796
::exit(___);}
#if 0
# 1792
{ 
# 1793
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1795
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 1796
} 
#endif
# 1799 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1503 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 1799 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
# 1800
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1804
::exit(___);}
#if 0
# 1800
{ 
# 1801
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
# 1803
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 1804
} 
#endif
# 1839 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 1840
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(T *res, surface< void, 12>  surf, int x, int y, int face, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1841
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
# 1848
::exit(___);}
#if 0
# 1841
{ 
# 1842
(s == 1) ? ((void)((*((uchar1 *)res)) = __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((ushort1 *)res)) = __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((uint1 *)res)) = __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((uint2 *)res)) = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((uint4 *)res)) = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap))) : ((void)0))))); 
# 1848
} 
#endif
# 1850 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 1851
__attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1852
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1858
::exit(___);}
#if 0
# 1852
{ 
# 1853
T tmp; 
# 1855
surfCubemapread(&tmp, surf, x, y, face, (int)sizeof(T), mode); 
# 1857
return tmp; 
# 1858
} 
#endif
# 1860 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 1861
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(T *res, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1862
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1864
::exit(___);}
#if 0
# 1862
{ 
# 1863
(*res) = surfCubemapread< T> (surf, x, y, face, mode); 
# 1864
} 
#endif
# 1867 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1867
__attribute((always_inline)) __attribute__((unused)) inline char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1868
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1870
::exit(___);}
#if 0
# 1868
{ 
# 1869
return (char)(__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x); 
# 1870
} 
#endif
# 1873 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1873
__attribute((always_inline)) __attribute__((unused)) inline signed char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1874
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1876
::exit(___);}
#if 0
# 1874
{ 
# 1875
return (signed char)(__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x); 
# 1876
} 
#endif
# 1879 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1879
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1880
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1882
::exit(___);}
#if 0
# 1880
{ 
# 1881
return __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x; 
# 1882
} 
#endif
# 1885 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1885
__attribute((always_inline)) __attribute__((unused)) inline char1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1886
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1888
::exit(___);}
#if 0
# 1886
{ 
# 1887
return make_char1((signed char)(__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x)); 
# 1888
} 
#endif
# 1891 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1891
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1892
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1894
::exit(___);}
#if 0
# 1892
{ 
# 1893
return __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap); 
# 1894
} 
#endif
# 1897 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1897
__attribute((always_inline)) __attribute__((unused)) inline char2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1898
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1902
::exit(___);}
#if 0
# 1898
{ 
# 1899
uchar2 tmp = __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap); 
# 1901
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 1902
} 
#endif
# 1905 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1905
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1906
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1908
::exit(___);}
#if 0
# 1906
{ 
# 1907
return __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap); 
# 1908
} 
#endif
# 1911 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1911
__attribute((always_inline)) __attribute__((unused)) inline char4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1912
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1916
::exit(___);}
#if 0
# 1912
{ 
# 1913
uchar4 tmp = __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap); 
# 1915
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 1916
} 
#endif
# 1919 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1919
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1920
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1922
::exit(___);}
#if 0
# 1920
{ 
# 1921
return __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap); 
# 1922
} 
#endif
# 1925 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1925
__attribute((always_inline)) __attribute__((unused)) inline short surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1926
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1928
::exit(___);}
#if 0
# 1926
{ 
# 1927
return (short)(__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap).x); 
# 1928
} 
#endif
# 1931 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1931
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1932
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1934
::exit(___);}
#if 0
# 1932
{ 
# 1933
return __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap).x; 
# 1934
} 
#endif
# 1937 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1937
__attribute((always_inline)) __attribute__((unused)) inline short1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1938
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1940
::exit(___);}
#if 0
# 1938
{ 
# 1939
return make_short1((signed short)(__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap).x)); 
# 1940
} 
#endif
# 1943 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1943
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1944
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1946
::exit(___);}
#if 0
# 1944
{ 
# 1945
return __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap); 
# 1946
} 
#endif
# 1949 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1949
__attribute((always_inline)) __attribute__((unused)) inline short2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1950
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1954
::exit(___);}
#if 0
# 1950
{ 
# 1951
ushort2 tmp = __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap); 
# 1953
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 1954
} 
#endif
# 1957 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1957
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1958
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1960
::exit(___);}
#if 0
# 1958
{ 
# 1959
return __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap); 
# 1960
} 
#endif
# 1963 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1963
__attribute((always_inline)) __attribute__((unused)) inline short4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1964
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1968
::exit(___);}
#if 0
# 1964
{ 
# 1965
ushort4 tmp = __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap); 
# 1967
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 1968
} 
#endif
# 1971 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1971
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1972
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1974
::exit(___);}
#if 0
# 1972
{ 
# 1973
return __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap); 
# 1974
} 
#endif
# 1977 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1977
__attribute((always_inline)) __attribute__((unused)) inline int surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1978
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1980
::exit(___);}
#if 0
# 1978
{ 
# 1979
return (int)(__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x); 
# 1980
} 
#endif
# 1983 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1983
__attribute((always_inline)) __attribute__((unused)) inline unsigned surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1984
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1986
::exit(___);}
#if 0
# 1984
{ 
# 1985
return __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x; 
# 1986
} 
#endif
# 1989 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1989
__attribute((always_inline)) __attribute__((unused)) inline int1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1990
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1992
::exit(___);}
#if 0
# 1990
{ 
# 1991
return make_int1((signed int)(__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x)); 
# 1992
} 
#endif
# 1995 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 1995
__attribute((always_inline)) __attribute__((unused)) inline uint1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 1996
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1998
::exit(___);}
#if 0
# 1996
{ 
# 1997
return __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap); 
# 1998
} 
#endif
# 2001 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 2001
__attribute((always_inline)) __attribute__((unused)) inline int2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2002
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2006
::exit(___);}
#if 0
# 2002
{ 
# 2003
uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
# 2005
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 2006
} 
#endif
# 2009 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 2009
__attribute((always_inline)) __attribute__((unused)) inline uint2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2010
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2012
::exit(___);}
#if 0
# 2010
{ 
# 2011
return __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
# 2012
} 
#endif
# 2015 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 2015
__attribute((always_inline)) __attribute__((unused)) inline int4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2016
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2020
::exit(___);}
#if 0
# 2016
{ 
# 2017
uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
# 2019
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 2020
} 
#endif
# 2023 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 2023
__attribute((always_inline)) __attribute__((unused)) inline uint4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2024
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2026
::exit(___);}
#if 0
# 2024
{ 
# 2025
return __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
# 2026
} 
#endif
# 2029 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 2029
__attribute((always_inline)) __attribute__((unused)) inline long long surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2030
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2032
::exit(___);}
#if 0
# 2030
{ 
# 2031
return (long long)(__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap).x); 
# 2032
} 
#endif
# 2035 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 2035
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2036
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2038
::exit(___);}
#if 0
# 2036
{ 
# 2037
return __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap).x; 
# 2038
} 
#endif
# 2041 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 2041
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2042
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2044
::exit(___);}
#if 0
# 2042
{ 
# 2043
return make_longlong1((long long)(__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap).x)); 
# 2044
} 
#endif
# 2047 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 2047
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2048
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2050
::exit(___);}
#if 0
# 2048
{ 
# 2049
return __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap); 
# 2050
} 
#endif
# 2053 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 2053
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2054
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2058
::exit(___);}
#if 0
# 2054
{ 
# 2055
ulonglong2 tmp = __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap); 
# 2057
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 2058
} 
#endif
# 2061 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851
__attribute((always_inline)) 
# 2061
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2062
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2064
::exit(___);}
#if 0
# 2062
{ 
# 2063
return __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap); 
# 2064
} 
#endif
# 2127 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 2127 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2128
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2130
::exit(___);}
#if 0
# 2128
{ 
# 2129
return __int_as_float((int)(__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x)); 
# 2130
} 
#endif
# 2133 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 2133 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2134
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2136
::exit(___);}
#if 0
# 2134
{ 
# 2135
return make_float1(__int_as_float((int)(__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x))); 
# 2136
} 
#endif
# 2139 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 2139 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2140
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2144
::exit(___);}
#if 0
# 2140
{ 
# 2141
uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
# 2143
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 2144
} 
#endif
# 2147 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 1851 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 2147 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
# 2148
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 2152
::exit(___);}
#if 0
# 2148
{ 
# 2149
uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
# 2151
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 2152
} 
#endif
# 2188 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 2189
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(T *res, surface< void, 252>  surf, int x, int y, int layerFace, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2190
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
# 2197
::exit(___);}
#if 0
# 2190
{ 
# 2191
(s == 1) ? ((void)((*((uchar1 *)res)) = __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 2) ? ((void)((*((ushort1 *)res)) = __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 4) ? ((void)((*((uint1 *)res)) = __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 8) ? ((void)((*((uint2 *)res)) = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((s == 16) ? ((void)((*((uint4 *)res)) = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap))) : ((void)0))))); 
# 2197
} 
#endif
# 2199 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 2200
__attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2201
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2207
::exit(___);}
#if 0
# 2201
{ 
# 2202
T tmp; 
# 2204
surfCubemapLayeredread(&tmp, surf, x, y, layerFace, (int)sizeof(T), mode); 
# 2206
return tmp; 
# 2207
} 
#endif
# 2209 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 2210
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(T *res, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2211
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2213
::exit(___);}
#if 0
# 2211
{ 
# 2212
(*res) = surfCubemapLayeredread< T> (surf, x, y, layerFace, mode); 
# 2213
} 
#endif
# 2216 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2216
__attribute((always_inline)) __attribute__((unused)) inline char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2217
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2219
::exit(___);}
#if 0
# 2217
{ 
# 2218
return (char)(__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x); 
# 2219
} 
#endif
# 2222 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2222
__attribute((always_inline)) __attribute__((unused)) inline signed char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2223
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2225
::exit(___);}
#if 0
# 2223
{ 
# 2224
return (signed char)(__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x); 
# 2225
} 
#endif
# 2228 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2228
__attribute((always_inline)) __attribute__((unused)) inline unsigned char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2229
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2231
::exit(___);}
#if 0
# 2229
{ 
# 2230
return __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x; 
# 2231
} 
#endif
# 2234 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2234
__attribute((always_inline)) __attribute__((unused)) inline char1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2235
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2237
::exit(___);}
#if 0
# 2235
{ 
# 2236
return make_char1((signed char)(__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x)); 
# 2237
} 
#endif
# 2240 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2240
__attribute((always_inline)) __attribute__((unused)) inline uchar1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2241
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2243
::exit(___);}
#if 0
# 2241
{ 
# 2242
return __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2243
} 
#endif
# 2246 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2246
__attribute((always_inline)) __attribute__((unused)) inline char2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2247
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2251
::exit(___);}
#if 0
# 2247
{ 
# 2248
uchar2 tmp = __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2250
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
# 2251
} 
#endif
# 2254 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2254
__attribute((always_inline)) __attribute__((unused)) inline uchar2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2255
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2257
::exit(___);}
#if 0
# 2255
{ 
# 2256
return __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2257
} 
#endif
# 2260 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2260
__attribute((always_inline)) __attribute__((unused)) inline char4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2261
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2265
::exit(___);}
#if 0
# 2261
{ 
# 2262
uchar4 tmp = __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2264
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
# 2265
} 
#endif
# 2268 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2268
__attribute((always_inline)) __attribute__((unused)) inline uchar4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2269
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2271
::exit(___);}
#if 0
# 2269
{ 
# 2270
return __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2271
} 
#endif
# 2274 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2274
__attribute((always_inline)) __attribute__((unused)) inline short surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2275
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2277
::exit(___);}
#if 0
# 2275
{ 
# 2276
return (short)(__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x); 
# 2277
} 
#endif
# 2280 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2280
__attribute((always_inline)) __attribute__((unused)) inline unsigned short surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2281
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2283
::exit(___);}
#if 0
# 2281
{ 
# 2282
return __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x; 
# 2283
} 
#endif
# 2286 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2286
__attribute((always_inline)) __attribute__((unused)) inline short1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2287
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2289
::exit(___);}
#if 0
# 2287
{ 
# 2288
return make_short1((signed short)(__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x)); 
# 2289
} 
#endif
# 2292 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2292
__attribute((always_inline)) __attribute__((unused)) inline ushort1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2293
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2295
::exit(___);}
#if 0
# 2293
{ 
# 2294
return __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2295
} 
#endif
# 2298 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2298
__attribute((always_inline)) __attribute__((unused)) inline short2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2299
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2303
::exit(___);}
#if 0
# 2299
{ 
# 2300
ushort2 tmp = __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2302
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
# 2303
} 
#endif
# 2306 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2306
__attribute((always_inline)) __attribute__((unused)) inline ushort2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2307
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2309
::exit(___);}
#if 0
# 2307
{ 
# 2308
return __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2309
} 
#endif
# 2312 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2312
__attribute((always_inline)) __attribute__((unused)) inline short4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2313
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2317
::exit(___);}
#if 0
# 2313
{ 
# 2314
ushort4 tmp = __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2316
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
# 2317
} 
#endif
# 2320 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2320
__attribute((always_inline)) __attribute__((unused)) inline ushort4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2321
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2323
::exit(___);}
#if 0
# 2321
{ 
# 2322
return __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2323
} 
#endif
# 2326 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2326
__attribute((always_inline)) __attribute__((unused)) inline int surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2327
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2329
::exit(___);}
#if 0
# 2327
{ 
# 2328
return (int)(__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x); 
# 2329
} 
#endif
# 2332 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2332
__attribute((always_inline)) __attribute__((unused)) inline unsigned surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2333
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2335
::exit(___);}
#if 0
# 2333
{ 
# 2334
return __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x; 
# 2335
} 
#endif
# 2338 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2338
__attribute((always_inline)) __attribute__((unused)) inline int1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2339
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2341
::exit(___);}
#if 0
# 2339
{ 
# 2340
return make_int1((signed int)(__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x)); 
# 2341
} 
#endif
# 2344 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2344
__attribute((always_inline)) __attribute__((unused)) inline uint1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2345
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2347
::exit(___);}
#if 0
# 2345
{ 
# 2346
return __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2347
} 
#endif
# 2350 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2350
__attribute((always_inline)) __attribute__((unused)) inline int2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2351
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2355
::exit(___);}
#if 0
# 2351
{ 
# 2352
uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2354
return make_int2((int)(tmp.x), (int)(tmp.y)); 
# 2355
} 
#endif
# 2358 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2358
__attribute((always_inline)) __attribute__((unused)) inline uint2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2359
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2361
::exit(___);}
#if 0
# 2359
{ 
# 2360
return __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2361
} 
#endif
# 2364 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2364
__attribute((always_inline)) __attribute__((unused)) inline int4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2365
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2369
::exit(___);}
#if 0
# 2365
{ 
# 2366
uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2368
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
# 2369
} 
#endif
# 2372 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2372
__attribute((always_inline)) __attribute__((unused)) inline uint4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2373
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2375
::exit(___);}
#if 0
# 2373
{ 
# 2374
return __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2375
} 
#endif
# 2378 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2378
__attribute((always_inline)) __attribute__((unused)) inline long long surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2379
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2381
::exit(___);}
#if 0
# 2379
{ 
# 2380
return (long long)(__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x); 
# 2381
} 
#endif
# 2384 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2384
__attribute((always_inline)) __attribute__((unused)) inline unsigned long long surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2385
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2387
::exit(___);}
#if 0
# 2385
{ 
# 2386
return __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x; 
# 2387
} 
#endif
# 2390 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2390
__attribute((always_inline)) __attribute__((unused)) inline longlong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2391
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2393
::exit(___);}
#if 0
# 2391
{ 
# 2392
return make_longlong1((long long)(__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x)); 
# 2393
} 
#endif
# 2396 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2396
__attribute((always_inline)) __attribute__((unused)) inline ulonglong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2397
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2399
::exit(___);}
#if 0
# 2397
{ 
# 2398
return __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2399
} 
#endif
# 2402 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2402
__attribute((always_inline)) __attribute__((unused)) inline longlong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2403
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2407
::exit(___);}
#if 0
# 2403
{ 
# 2404
ulonglong2 tmp = __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2406
return make_longlong2((long long)(tmp.x), (long long)(tmp.y)); 
# 2407
} 
#endif
# 2410 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200
__attribute((always_inline)) 
# 2410
__attribute((always_inline)) __attribute__((unused)) inline ulonglong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2411
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2413
::exit(___);}
#if 0
# 2411
{ 
# 2412
return __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2413
} 
#endif
# 2476 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 2476 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2477
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2479
::exit(___);}
#if 0
# 2477
{ 
# 2478
return __int_as_float((int)(__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x)); 
# 2479
} 
#endif
# 2482 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 2482 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2483
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2485
::exit(___);}
#if 0
# 2483
{ 
# 2484
return make_float1(__int_as_float((int)(__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x))); 
# 2485
} 
#endif
# 2488 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 2488 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2489
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2493
::exit(___);}
#if 0
# 2489
{ 
# 2490
uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2492
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
# 2493
} 
#endif
# 2496 "/usr/local/cuda/bin/..//include/surface_functions.h"
template<> 
# 2200 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) 
# 2496 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) inline float4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
# 2497
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2501
::exit(___);}
#if 0
# 2497
{ 
# 2498
uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 2500
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
# 2501
} 
#endif
# 2537 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 2538
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(T val, surface< void, 1>  surf, int x, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2539
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)s;(void)mode;
# 2557
::exit(___);}
#if 0
# 2539
{ 
# 2540
union { 
# 2541
T val; 
# 2542
uchar1 c1; 
# 2543
ushort1 s1; 
# 2544
uint1 u1; 
# 2545
uint2 u2; 
# 2546
uint4 u4; 
# 2547
} tmp; 
# 2549
(tmp.val) = val; 
# 2551
(s == 1) ? ((void)__surf1Dwritec1(tmp.c1, surf, x, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf1Dwrites1(tmp.s1, surf, x, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf1Dwriteu1(tmp.u1, surf, x, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf1Dwriteu2(tmp.u2, surf, x, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf1Dwriteu4(tmp.u4, surf, x, cudaBoundaryModeTrap)) : ((void)0))))); 
# 2557
} 
#endif
# 2559 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 2560
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(T val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2561
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2563
::exit(___);}
#if 0
# 2561
{ ; 
# 2562
surf1Dwrite(val, surf, x, (int)sizeof(T), mode); 
# 2563
} 
#endif
# 2566 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2567
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2569
::exit(___);}
#if 0
# 2567
{ 
# 2568
__surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap); 
# 2569
} 
#endif
# 2571 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(signed char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2572
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2574
::exit(___);}
#if 0
# 2572
{ 
# 2573
__surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap); 
# 2574
} 
#endif
# 2576 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2577
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2579
::exit(___);}
#if 0
# 2577
{ 
# 2578
__surf1Dwritec1(make_uchar1(val), surf, x, cudaBoundaryModeTrap); 
# 2579
} 
#endif
# 2581 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2582
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2584
::exit(___);}
#if 0
# 2582
{ 
# 2583
__surf1Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, cudaBoundaryModeTrap); 
# 2584
} 
#endif
# 2586 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2587
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2589
::exit(___);}
#if 0
# 2587
{ 
# 2588
__surf1Dwritec1(val, surf, x, cudaBoundaryModeTrap); 
# 2589
} 
#endif
# 2591 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2592
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2594
::exit(___);}
#if 0
# 2592
{ 
# 2593
__surf1Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, cudaBoundaryModeTrap); 
# 2594
} 
#endif
# 2596 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2597
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2599
::exit(___);}
#if 0
# 2597
{ 
# 2598
__surf1Dwritec2(val, surf, x, cudaBoundaryModeTrap); 
# 2599
} 
#endif
# 2601 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2602
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2604
::exit(___);}
#if 0
# 2602
{ 
# 2603
__surf1Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, cudaBoundaryModeTrap); 
# 2604
} 
#endif
# 2606 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2607
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2609
::exit(___);}
#if 0
# 2607
{ 
# 2608
__surf1Dwritec4(val, surf, x, cudaBoundaryModeTrap); 
# 2609
} 
#endif
# 2611 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2612
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2614
::exit(___);}
#if 0
# 2612
{ 
# 2613
__surf1Dwrites1(make_ushort1((unsigned short)val), surf, x, cudaBoundaryModeTrap); 
# 2614
} 
#endif
# 2616 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2617
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2619
::exit(___);}
#if 0
# 2617
{ 
# 2618
__surf1Dwrites1(make_ushort1(val), surf, x, cudaBoundaryModeTrap); 
# 2619
} 
#endif
# 2621 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2622
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2624
::exit(___);}
#if 0
# 2622
{ 
# 2623
__surf1Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, cudaBoundaryModeTrap); 
# 2624
} 
#endif
# 2626 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2627
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2629
::exit(___);}
#if 0
# 2627
{ 
# 2628
__surf1Dwrites1(val, surf, x, cudaBoundaryModeTrap); 
# 2629
} 
#endif
# 2631 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2632
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2634
::exit(___);}
#if 0
# 2632
{ 
# 2633
__surf1Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, cudaBoundaryModeTrap); 
# 2634
} 
#endif
# 2636 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2637
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2639
::exit(___);}
#if 0
# 2637
{ 
# 2638
__surf1Dwrites2(val, surf, x, cudaBoundaryModeTrap); 
# 2639
} 
#endif
# 2641 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2642
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2644
::exit(___);}
#if 0
# 2642
{ 
# 2643
__surf1Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, cudaBoundaryModeTrap); 
# 2644
} 
#endif
# 2646 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2647
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2649
::exit(___);}
#if 0
# 2647
{ 
# 2648
__surf1Dwrites4(val, surf, x, cudaBoundaryModeTrap); 
# 2649
} 
#endif
# 2651 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2652
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2654
::exit(___);}
#if 0
# 2652
{ 
# 2653
__surf1Dwriteu1(make_uint1((unsigned)val), surf, x, cudaBoundaryModeTrap); 
# 2654
} 
#endif
# 2656 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2657
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2659
::exit(___);}
#if 0
# 2657
{ 
# 2658
__surf1Dwriteu1(make_uint1(val), surf, x, cudaBoundaryModeTrap); 
# 2659
} 
#endif
# 2661 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2662
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2664
::exit(___);}
#if 0
# 2662
{ 
# 2663
__surf1Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, cudaBoundaryModeTrap); 
# 2664
} 
#endif
# 2666 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2667
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2669
::exit(___);}
#if 0
# 2667
{ 
# 2668
__surf1Dwriteu1(val, surf, x, cudaBoundaryModeTrap); 
# 2669
} 
#endif
# 2671 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2672
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2674
::exit(___);}
#if 0
# 2672
{ 
# 2673
__surf1Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, cudaBoundaryModeTrap); 
# 2674
} 
#endif
# 2676 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2677
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2679
::exit(___);}
#if 0
# 2677
{ 
# 2678
__surf1Dwriteu2(val, surf, x, cudaBoundaryModeTrap); 
# 2679
} 
#endif
# 2681 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2682
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2684
::exit(___);}
#if 0
# 2682
{ 
# 2683
__surf1Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, cudaBoundaryModeTrap); 
# 2684
} 
#endif
# 2686 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2687
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2689
::exit(___);}
#if 0
# 2687
{ 
# 2688
__surf1Dwriteu4(val, surf, x, cudaBoundaryModeTrap); 
# 2689
} 
#endif
# 2691 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(long long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2692
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2694
::exit(___);}
#if 0
# 2692
{ 
# 2693
__surf1Dwritel1(make_ulonglong1((unsigned long long)val), surf, x, cudaBoundaryModeTrap); 
# 2694
} 
#endif
# 2696 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned long long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2697
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2699
::exit(___);}
#if 0
# 2697
{ 
# 2698
__surf1Dwritel1(make_ulonglong1(val), surf, x, cudaBoundaryModeTrap); 
# 2699
} 
#endif
# 2701 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2702
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2704
::exit(___);}
#if 0
# 2702
{ 
# 2703
__surf1Dwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, cudaBoundaryModeTrap); 
# 2704
} 
#endif
# 2706 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2707
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2709
::exit(___);}
#if 0
# 2707
{ 
# 2708
__surf1Dwritel1(val, surf, x, cudaBoundaryModeTrap); 
# 2709
} 
#endif
# 2711 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2712
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2714
::exit(___);}
#if 0
# 2712
{ 
# 2713
__surf1Dwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, cudaBoundaryModeTrap); 
# 2714
} 
#endif
# 2716 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2717
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2719
::exit(___);}
#if 0
# 2717
{ 
# 2718
__surf1Dwritel2(val, surf, x, cudaBoundaryModeTrap); 
# 2719
} 
#endif
# 2765 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2766
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2768
::exit(___);}
#if 0
# 2766
{ 
# 2767
__surf1Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, cudaBoundaryModeTrap); 
# 2768
} 
#endif
# 2770 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2771
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2773
::exit(___);}
#if 0
# 2771
{ 
# 2772
__surf1Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, cudaBoundaryModeTrap); 
# 2773
} 
#endif
# 2775 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2776
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2778
::exit(___);}
#if 0
# 2776
{ 
# 2777
__surf1Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, cudaBoundaryModeTrap); 
# 2778
} 
#endif
# 2780 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2781
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 2783
::exit(___);}
#if 0
# 2781
{ 
# 2782
__surf1Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, cudaBoundaryModeTrap); 
# 2783
} 
#endif
# 2819 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 2820
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(T val, surface< void, 2>  surf, int x, int y, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2821
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)s;(void)mode;
# 2839
::exit(___);}
#if 0
# 2821
{ 
# 2822
union { 
# 2823
T val; 
# 2824
uchar1 c1; 
# 2825
ushort1 s1; 
# 2826
uint1 u1; 
# 2827
uint2 u2; 
# 2828
uint4 u4; 
# 2829
} tmp; 
# 2831
(tmp.val) = val; 
# 2833
(s == 1) ? ((void)__surf2Dwritec1(tmp.c1, surf, x, y, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf2Dwrites1(tmp.s1, surf, x, y, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf2Dwriteu1(tmp.u1, surf, x, y, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf2Dwriteu2(tmp.u2, surf, x, y, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf2Dwriteu4(tmp.u4, surf, x, y, cudaBoundaryModeTrap)) : ((void)0))))); 
# 2839
} 
#endif
# 2841 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 2842
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(T val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2843
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2845
::exit(___);}
#if 0
# 2843
{ ; 
# 2844
surf2Dwrite(val, surf, x, y, (int)sizeof(T), mode); 
# 2845
} 
#endif
# 2848 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2849
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2851
::exit(___);}
#if 0
# 2849
{ 
# 2850
__surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap); 
# 2851
} 
#endif
# 2853 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(signed char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2854
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2856
::exit(___);}
#if 0
# 2854
{ 
# 2855
__surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap); 
# 2856
} 
#endif
# 2858 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2859
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2861
::exit(___);}
#if 0
# 2859
{ 
# 2860
__surf2Dwritec1(make_uchar1(val), surf, x, y, cudaBoundaryModeTrap); 
# 2861
} 
#endif
# 2863 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2864
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2866
::exit(___);}
#if 0
# 2864
{ 
# 2865
__surf2Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
# 2866
} 
#endif
# 2868 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2869
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2871
::exit(___);}
#if 0
# 2869
{ 
# 2870
__surf2Dwritec1(val, surf, x, y, cudaBoundaryModeTrap); 
# 2871
} 
#endif
# 2873 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2874
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2876
::exit(___);}
#if 0
# 2874
{ 
# 2875
__surf2Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
# 2876
} 
#endif
# 2878 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2879
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2881
::exit(___);}
#if 0
# 2879
{ 
# 2880
__surf2Dwritec2(val, surf, x, y, cudaBoundaryModeTrap); 
# 2881
} 
#endif
# 2883 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2884
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2886
::exit(___);}
#if 0
# 2884
{ 
# 2885
__surf2Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
# 2886
} 
#endif
# 2888 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2889
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2891
::exit(___);}
#if 0
# 2889
{ 
# 2890
__surf2Dwritec4(val, surf, x, y, cudaBoundaryModeTrap); 
# 2891
} 
#endif
# 2893 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2894
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2896
::exit(___);}
#if 0
# 2894
{ 
# 2895
__surf2Dwrites1(make_ushort1((unsigned short)val), surf, x, y, cudaBoundaryModeTrap); 
# 2896
} 
#endif
# 2898 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2899
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2901
::exit(___);}
#if 0
# 2899
{ 
# 2900
__surf2Dwrites1(make_ushort1(val), surf, x, y, cudaBoundaryModeTrap); 
# 2901
} 
#endif
# 2903 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2904
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2906
::exit(___);}
#if 0
# 2904
{ 
# 2905
__surf2Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
# 2906
} 
#endif
# 2908 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2909
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2911
::exit(___);}
#if 0
# 2909
{ 
# 2910
__surf2Dwrites1(val, surf, x, y, cudaBoundaryModeTrap); 
# 2911
} 
#endif
# 2913 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2914
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2916
::exit(___);}
#if 0
# 2914
{ 
# 2915
__surf2Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
# 2916
} 
#endif
# 2918 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2919
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2921
::exit(___);}
#if 0
# 2919
{ 
# 2920
__surf2Dwrites2(val, surf, x, y, cudaBoundaryModeTrap); 
# 2921
} 
#endif
# 2923 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2924
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2926
::exit(___);}
#if 0
# 2924
{ 
# 2925
__surf2Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
# 2926
} 
#endif
# 2928 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2929
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2931
::exit(___);}
#if 0
# 2929
{ 
# 2930
__surf2Dwrites4(val, surf, x, y, cudaBoundaryModeTrap); 
# 2931
} 
#endif
# 2933 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2934
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2936
::exit(___);}
#if 0
# 2934
{ 
# 2935
__surf2Dwriteu1(make_uint1((unsigned)val), surf, x, y, cudaBoundaryModeTrap); 
# 2936
} 
#endif
# 2938 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2939
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2941
::exit(___);}
#if 0
# 2939
{ 
# 2940
__surf2Dwriteu1(make_uint1(val), surf, x, y, cudaBoundaryModeTrap); 
# 2941
} 
#endif
# 2943 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2944
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2946
::exit(___);}
#if 0
# 2944
{ 
# 2945
__surf2Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
# 2946
} 
#endif
# 2948 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2949
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2951
::exit(___);}
#if 0
# 2949
{ 
# 2950
__surf2Dwriteu1(val, surf, x, y, cudaBoundaryModeTrap); 
# 2951
} 
#endif
# 2953 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2954
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2956
::exit(___);}
#if 0
# 2954
{ 
# 2955
__surf2Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
# 2956
} 
#endif
# 2958 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2959
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2961
::exit(___);}
#if 0
# 2959
{ 
# 2960
__surf2Dwriteu2(val, surf, x, y, cudaBoundaryModeTrap); 
# 2961
} 
#endif
# 2963 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2964
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2966
::exit(___);}
#if 0
# 2964
{ 
# 2965
__surf2Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
# 2966
} 
#endif
# 2968 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2969
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2971
::exit(___);}
#if 0
# 2969
{ 
# 2970
__surf2Dwriteu4(val, surf, x, y, cudaBoundaryModeTrap); 
# 2971
} 
#endif
# 2973 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(long long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2974
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2976
::exit(___);}
#if 0
# 2974
{ 
# 2975
__surf2Dwritel1(make_ulonglong1((unsigned long long)val), surf, x, y, cudaBoundaryModeTrap); 
# 2976
} 
#endif
# 2978 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned long long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2979
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2981
::exit(___);}
#if 0
# 2979
{ 
# 2980
__surf2Dwritel1(make_ulonglong1(val), surf, x, y, cudaBoundaryModeTrap); 
# 2981
} 
#endif
# 2983 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2984
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2986
::exit(___);}
#if 0
# 2984
{ 
# 2985
__surf2Dwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
# 2986
} 
#endif
# 2988 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2989
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2991
::exit(___);}
#if 0
# 2989
{ 
# 2990
__surf2Dwritel1(val, surf, x, y, cudaBoundaryModeTrap); 
# 2991
} 
#endif
# 2993 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2994
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 2996
::exit(___);}
#if 0
# 2994
{ 
# 2995
__surf2Dwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
# 2996
} 
#endif
# 2998 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2999
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 3001
::exit(___);}
#if 0
# 2999
{ 
# 3000
__surf2Dwritel2(val, surf, x, y, cudaBoundaryModeTrap); 
# 3001
} 
#endif
# 3047 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3048
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 3050
::exit(___);}
#if 0
# 3048
{ 
# 3049
__surf2Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, cudaBoundaryModeTrap); 
# 3050
} 
#endif
# 3052 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3053
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 3055
::exit(___);}
#if 0
# 3053
{ 
# 3054
__surf2Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, cudaBoundaryModeTrap); 
# 3055
} 
#endif
# 3057 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3058
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 3060
::exit(___);}
#if 0
# 3058
{ 
# 3059
__surf2Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, cudaBoundaryModeTrap); 
# 3060
} 
#endif
# 3062 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3063
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 3065
::exit(___);}
#if 0
# 3063
{ 
# 3064
__surf2Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, cudaBoundaryModeTrap); 
# 3065
} 
#endif
# 3101 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 3102
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(T val, surface< void, 3>  surf, int x, int y, int z, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3103
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
# 3121
::exit(___);}
#if 0
# 3103
{ 
# 3104
union { 
# 3105
T val; 
# 3106
uchar1 c1; 
# 3107
ushort1 s1; 
# 3108
uint1 u1; 
# 3109
uint2 u2; 
# 3110
uint4 u4; 
# 3111
} tmp; 
# 3113
(tmp.val) = val; 
# 3115
(s == 1) ? ((void)__surf3Dwritec1(tmp.c1, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf3Dwrites1(tmp.s1, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf3Dwriteu1(tmp.u1, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf3Dwriteu2(tmp.u2, surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf3Dwriteu4(tmp.u4, surf, x, y, z, cudaBoundaryModeTrap)) : ((void)0))))); 
# 3121
} 
#endif
# 3123 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 3124
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(T val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3125
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3127
::exit(___);}
#if 0
# 3125
{ ; 
# 3126
surf3Dwrite(val, surf, x, y, z, (int)sizeof(T), mode); 
# 3127
} 
#endif
# 3130 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3131
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3133
::exit(___);}
#if 0
# 3131
{ 
# 3132
__surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap); 
# 3133
} 
#endif
# 3135 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(signed char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3136
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3138
::exit(___);}
#if 0
# 3136
{ 
# 3137
__surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap); 
# 3138
} 
#endif
# 3140 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3141
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3143
::exit(___);}
#if 0
# 3141
{ 
# 3142
__surf3Dwritec1(make_uchar1(val), surf, x, y, z, cudaBoundaryModeTrap); 
# 3143
} 
#endif
# 3145 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3146
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3148
::exit(___);}
#if 0
# 3146
{ 
# 3147
__surf3Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3148
} 
#endif
# 3150 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3151
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3153
::exit(___);}
#if 0
# 3151
{ 
# 3152
__surf3Dwritec1(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 3153
} 
#endif
# 3155 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3156
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3158
::exit(___);}
#if 0
# 3156
{ 
# 3157
__surf3Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3158
} 
#endif
# 3160 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3161
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3163
::exit(___);}
#if 0
# 3161
{ 
# 3162
__surf3Dwritec2(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 3163
} 
#endif
# 3165 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3166
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3168
::exit(___);}
#if 0
# 3166
{ 
# 3167
__surf3Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3168
} 
#endif
# 3170 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3171
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3173
::exit(___);}
#if 0
# 3171
{ 
# 3172
__surf3Dwritec4(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 3173
} 
#endif
# 3175 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3176
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3178
::exit(___);}
#if 0
# 3176
{ 
# 3177
__surf3Dwrites1(make_ushort1((unsigned short)val), surf, x, y, z, cudaBoundaryModeTrap); 
# 3178
} 
#endif
# 3180 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3181
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3183
::exit(___);}
#if 0
# 3181
{ 
# 3182
__surf3Dwrites1(make_ushort1(val), surf, x, y, z, cudaBoundaryModeTrap); 
# 3183
} 
#endif
# 3185 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3186
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3188
::exit(___);}
#if 0
# 3186
{ 
# 3187
__surf3Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3188
} 
#endif
# 3190 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3191
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3193
::exit(___);}
#if 0
# 3191
{ 
# 3192
__surf3Dwrites1(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 3193
} 
#endif
# 3195 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3196
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3198
::exit(___);}
#if 0
# 3196
{ 
# 3197
__surf3Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3198
} 
#endif
# 3200 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3201
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3203
::exit(___);}
#if 0
# 3201
{ 
# 3202
__surf3Dwrites2(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 3203
} 
#endif
# 3205 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3206
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3208
::exit(___);}
#if 0
# 3206
{ 
# 3207
__surf3Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3208
} 
#endif
# 3210 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3211
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3213
::exit(___);}
#if 0
# 3211
{ 
# 3212
__surf3Dwrites4(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 3213
} 
#endif
# 3215 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3216
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3218
::exit(___);}
#if 0
# 3216
{ 
# 3217
__surf3Dwriteu1(make_uint1((unsigned)val), surf, x, y, z, cudaBoundaryModeTrap); 
# 3218
} 
#endif
# 3220 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3221
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3223
::exit(___);}
#if 0
# 3221
{ 
# 3222
__surf3Dwriteu1(make_uint1(val), surf, x, y, z, cudaBoundaryModeTrap); 
# 3223
} 
#endif
# 3225 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3226
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3228
::exit(___);}
#if 0
# 3226
{ 
# 3227
__surf3Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3228
} 
#endif
# 3230 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3231
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3233
::exit(___);}
#if 0
# 3231
{ 
# 3232
__surf3Dwriteu1(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 3233
} 
#endif
# 3235 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3236
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3238
::exit(___);}
#if 0
# 3236
{ 
# 3237
__surf3Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3238
} 
#endif
# 3240 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3241
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3243
::exit(___);}
#if 0
# 3241
{ 
# 3242
__surf3Dwriteu2(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 3243
} 
#endif
# 3245 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3246
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3248
::exit(___);}
#if 0
# 3246
{ 
# 3247
__surf3Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3248
} 
#endif
# 3250 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3251
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3253
::exit(___);}
#if 0
# 3251
{ 
# 3252
__surf3Dwriteu4(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 3253
} 
#endif
# 3255 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(long long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3256
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3258
::exit(___);}
#if 0
# 3256
{ 
# 3257
__surf3Dwritel1(make_ulonglong1((unsigned long long)val), surf, x, y, z, cudaBoundaryModeTrap); 
# 3258
} 
#endif
# 3260 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned long long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3261
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3263
::exit(___);}
#if 0
# 3261
{ 
# 3262
__surf3Dwritel1(make_ulonglong1(val), surf, x, y, z, cudaBoundaryModeTrap); 
# 3263
} 
#endif
# 3265 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3266
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3268
::exit(___);}
#if 0
# 3266
{ 
# 3267
__surf3Dwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3268
} 
#endif
# 3270 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3271
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3273
::exit(___);}
#if 0
# 3271
{ 
# 3272
__surf3Dwritel1(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 3273
} 
#endif
# 3275 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3276
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3278
::exit(___);}
#if 0
# 3276
{ 
# 3277
__surf3Dwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3278
} 
#endif
# 3280 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3281
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3283
::exit(___);}
#if 0
# 3281
{ 
# 3282
__surf3Dwritel2(val, surf, x, y, z, cudaBoundaryModeTrap); 
# 3283
} 
#endif
# 3329 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3330
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3332
::exit(___);}
#if 0
# 3330
{ 
# 3331
__surf3Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3332
} 
#endif
# 3334 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3335
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3337
::exit(___);}
#if 0
# 3335
{ 
# 3336
__surf3Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3337
} 
#endif
# 3339 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3340
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3342
::exit(___);}
#if 0
# 3340
{ 
# 3341
__surf3Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, z, cudaBoundaryModeTrap); 
# 3342
} 
#endif
# 3344 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3345
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 3347
::exit(___);}
#if 0
# 3345
{ 
# 3346
__surf3Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
# 3347
} 
#endif
# 3383 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 3384
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(T val, surface< void, 241>  surf, int x, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3385
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
# 3403
::exit(___);}
#if 0
# 3385
{ 
# 3386
union { 
# 3387
T val; 
# 3388
uchar1 c1; 
# 3389
ushort1 s1; 
# 3390
uint1 u1; 
# 3391
uint2 u2; 
# 3392
uint4 u4; 
# 3393
} tmp; 
# 3395
(tmp.val) = val; 
# 3397
(s == 1) ? ((void)__surf1DLayeredwritec1(tmp.c1, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf1DLayeredwrites1(tmp.s1, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf1DLayeredwriteu1(tmp.u1, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf1DLayeredwriteu2(tmp.u2, surf, x, layer, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf1DLayeredwriteu4(tmp.u4, surf, x, layer, cudaBoundaryModeTrap)) : ((void)0))))); 
# 3403
} 
#endif
# 3405 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 3406
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(T val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3407
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3409
::exit(___);}
#if 0
# 3407
{ ; 
# 3408
surf1DLayeredwrite(val, surf, x, layer, (int)sizeof(T), mode); 
# 3409
} 
#endif
# 3412 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3413
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3415
::exit(___);}
#if 0
# 3413
{ 
# 3414
__surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap); 
# 3415
} 
#endif
# 3417 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(signed char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3418
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3420
::exit(___);}
#if 0
# 3418
{ 
# 3419
__surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap); 
# 3420
} 
#endif
# 3422 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3423
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3425
::exit(___);}
#if 0
# 3423
{ 
# 3424
__surf1DLayeredwritec1(make_uchar1(val), surf, x, layer, cudaBoundaryModeTrap); 
# 3425
} 
#endif
# 3427 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3428
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3430
::exit(___);}
#if 0
# 3428
{ 
# 3429
__surf1DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
# 3430
} 
#endif
# 3432 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3433
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3435
::exit(___);}
#if 0
# 3433
{ 
# 3434
__surf1DLayeredwritec1(val, surf, x, layer, cudaBoundaryModeTrap); 
# 3435
} 
#endif
# 3437 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3438
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3440
::exit(___);}
#if 0
# 3438
{ 
# 3439
__surf1DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
# 3440
} 
#endif
# 3442 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3443
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3445
::exit(___);}
#if 0
# 3443
{ 
# 3444
__surf1DLayeredwritec2(val, surf, x, layer, cudaBoundaryModeTrap); 
# 3445
} 
#endif
# 3447 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3448
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3450
::exit(___);}
#if 0
# 3448
{ 
# 3449
__surf1DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
# 3450
} 
#endif
# 3452 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3453
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3455
::exit(___);}
#if 0
# 3453
{ 
# 3454
__surf1DLayeredwritec4(val, surf, x, layer, cudaBoundaryModeTrap); 
# 3455
} 
#endif
# 3457 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3458
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3460
::exit(___);}
#if 0
# 3458
{ 
# 3459
__surf1DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, layer, cudaBoundaryModeTrap); 
# 3460
} 
#endif
# 3462 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3463
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3465
::exit(___);}
#if 0
# 3463
{ 
# 3464
__surf1DLayeredwrites1(make_ushort1(val), surf, x, layer, cudaBoundaryModeTrap); 
# 3465
} 
#endif
# 3467 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3468
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3470
::exit(___);}
#if 0
# 3468
{ 
# 3469
__surf1DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
# 3470
} 
#endif
# 3472 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3473
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3475
::exit(___);}
#if 0
# 3473
{ 
# 3474
__surf1DLayeredwrites1(val, surf, x, layer, cudaBoundaryModeTrap); 
# 3475
} 
#endif
# 3477 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3478
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3480
::exit(___);}
#if 0
# 3478
{ 
# 3479
__surf1DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
# 3480
} 
#endif
# 3482 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3483
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3485
::exit(___);}
#if 0
# 3483
{ 
# 3484
__surf1DLayeredwrites2(val, surf, x, layer, cudaBoundaryModeTrap); 
# 3485
} 
#endif
# 3487 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3488
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3490
::exit(___);}
#if 0
# 3488
{ 
# 3489
__surf1DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
# 3490
} 
#endif
# 3492 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3493
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3495
::exit(___);}
#if 0
# 3493
{ 
# 3494
__surf1DLayeredwrites4(val, surf, x, layer, cudaBoundaryModeTrap); 
# 3495
} 
#endif
# 3497 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3498
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3500
::exit(___);}
#if 0
# 3498
{ 
# 3499
__surf1DLayeredwriteu1(make_uint1((unsigned)val), surf, x, layer, cudaBoundaryModeTrap); 
# 3500
} 
#endif
# 3502 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3503
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3505
::exit(___);}
#if 0
# 3503
{ 
# 3504
__surf1DLayeredwriteu1(make_uint1(val), surf, x, layer, cudaBoundaryModeTrap); 
# 3505
} 
#endif
# 3507 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3508
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3510
::exit(___);}
#if 0
# 3508
{ 
# 3509
__surf1DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
# 3510
} 
#endif
# 3512 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3513
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3515
::exit(___);}
#if 0
# 3513
{ 
# 3514
__surf1DLayeredwriteu1(val, surf, x, layer, cudaBoundaryModeTrap); 
# 3515
} 
#endif
# 3517 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3518
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3520
::exit(___);}
#if 0
# 3518
{ 
# 3519
__surf1DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
# 3520
} 
#endif
# 3522 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3523
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3525
::exit(___);}
#if 0
# 3523
{ 
# 3524
__surf1DLayeredwriteu2(val, surf, x, layer, cudaBoundaryModeTrap); 
# 3525
} 
#endif
# 3527 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3528
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3530
::exit(___);}
#if 0
# 3528
{ 
# 3529
__surf1DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
# 3530
} 
#endif
# 3532 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3533
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3535
::exit(___);}
#if 0
# 3533
{ 
# 3534
__surf1DLayeredwriteu4(val, surf, x, layer, cudaBoundaryModeTrap); 
# 3535
} 
#endif
# 3537 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(long long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3538
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3540
::exit(___);}
#if 0
# 3538
{ 
# 3539
__surf1DLayeredwritel1(make_ulonglong1((unsigned long long)val), surf, x, layer, cudaBoundaryModeTrap); 
# 3540
} 
#endif
# 3542 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned long long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3543
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3545
::exit(___);}
#if 0
# 3543
{ 
# 3544
__surf1DLayeredwritel1(make_ulonglong1(val), surf, x, layer, cudaBoundaryModeTrap); 
# 3545
} 
#endif
# 3547 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3548
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3550
::exit(___);}
#if 0
# 3548
{ 
# 3549
__surf1DLayeredwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
# 3550
} 
#endif
# 3552 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3553
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3555
::exit(___);}
#if 0
# 3553
{ 
# 3554
__surf1DLayeredwritel1(val, surf, x, layer, cudaBoundaryModeTrap); 
# 3555
} 
#endif
# 3557 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3558
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3560
::exit(___);}
#if 0
# 3558
{ 
# 3559
__surf1DLayeredwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
# 3560
} 
#endif
# 3562 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3563
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3565
::exit(___);}
#if 0
# 3563
{ 
# 3564
__surf1DLayeredwritel2(val, surf, x, layer, cudaBoundaryModeTrap); 
# 3565
} 
#endif
# 3611 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3612
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3614
::exit(___);}
#if 0
# 3612
{ 
# 3613
__surf1DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, layer, cudaBoundaryModeTrap); 
# 3614
} 
#endif
# 3616 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3617
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3619
::exit(___);}
#if 0
# 3617
{ 
# 3618
__surf1DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
# 3619
} 
#endif
# 3621 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3622
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3624
::exit(___);}
#if 0
# 3622
{ 
# 3623
__surf1DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, layer, cudaBoundaryModeTrap); 
# 3624
} 
#endif
# 3626 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3627
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 3629
::exit(___);}
#if 0
# 3627
{ 
# 3628
__surf1DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
# 3629
} 
#endif
# 3665 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 3666
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(T val, surface< void, 242>  surf, int x, int y, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3667
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
# 3685
::exit(___);}
#if 0
# 3667
{ 
# 3668
union { 
# 3669
T val; 
# 3670
uchar1 c1; 
# 3671
ushort1 s1; 
# 3672
uint1 u1; 
# 3673
uint2 u2; 
# 3674
uint4 u4; 
# 3675
} tmp; 
# 3677
(tmp.val) = val; 
# 3679
(s == 1) ? ((void)__surf2DLayeredwritec1(tmp.c1, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surf2DLayeredwrites1(tmp.s1, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surf2DLayeredwriteu1(tmp.u1, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surf2DLayeredwriteu2(tmp.u2, surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surf2DLayeredwriteu4(tmp.u4, surf, x, y, layer, cudaBoundaryModeTrap)) : ((void)0))))); 
# 3685
} 
#endif
# 3687 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 3688
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(T val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3689
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3691
::exit(___);}
#if 0
# 3689
{ ; 
# 3690
surf2DLayeredwrite(val, surf, x, y, layer, (int)sizeof(T), mode); 
# 3691
} 
#endif
# 3694 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3695
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3697
::exit(___);}
#if 0
# 3695
{ 
# 3696
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3697
} 
#endif
# 3699 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(signed char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3700
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3702
::exit(___);}
#if 0
# 3700
{ 
# 3701
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3702
} 
#endif
# 3704 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3705
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3707
::exit(___);}
#if 0
# 3705
{ 
# 3706
__surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3707
} 
#endif
# 3709 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3710
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3712
::exit(___);}
#if 0
# 3710
{ 
# 3711
__surf2DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3712
} 
#endif
# 3714 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3715
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3717
::exit(___);}
#if 0
# 3715
{ 
# 3716
__surf2DLayeredwritec1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 3717
} 
#endif
# 3719 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3720
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3722
::exit(___);}
#if 0
# 3720
{ 
# 3721
__surf2DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3722
} 
#endif
# 3724 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3725
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3727
::exit(___);}
#if 0
# 3725
{ 
# 3726
__surf2DLayeredwritec2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 3727
} 
#endif
# 3729 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3730
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3732
::exit(___);}
#if 0
# 3730
{ 
# 3731
__surf2DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3732
} 
#endif
# 3734 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3735
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3737
::exit(___);}
#if 0
# 3735
{ 
# 3736
__surf2DLayeredwritec4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 3737
} 
#endif
# 3739 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3740
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3742
::exit(___);}
#if 0
# 3740
{ 
# 3741
__surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3742
} 
#endif
# 3744 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3745
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3747
::exit(___);}
#if 0
# 3745
{ 
# 3746
__surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3747
} 
#endif
# 3749 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3750
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3752
::exit(___);}
#if 0
# 3750
{ 
# 3751
__surf2DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3752
} 
#endif
# 3754 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3755
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3757
::exit(___);}
#if 0
# 3755
{ 
# 3756
__surf2DLayeredwrites1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 3757
} 
#endif
# 3759 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3760
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3762
::exit(___);}
#if 0
# 3760
{ 
# 3761
__surf2DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3762
} 
#endif
# 3764 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3765
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3767
::exit(___);}
#if 0
# 3765
{ 
# 3766
__surf2DLayeredwrites2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 3767
} 
#endif
# 3769 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3770
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3772
::exit(___);}
#if 0
# 3770
{ 
# 3771
__surf2DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3772
} 
#endif
# 3774 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3775
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3777
::exit(___);}
#if 0
# 3775
{ 
# 3776
__surf2DLayeredwrites4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 3777
} 
#endif
# 3779 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3780
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3782
::exit(___);}
#if 0
# 3780
{ 
# 3781
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3782
} 
#endif
# 3784 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3785
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3787
::exit(___);}
#if 0
# 3785
{ 
# 3786
__surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3787
} 
#endif
# 3789 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3790
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3792
::exit(___);}
#if 0
# 3790
{ 
# 3791
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3792
} 
#endif
# 3794 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3795
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3797
::exit(___);}
#if 0
# 3795
{ 
# 3796
__surf2DLayeredwriteu1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 3797
} 
#endif
# 3799 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3800
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3802
::exit(___);}
#if 0
# 3800
{ 
# 3801
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3802
} 
#endif
# 3804 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3805
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3807
::exit(___);}
#if 0
# 3805
{ 
# 3806
__surf2DLayeredwriteu2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 3807
} 
#endif
# 3809 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3810
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3812
::exit(___);}
#if 0
# 3810
{ 
# 3811
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3812
} 
#endif
# 3814 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3815
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3817
::exit(___);}
#if 0
# 3815
{ 
# 3816
__surf2DLayeredwriteu4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 3817
} 
#endif
# 3819 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(long long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3820
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3822
::exit(___);}
#if 0
# 3820
{ 
# 3821
__surf2DLayeredwritel1(make_ulonglong1((unsigned long long)val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3822
} 
#endif
# 3824 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned long long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3825
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3827
::exit(___);}
#if 0
# 3825
{ 
# 3826
__surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3827
} 
#endif
# 3829 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3830
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3832
::exit(___);}
#if 0
# 3830
{ 
# 3831
__surf2DLayeredwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3832
} 
#endif
# 3834 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3835
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3837
::exit(___);}
#if 0
# 3835
{ 
# 3836
__surf2DLayeredwritel1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 3837
} 
#endif
# 3839 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3840
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3842
::exit(___);}
#if 0
# 3840
{ 
# 3841
__surf2DLayeredwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3842
} 
#endif
# 3844 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3845
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3847
::exit(___);}
#if 0
# 3845
{ 
# 3846
__surf2DLayeredwritel2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
# 3847
} 
#endif
# 3893 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3894
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3896
::exit(___);}
#if 0
# 3894
{ 
# 3895
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3896
} 
#endif
# 3898 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3899
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3901
::exit(___);}
#if 0
# 3899
{ 
# 3900
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3901
} 
#endif
# 3903 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3904
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3906
::exit(___);}
#if 0
# 3904
{ 
# 3905
__surf2DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3906
} 
#endif
# 3908 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3909
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 3911
::exit(___);}
#if 0
# 3909
{ 
# 3910
__surf2DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
# 3911
} 
#endif
# 3947 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 3948
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(T val, surface< void, 12>  surf, int x, int y, int face, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3949
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
# 3967
::exit(___);}
#if 0
# 3949
{ 
# 3950
union { 
# 3951
T val; 
# 3952
uchar1 c1; 
# 3953
ushort1 s1; 
# 3954
uint1 u1; 
# 3955
uint2 u2; 
# 3956
uint4 u4; 
# 3957
} tmp; 
# 3959
(tmp.val) = val; 
# 3961
(s == 1) ? ((void)__surfCubemapwritec1(tmp.c1, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surfCubemapwrites1(tmp.s1, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surfCubemapwriteu1(tmp.u1, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surfCubemapwriteu2(tmp.u2, surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surfCubemapwriteu4(tmp.u4, surf, x, y, face, cudaBoundaryModeTrap)) : ((void)0))))); 
# 3967
} 
#endif
# 3969 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 3970
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(T val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3971
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 3973
::exit(___);}
#if 0
# 3971
{ ; 
# 3972
surfCubemapwrite(val, surf, x, y, face, (int)sizeof(T), mode); 
# 3973
} 
#endif
# 3976 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3977
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 3979
::exit(___);}
#if 0
# 3977
{ 
# 3978
__surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap); 
# 3979
} 
#endif
# 3981 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(signed char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3982
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 3984
::exit(___);}
#if 0
# 3982
{ 
# 3983
__surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap); 
# 3984
} 
#endif
# 3986 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3987
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 3989
::exit(___);}
#if 0
# 3987
{ 
# 3988
__surfCubemapwritec1(make_uchar1(val), surf, x, y, face, cudaBoundaryModeTrap); 
# 3989
} 
#endif
# 3991 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3992
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 3994
::exit(___);}
#if 0
# 3992
{ 
# 3993
__surfCubemapwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
# 3994
} 
#endif
# 3996 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 3997
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 3999
::exit(___);}
#if 0
# 3997
{ 
# 3998
__surfCubemapwritec1(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 3999
} 
#endif
# 4001 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4002
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4004
::exit(___);}
#if 0
# 4002
{ 
# 4003
__surfCubemapwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4004
} 
#endif
# 4006 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4007
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4009
::exit(___);}
#if 0
# 4007
{ 
# 4008
__surfCubemapwritec2(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 4009
} 
#endif
# 4011 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4012
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4014
::exit(___);}
#if 0
# 4012
{ 
# 4013
__surfCubemapwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4014
} 
#endif
# 4016 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4017
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4019
::exit(___);}
#if 0
# 4017
{ 
# 4018
__surfCubemapwritec4(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 4019
} 
#endif
# 4021 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4022
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4024
::exit(___);}
#if 0
# 4022
{ 
# 4023
__surfCubemapwrites1(make_ushort1((unsigned short)val), surf, x, y, face, cudaBoundaryModeTrap); 
# 4024
} 
#endif
# 4026 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4027
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4029
::exit(___);}
#if 0
# 4027
{ 
# 4028
__surfCubemapwrites1(make_ushort1(val), surf, x, y, face, cudaBoundaryModeTrap); 
# 4029
} 
#endif
# 4031 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4032
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4034
::exit(___);}
#if 0
# 4032
{ 
# 4033
__surfCubemapwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4034
} 
#endif
# 4036 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4037
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4039
::exit(___);}
#if 0
# 4037
{ 
# 4038
__surfCubemapwrites1(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 4039
} 
#endif
# 4041 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4042
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4044
::exit(___);}
#if 0
# 4042
{ 
# 4043
__surfCubemapwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4044
} 
#endif
# 4046 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4047
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4049
::exit(___);}
#if 0
# 4047
{ 
# 4048
__surfCubemapwrites2(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 4049
} 
#endif
# 4051 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4052
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4054
::exit(___);}
#if 0
# 4052
{ 
# 4053
__surfCubemapwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4054
} 
#endif
# 4056 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4057
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4059
::exit(___);}
#if 0
# 4057
{ 
# 4058
__surfCubemapwrites4(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 4059
} 
#endif
# 4061 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4062
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4064
::exit(___);}
#if 0
# 4062
{ 
# 4063
__surfCubemapwriteu1(make_uint1((unsigned)val), surf, x, y, face, cudaBoundaryModeTrap); 
# 4064
} 
#endif
# 4066 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4067
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4069
::exit(___);}
#if 0
# 4067
{ 
# 4068
__surfCubemapwriteu1(make_uint1(val), surf, x, y, face, cudaBoundaryModeTrap); 
# 4069
} 
#endif
# 4071 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4072
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4074
::exit(___);}
#if 0
# 4072
{ 
# 4073
__surfCubemapwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4074
} 
#endif
# 4076 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4077
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4079
::exit(___);}
#if 0
# 4077
{ 
# 4078
__surfCubemapwriteu1(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 4079
} 
#endif
# 4081 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4082
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4084
::exit(___);}
#if 0
# 4082
{ 
# 4083
__surfCubemapwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4084
} 
#endif
# 4086 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4087
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4089
::exit(___);}
#if 0
# 4087
{ 
# 4088
__surfCubemapwriteu2(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 4089
} 
#endif
# 4091 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4092
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4094
::exit(___);}
#if 0
# 4092
{ 
# 4093
__surfCubemapwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4094
} 
#endif
# 4096 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4097
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4099
::exit(___);}
#if 0
# 4097
{ 
# 4098
__surfCubemapwriteu4(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 4099
} 
#endif
# 4101 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(long long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4102
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4104
::exit(___);}
#if 0
# 4102
{ 
# 4103
__surfCubemapwritel1(make_ulonglong1((unsigned long long)val), surf, x, y, face, cudaBoundaryModeTrap); 
# 4104
} 
#endif
# 4106 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned long long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4107
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4109
::exit(___);}
#if 0
# 4107
{ 
# 4108
__surfCubemapwritel1(make_ulonglong1(val), surf, x, y, face, cudaBoundaryModeTrap); 
# 4109
} 
#endif
# 4111 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4112
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4114
::exit(___);}
#if 0
# 4112
{ 
# 4113
__surfCubemapwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4114
} 
#endif
# 4116 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4117
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4119
::exit(___);}
#if 0
# 4117
{ 
# 4118
__surfCubemapwritel1(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 4119
} 
#endif
# 4121 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4122
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4124
::exit(___);}
#if 0
# 4122
{ 
# 4123
__surfCubemapwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4124
} 
#endif
# 4126 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4127
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4129
::exit(___);}
#if 0
# 4127
{ 
# 4128
__surfCubemapwritel2(val, surf, x, y, face, cudaBoundaryModeTrap); 
# 4129
} 
#endif
# 4175 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4176
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4178
::exit(___);}
#if 0
# 4176
{ 
# 4177
__surfCubemapwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4178
} 
#endif
# 4180 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4181
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4183
::exit(___);}
#if 0
# 4181
{ 
# 4182
__surfCubemapwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4183
} 
#endif
# 4185 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4186
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4188
::exit(___);}
#if 0
# 4186
{ 
# 4187
__surfCubemapwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, face, cudaBoundaryModeTrap); 
# 4188
} 
#endif
# 4190 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4191
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 4193
::exit(___);}
#if 0
# 4191
{ 
# 4192
__surfCubemapwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
# 4193
} 
#endif
# 4229 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 4230
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(T val, surface< void, 252>  surf, int x, int y, int layerFace, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4231
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
# 4249
::exit(___);}
#if 0
# 4231
{ 
# 4232
union { 
# 4233
T val; 
# 4234
uchar1 c1; 
# 4235
ushort1 s1; 
# 4236
uint1 u1; 
# 4237
uint2 u2; 
# 4238
uint4 u4; 
# 4239
} tmp; 
# 4241
(tmp.val) = val; 
# 4243
(s == 1) ? ((void)__surfCubemapLayeredwritec1(tmp.c1, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 2) ? ((void)__surfCubemapLayeredwrites1(tmp.s1, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 4) ? ((void)__surfCubemapLayeredwriteu1(tmp.u1, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 8) ? ((void)__surfCubemapLayeredwriteu2(tmp.u2, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 16) ? ((void)__surfCubemapLayeredwriteu4(tmp.u4, surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((void)0))))); 
# 4249
} 
#endif
# 4251 "/usr/local/cuda/bin/..//include/surface_functions.h"
template< class T> 
# 4252
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(T val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4253
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4255
::exit(___);}
#if 0
# 4253
{ ; 
# 4254
surfCubemapLayeredwrite(val, surf, x, y, layerFace, (int)sizeof(T), mode); 
# 4255
} 
#endif
# 4258 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4259
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4261
::exit(___);}
#if 0
# 4259
{ 
# 4260
__surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4261
} 
#endif
# 4263 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(signed char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4264
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4266
::exit(___);}
#if 0
# 4264
{ 
# 4265
__surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4266
} 
#endif
# 4268 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4269
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4271
::exit(___);}
#if 0
# 4269
{ 
# 4270
__surfCubemapLayeredwritec1(make_uchar1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4271
} 
#endif
# 4273 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4274
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4276
::exit(___);}
#if 0
# 4274
{ 
# 4275
__surfCubemapLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4276
} 
#endif
# 4278 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4279
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4281
::exit(___);}
#if 0
# 4279
{ 
# 4280
__surfCubemapLayeredwritec1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4281
} 
#endif
# 4283 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4284
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4286
::exit(___);}
#if 0
# 4284
{ 
# 4285
__surfCubemapLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4286
} 
#endif
# 4288 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4289
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4291
::exit(___);}
#if 0
# 4289
{ 
# 4290
__surfCubemapLayeredwritec2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4291
} 
#endif
# 4293 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4294
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4296
::exit(___);}
#if 0
# 4294
{ 
# 4295
__surfCubemapLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4296
} 
#endif
# 4298 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4299
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4301
::exit(___);}
#if 0
# 4299
{ 
# 4300
__surfCubemapLayeredwritec4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4301
} 
#endif
# 4303 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4304
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4306
::exit(___);}
#if 0
# 4304
{ 
# 4305
__surfCubemapLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4306
} 
#endif
# 4308 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4309
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4311
::exit(___);}
#if 0
# 4309
{ 
# 4310
__surfCubemapLayeredwrites1(make_ushort1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4311
} 
#endif
# 4313 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4314
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4316
::exit(___);}
#if 0
# 4314
{ 
# 4315
__surfCubemapLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4316
} 
#endif
# 4318 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4319
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4321
::exit(___);}
#if 0
# 4319
{ 
# 4320
__surfCubemapLayeredwrites1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4321
} 
#endif
# 4323 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4324
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4326
::exit(___);}
#if 0
# 4324
{ 
# 4325
__surfCubemapLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4326
} 
#endif
# 4328 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4329
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4331
::exit(___);}
#if 0
# 4329
{ 
# 4330
__surfCubemapLayeredwrites2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4331
} 
#endif
# 4333 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4334
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4336
::exit(___);}
#if 0
# 4334
{ 
# 4335
__surfCubemapLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4336
} 
#endif
# 4338 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4339
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4341
::exit(___);}
#if 0
# 4339
{ 
# 4340
__surfCubemapLayeredwrites4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4341
} 
#endif
# 4343 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4344
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4346
::exit(___);}
#if 0
# 4344
{ 
# 4345
__surfCubemapLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4346
} 
#endif
# 4348 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4349
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4351
::exit(___);}
#if 0
# 4349
{ 
# 4350
__surfCubemapLayeredwriteu1(make_uint1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4351
} 
#endif
# 4353 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4354
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4356
::exit(___);}
#if 0
# 4354
{ 
# 4355
__surfCubemapLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4356
} 
#endif
# 4358 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4359
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4361
::exit(___);}
#if 0
# 4359
{ 
# 4360
__surfCubemapLayeredwriteu1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4361
} 
#endif
# 4363 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4364
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4366
::exit(___);}
#if 0
# 4364
{ 
# 4365
__surfCubemapLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4366
} 
#endif
# 4368 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4369
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4371
::exit(___);}
#if 0
# 4369
{ 
# 4370
__surfCubemapLayeredwriteu2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4371
} 
#endif
# 4373 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4374
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4376
::exit(___);}
#if 0
# 4374
{ 
# 4375
__surfCubemapLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4376
} 
#endif
# 4378 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4379
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4381
::exit(___);}
#if 0
# 4379
{ 
# 4380
__surfCubemapLayeredwriteu4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4381
} 
#endif
# 4383 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(long long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4384
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4386
::exit(___);}
#if 0
# 4384
{ 
# 4385
__surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4386
} 
#endif
# 4388 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned long long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4389
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4391
::exit(___);}
#if 0
# 4389
{ 
# 4390
__surfCubemapLayeredwritel1(make_ulonglong1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4391
} 
#endif
# 4393 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4394
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4396
::exit(___);}
#if 0
# 4394
{ 
# 4395
__surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4396
} 
#endif
# 4398 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4399
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4401
::exit(___);}
#if 0
# 4399
{ 
# 4400
__surfCubemapLayeredwritel1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4401
} 
#endif
# 4403 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4404
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4406
::exit(___);}
#if 0
# 4404
{ 
# 4405
__surfCubemapLayeredwritel2(make_ulonglong2((unsigned long long)(val.x), (unsigned long long)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4406
} 
#endif
# 4408 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4409
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4411
::exit(___);}
#if 0
# 4409
{ 
# 4410
__surfCubemapLayeredwritel2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4411
} 
#endif
# 4457 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4458
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4460
::exit(___);}
#if 0
# 4458
{ 
# 4459
__surfCubemapLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4460
} 
#endif
# 4462 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4463
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4465
::exit(___);}
#if 0
# 4463
{ 
# 4464
__surfCubemapLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4465
} 
#endif
# 4467 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4468
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4470
::exit(___);}
#if 0
# 4468
{ 
# 4469
__surfCubemapLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), __float_as_int((unsigned)(val.y))), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4470
} 
#endif
# 4472 "/usr/local/cuda/bin/..//include/surface_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 4473
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 4475
::exit(___);}
#if 0
# 4473
{ 
# 4474
__surfCubemapLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
# 4475
} 
#endif
# 96 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex1Dfetch(texture< char, 1, cudaReadModeElementType>  t, int x) 
# 97
{int volatile ___ = 1;(void)t;(void)x;
# 105
::exit(___);}
#if 0
# 97
{ 
# 101
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 104
return (char)(v.x); 
# 105
} 
#endif
# 107 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1Dfetch(texture< signed char, 1, cudaReadModeElementType>  t, int x) 
# 108
{int volatile ___ = 1;(void)t;(void)x;
# 112
::exit(___);}
#if 0
# 108
{ 
# 109
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 111
return (signed char)(v.x); 
# 112
} 
#endif
# 114 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1Dfetch(texture< unsigned char, 1, cudaReadModeElementType>  t, int x) 
# 115
{int volatile ___ = 1;(void)t;(void)x;
# 119
::exit(___);}
#if 0
# 115
{ 
# 116
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 118
return (unsigned char)(v.x); 
# 119
} 
#endif
# 121 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1Dfetch(texture< char1, 1, cudaReadModeElementType>  t, int x) 
# 122
{int volatile ___ = 1;(void)t;(void)x;
# 126
::exit(___);}
#if 0
# 122
{ 
# 123
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 125
return make_char1(v.x); 
# 126
} 
#endif
# 128 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1Dfetch(texture< uchar1, 1, cudaReadModeElementType>  t, int x) 
# 129
{int volatile ___ = 1;(void)t;(void)x;
# 133
::exit(___);}
#if 0
# 129
{ 
# 130
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 132
return make_uchar1(v.x); 
# 133
} 
#endif
# 135 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1Dfetch(texture< char2, 1, cudaReadModeElementType>  t, int x) 
# 136
{int volatile ___ = 1;(void)t;(void)x;
# 140
::exit(___);}
#if 0
# 136
{ 
# 137
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 139
return make_char2(v.x, v.y); 
# 140
} 
#endif
# 142 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1Dfetch(texture< uchar2, 1, cudaReadModeElementType>  t, int x) 
# 143
{int volatile ___ = 1;(void)t;(void)x;
# 147
::exit(___);}
#if 0
# 143
{ 
# 144
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 146
return make_uchar2(v.x, v.y); 
# 147
} 
#endif
# 149 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1Dfetch(texture< char4, 1, cudaReadModeElementType>  t, int x) 
# 150
{int volatile ___ = 1;(void)t;(void)x;
# 154
::exit(___);}
#if 0
# 150
{ 
# 151
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 153
return make_char4(v.x, v.y, v.z, v.w); 
# 154
} 
#endif
# 156 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1Dfetch(texture< uchar4, 1, cudaReadModeElementType>  t, int x) 
# 157
{int volatile ___ = 1;(void)t;(void)x;
# 161
::exit(___);}
#if 0
# 157
{ 
# 158
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 160
return make_uchar4(v.x, v.y, v.z, v.w); 
# 161
} 
#endif
# 169 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex1Dfetch(texture< short, 1, cudaReadModeElementType>  t, int x) 
# 170
{int volatile ___ = 1;(void)t;(void)x;
# 174
::exit(___);}
#if 0
# 170
{ 
# 171
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 173
return (short)(v.x); 
# 174
} 
#endif
# 176 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1Dfetch(texture< unsigned short, 1, cudaReadModeElementType>  t, int x) 
# 177
{int volatile ___ = 1;(void)t;(void)x;
# 181
::exit(___);}
#if 0
# 177
{ 
# 178
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 180
return (unsigned short)(v.x); 
# 181
} 
#endif
# 183 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1Dfetch(texture< short1, 1, cudaReadModeElementType>  t, int x) 
# 184
{int volatile ___ = 1;(void)t;(void)x;
# 188
::exit(___);}
#if 0
# 184
{ 
# 185
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 187
return make_short1(v.x); 
# 188
} 
#endif
# 190 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1Dfetch(texture< ushort1, 1, cudaReadModeElementType>  t, int x) 
# 191
{int volatile ___ = 1;(void)t;(void)x;
# 195
::exit(___);}
#if 0
# 191
{ 
# 192
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 194
return make_ushort1(v.x); 
# 195
} 
#endif
# 197 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1Dfetch(texture< short2, 1, cudaReadModeElementType>  t, int x) 
# 198
{int volatile ___ = 1;(void)t;(void)x;
# 202
::exit(___);}
#if 0
# 198
{ 
# 199
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 201
return make_short2(v.x, v.y); 
# 202
} 
#endif
# 204 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1Dfetch(texture< ushort2, 1, cudaReadModeElementType>  t, int x) 
# 205
{int volatile ___ = 1;(void)t;(void)x;
# 209
::exit(___);}
#if 0
# 205
{ 
# 206
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 208
return make_ushort2(v.x, v.y); 
# 209
} 
#endif
# 211 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1Dfetch(texture< short4, 1, cudaReadModeElementType>  t, int x) 
# 212
{int volatile ___ = 1;(void)t;(void)x;
# 216
::exit(___);}
#if 0
# 212
{ 
# 213
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 215
return make_short4(v.x, v.y, v.z, v.w); 
# 216
} 
#endif
# 218 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1Dfetch(texture< ushort4, 1, cudaReadModeElementType>  t, int x) 
# 219
{int volatile ___ = 1;(void)t;(void)x;
# 223
::exit(___);}
#if 0
# 219
{ 
# 220
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 222
return make_ushort4(v.x, v.y, v.z, v.w); 
# 223
} 
#endif
# 231 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex1Dfetch(texture< int, 1, cudaReadModeElementType>  t, int x) 
# 232
{int volatile ___ = 1;(void)t;(void)x;
# 236
::exit(___);}
#if 0
# 232
{ 
# 233
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 235
return (int)(v.x); 
# 236
} 
#endif
# 238 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1Dfetch(texture< unsigned, 1, cudaReadModeElementType>  t, int x) 
# 239
{int volatile ___ = 1;(void)t;(void)x;
# 243
::exit(___);}
#if 0
# 239
{ 
# 240
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 242
return (unsigned)(v.x); 
# 243
} 
#endif
# 245 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1Dfetch(texture< int1, 1, cudaReadModeElementType>  t, int x) 
# 246
{int volatile ___ = 1;(void)t;(void)x;
# 250
::exit(___);}
#if 0
# 246
{ 
# 247
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 249
return make_int1(v.x); 
# 250
} 
#endif
# 252 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1Dfetch(texture< uint1, 1, cudaReadModeElementType>  t, int x) 
# 253
{int volatile ___ = 1;(void)t;(void)x;
# 257
::exit(___);}
#if 0
# 253
{ 
# 254
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 256
return make_uint1(v.x); 
# 257
} 
#endif
# 259 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1Dfetch(texture< int2, 1, cudaReadModeElementType>  t, int x) 
# 260
{int volatile ___ = 1;(void)t;(void)x;
# 264
::exit(___);}
#if 0
# 260
{ 
# 261
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 263
return make_int2(v.x, v.y); 
# 264
} 
#endif
# 266 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1Dfetch(texture< uint2, 1, cudaReadModeElementType>  t, int x) 
# 267
{int volatile ___ = 1;(void)t;(void)x;
# 271
::exit(___);}
#if 0
# 267
{ 
# 268
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 270
return make_uint2(v.x, v.y); 
# 271
} 
#endif
# 273 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1Dfetch(texture< int4, 1, cudaReadModeElementType>  t, int x) 
# 274
{int volatile ___ = 1;(void)t;(void)x;
# 278
::exit(___);}
#if 0
# 274
{ 
# 275
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 277
return make_int4(v.x, v.y, v.z, v.w); 
# 278
} 
#endif
# 280 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1Dfetch(texture< uint4, 1, cudaReadModeElementType>  t, int x) 
# 281
{int volatile ___ = 1;(void)t;(void)x;
# 285
::exit(___);}
#if 0
# 281
{ 
# 282
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 284
return make_uint4(v.x, v.y, v.z, v.w); 
# 285
} 
#endif
# 359 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< float, 1, cudaReadModeElementType>  t, int x) 
# 360
{int volatile ___ = 1;(void)t;(void)x;
# 364
::exit(___);}
#if 0
# 360
{ 
# 361
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
# 363
return v.x; 
# 364
} 
#endif
# 366 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< float1, 1, cudaReadModeElementType>  t, int x) 
# 367
{int volatile ___ = 1;(void)t;(void)x;
# 371
::exit(___);}
#if 0
# 367
{ 
# 368
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
# 370
return make_float1(v.x); 
# 371
} 
#endif
# 373 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< float2, 1, cudaReadModeElementType>  t, int x) 
# 374
{int volatile ___ = 1;(void)t;(void)x;
# 378
::exit(___);}
#if 0
# 374
{ 
# 375
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
# 377
return make_float2(v.x, v.y); 
# 378
} 
#endif
# 380 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< float4, 1, cudaReadModeElementType>  t, int x) 
# 381
{int volatile ___ = 1;(void)t;(void)x;
# 385
::exit(___);}
#if 0
# 381
{ 
# 382
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
# 384
return make_float4(v.x, v.y, v.z, v.w); 
# 385
} 
#endif
# 393 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< char, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 394
{int volatile ___ = 1;(void)t;(void)x;
# 403
::exit(___);}
#if 0
# 394
{ 
# 398
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 400
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 402
return w.x; 
# 403
} 
#endif
# 405 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 406
{int volatile ___ = 1;(void)t;(void)x;
# 411
::exit(___);}
#if 0
# 406
{ 
# 407
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 408
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 410
return w.x; 
# 411
} 
#endif
# 413 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 414
{int volatile ___ = 1;(void)t;(void)x;
# 419
::exit(___);}
#if 0
# 414
{ 
# 415
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 416
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 418
return w.x; 
# 419
} 
#endif
# 421 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< char1, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 422
{int volatile ___ = 1;(void)t;(void)x;
# 427
::exit(___);}
#if 0
# 422
{ 
# 423
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 424
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 426
return make_float1(w.x); 
# 427
} 
#endif
# 429 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 430
{int volatile ___ = 1;(void)t;(void)x;
# 435
::exit(___);}
#if 0
# 430
{ 
# 431
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 432
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 434
return make_float1(w.x); 
# 435
} 
#endif
# 437 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< char2, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 438
{int volatile ___ = 1;(void)t;(void)x;
# 443
::exit(___);}
#if 0
# 438
{ 
# 439
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 440
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 442
return make_float2(w.x, w.y); 
# 443
} 
#endif
# 445 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 446
{int volatile ___ = 1;(void)t;(void)x;
# 451
::exit(___);}
#if 0
# 446
{ 
# 447
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 448
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 450
return make_float2(w.x, w.y); 
# 451
} 
#endif
# 453 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< char4, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 454
{int volatile ___ = 1;(void)t;(void)x;
# 459
::exit(___);}
#if 0
# 454
{ 
# 455
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 456
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 458
return make_float4(w.x, w.y, w.z, w.w); 
# 459
} 
#endif
# 461 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 462
{int volatile ___ = 1;(void)t;(void)x;
# 467
::exit(___);}
#if 0
# 462
{ 
# 463
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 464
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 466
return make_float4(w.x, w.y, w.z, w.w); 
# 467
} 
#endif
# 475 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< short, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 476
{int volatile ___ = 1;(void)t;(void)x;
# 481
::exit(___);}
#if 0
# 476
{ 
# 477
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 478
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 480
return w.x; 
# 481
} 
#endif
# 483 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1Dfetch(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 484
{int volatile ___ = 1;(void)t;(void)x;
# 489
::exit(___);}
#if 0
# 484
{ 
# 485
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 486
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 488
return w.x; 
# 489
} 
#endif
# 491 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< short1, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 492
{int volatile ___ = 1;(void)t;(void)x;
# 497
::exit(___);}
#if 0
# 492
{ 
# 493
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 494
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 496
return make_float1(w.x); 
# 497
} 
#endif
# 499 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1Dfetch(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 500
{int volatile ___ = 1;(void)t;(void)x;
# 505
::exit(___);}
#if 0
# 500
{ 
# 501
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 502
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 504
return make_float1(w.x); 
# 505
} 
#endif
# 507 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< short2, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 508
{int volatile ___ = 1;(void)t;(void)x;
# 513
::exit(___);}
#if 0
# 508
{ 
# 509
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 510
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 512
return make_float2(w.x, w.y); 
# 513
} 
#endif
# 515 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1Dfetch(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 516
{int volatile ___ = 1;(void)t;(void)x;
# 521
::exit(___);}
#if 0
# 516
{ 
# 517
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 518
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 520
return make_float2(w.x, w.y); 
# 521
} 
#endif
# 523 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< short4, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 524
{int volatile ___ = 1;(void)t;(void)x;
# 529
::exit(___);}
#if 0
# 524
{ 
# 525
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
# 526
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 528
return make_float4(w.x, w.y, w.z, w.w); 
# 529
} 
#endif
# 531 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1Dfetch(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 532
{int volatile ___ = 1;(void)t;(void)x;
# 537
::exit(___);}
#if 0
# 532
{ 
# 533
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
# 534
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 536
return make_float4(w.x, w.y, w.z, w.w); 
# 537
} 
#endif
# 545 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex1D(texture< char, 1, cudaReadModeElementType>  t, float x) 
# 546
{int volatile ___ = 1;(void)t;(void)x;
# 554
::exit(___);}
#if 0
# 546
{ 
# 550
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 553
return (char)(v.x); 
# 554
} 
#endif
# 556 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1D(texture< signed char, 1, cudaReadModeElementType>  t, float x) 
# 557
{int volatile ___ = 1;(void)t;(void)x;
# 561
::exit(___);}
#if 0
# 557
{ 
# 558
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 560
return (signed char)(v.x); 
# 561
} 
#endif
# 563 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1D(texture< unsigned char, 1, cudaReadModeElementType>  t, float x) 
# 564
{int volatile ___ = 1;(void)t;(void)x;
# 568
::exit(___);}
#if 0
# 564
{ 
# 565
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 567
return (unsigned char)(v.x); 
# 568
} 
#endif
# 570 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1D(texture< char1, 1, cudaReadModeElementType>  t, float x) 
# 571
{int volatile ___ = 1;(void)t;(void)x;
# 575
::exit(___);}
#if 0
# 571
{ 
# 572
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 574
return make_char1(v.x); 
# 575
} 
#endif
# 577 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1D(texture< uchar1, 1, cudaReadModeElementType>  t, float x) 
# 578
{int volatile ___ = 1;(void)t;(void)x;
# 582
::exit(___);}
#if 0
# 578
{ 
# 579
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 581
return make_uchar1(v.x); 
# 582
} 
#endif
# 584 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1D(texture< char2, 1, cudaReadModeElementType>  t, float x) 
# 585
{int volatile ___ = 1;(void)t;(void)x;
# 589
::exit(___);}
#if 0
# 585
{ 
# 586
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 588
return make_char2(v.x, v.y); 
# 589
} 
#endif
# 591 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1D(texture< uchar2, 1, cudaReadModeElementType>  t, float x) 
# 592
{int volatile ___ = 1;(void)t;(void)x;
# 596
::exit(___);}
#if 0
# 592
{ 
# 593
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 595
return make_uchar2(v.x, v.y); 
# 596
} 
#endif
# 598 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1D(texture< char4, 1, cudaReadModeElementType>  t, float x) 
# 599
{int volatile ___ = 1;(void)t;(void)x;
# 603
::exit(___);}
#if 0
# 599
{ 
# 600
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 602
return make_char4(v.x, v.y, v.z, v.w); 
# 603
} 
#endif
# 605 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1D(texture< uchar4, 1, cudaReadModeElementType>  t, float x) 
# 606
{int volatile ___ = 1;(void)t;(void)x;
# 610
::exit(___);}
#if 0
# 606
{ 
# 607
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 609
return make_uchar4(v.x, v.y, v.z, v.w); 
# 610
} 
#endif
# 618 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex1D(texture< short, 1, cudaReadModeElementType>  t, float x) 
# 619
{int volatile ___ = 1;(void)t;(void)x;
# 623
::exit(___);}
#if 0
# 619
{ 
# 620
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 622
return (short)(v.x); 
# 623
} 
#endif
# 625 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1D(texture< unsigned short, 1, cudaReadModeElementType>  t, float x) 
# 626
{int volatile ___ = 1;(void)t;(void)x;
# 630
::exit(___);}
#if 0
# 626
{ 
# 627
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 629
return (unsigned short)(v.x); 
# 630
} 
#endif
# 632 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1D(texture< short1, 1, cudaReadModeElementType>  t, float x) 
# 633
{int volatile ___ = 1;(void)t;(void)x;
# 637
::exit(___);}
#if 0
# 633
{ 
# 634
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 636
return make_short1(v.x); 
# 637
} 
#endif
# 639 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1D(texture< ushort1, 1, cudaReadModeElementType>  t, float x) 
# 640
{int volatile ___ = 1;(void)t;(void)x;
# 644
::exit(___);}
#if 0
# 640
{ 
# 641
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 643
return make_ushort1(v.x); 
# 644
} 
#endif
# 646 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1D(texture< short2, 1, cudaReadModeElementType>  t, float x) 
# 647
{int volatile ___ = 1;(void)t;(void)x;
# 651
::exit(___);}
#if 0
# 647
{ 
# 648
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 650
return make_short2(v.x, v.y); 
# 651
} 
#endif
# 653 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1D(texture< ushort2, 1, cudaReadModeElementType>  t, float x) 
# 654
{int volatile ___ = 1;(void)t;(void)x;
# 658
::exit(___);}
#if 0
# 654
{ 
# 655
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 657
return make_ushort2(v.x, v.y); 
# 658
} 
#endif
# 660 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1D(texture< short4, 1, cudaReadModeElementType>  t, float x) 
# 661
{int volatile ___ = 1;(void)t;(void)x;
# 665
::exit(___);}
#if 0
# 661
{ 
# 662
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 664
return make_short4(v.x, v.y, v.z, v.w); 
# 665
} 
#endif
# 667 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1D(texture< ushort4, 1, cudaReadModeElementType>  t, float x) 
# 668
{int volatile ___ = 1;(void)t;(void)x;
# 672
::exit(___);}
#if 0
# 668
{ 
# 669
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 671
return make_ushort4(v.x, v.y, v.z, v.w); 
# 672
} 
#endif
# 680 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex1D(texture< int, 1, cudaReadModeElementType>  t, float x) 
# 681
{int volatile ___ = 1;(void)t;(void)x;
# 685
::exit(___);}
#if 0
# 681
{ 
# 682
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 684
return (int)(v.x); 
# 685
} 
#endif
# 687 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1D(texture< unsigned, 1, cudaReadModeElementType>  t, float x) 
# 688
{int volatile ___ = 1;(void)t;(void)x;
# 692
::exit(___);}
#if 0
# 688
{ 
# 689
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 691
return (unsigned)(v.x); 
# 692
} 
#endif
# 694 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1D(texture< int1, 1, cudaReadModeElementType>  t, float x) 
# 695
{int volatile ___ = 1;(void)t;(void)x;
# 699
::exit(___);}
#if 0
# 695
{ 
# 696
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 698
return make_int1(v.x); 
# 699
} 
#endif
# 701 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1D(texture< uint1, 1, cudaReadModeElementType>  t, float x) 
# 702
{int volatile ___ = 1;(void)t;(void)x;
# 706
::exit(___);}
#if 0
# 702
{ 
# 703
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 705
return make_uint1(v.x); 
# 706
} 
#endif
# 708 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1D(texture< int2, 1, cudaReadModeElementType>  t, float x) 
# 709
{int volatile ___ = 1;(void)t;(void)x;
# 713
::exit(___);}
#if 0
# 709
{ 
# 710
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 712
return make_int2(v.x, v.y); 
# 713
} 
#endif
# 715 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1D(texture< uint2, 1, cudaReadModeElementType>  t, float x) 
# 716
{int volatile ___ = 1;(void)t;(void)x;
# 720
::exit(___);}
#if 0
# 716
{ 
# 717
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 719
return make_uint2(v.x, v.y); 
# 720
} 
#endif
# 722 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1D(texture< int4, 1, cudaReadModeElementType>  t, float x) 
# 723
{int volatile ___ = 1;(void)t;(void)x;
# 727
::exit(___);}
#if 0
# 723
{ 
# 724
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 726
return make_int4(v.x, v.y, v.z, v.w); 
# 727
} 
#endif
# 729 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1D(texture< uint4, 1, cudaReadModeElementType>  t, float x) 
# 730
{int volatile ___ = 1;(void)t;(void)x;
# 734
::exit(___);}
#if 0
# 730
{ 
# 731
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 733
return make_uint4(v.x, v.y, v.z, v.w); 
# 734
} 
#endif
# 814 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< float, 1, cudaReadModeElementType>  t, float x) 
# 815
{int volatile ___ = 1;(void)t;(void)x;
# 819
::exit(___);}
#if 0
# 815
{ 
# 816
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
# 818
return v.x; 
# 819
} 
#endif
# 821 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< float1, 1, cudaReadModeElementType>  t, float x) 
# 822
{int volatile ___ = 1;(void)t;(void)x;
# 826
::exit(___);}
#if 0
# 822
{ 
# 823
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
# 825
return make_float1(v.x); 
# 826
} 
#endif
# 828 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< float2, 1, cudaReadModeElementType>  t, float x) 
# 829
{int volatile ___ = 1;(void)t;(void)x;
# 833
::exit(___);}
#if 0
# 829
{ 
# 830
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
# 832
return make_float2(v.x, v.y); 
# 833
} 
#endif
# 835 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< float4, 1, cudaReadModeElementType>  t, float x) 
# 836
{int volatile ___ = 1;(void)t;(void)x;
# 840
::exit(___);}
#if 0
# 836
{ 
# 837
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
# 839
return make_float4(v.x, v.y, v.z, v.w); 
# 840
} 
#endif
# 848 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 849
{int volatile ___ = 1;(void)t;(void)x;
# 858
::exit(___);}
#if 0
# 849
{ 
# 853
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 855
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 857
return w.x; 
# 858
} 
#endif
# 860 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 861
{int volatile ___ = 1;(void)t;(void)x;
# 866
::exit(___);}
#if 0
# 861
{ 
# 862
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 863
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 865
return w.x; 
# 866
} 
#endif
# 868 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 869
{int volatile ___ = 1;(void)t;(void)x;
# 874
::exit(___);}
#if 0
# 869
{ 
# 870
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 871
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 873
return w.x; 
# 874
} 
#endif
# 876 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 877
{int volatile ___ = 1;(void)t;(void)x;
# 882
::exit(___);}
#if 0
# 877
{ 
# 878
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 879
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 881
return make_float1(w.x); 
# 882
} 
#endif
# 884 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 885
{int volatile ___ = 1;(void)t;(void)x;
# 890
::exit(___);}
#if 0
# 885
{ 
# 886
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 887
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 889
return make_float1(w.x); 
# 890
} 
#endif
# 892 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 893
{int volatile ___ = 1;(void)t;(void)x;
# 898
::exit(___);}
#if 0
# 893
{ 
# 894
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 895
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 897
return make_float2(w.x, w.y); 
# 898
} 
#endif
# 900 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 901
{int volatile ___ = 1;(void)t;(void)x;
# 906
::exit(___);}
#if 0
# 901
{ 
# 902
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 903
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 905
return make_float2(w.x, w.y); 
# 906
} 
#endif
# 908 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 909
{int volatile ___ = 1;(void)t;(void)x;
# 914
::exit(___);}
#if 0
# 909
{ 
# 910
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 911
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 913
return make_float4(w.x, w.y, w.z, w.w); 
# 914
} 
#endif
# 916 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 917
{int volatile ___ = 1;(void)t;(void)x;
# 922
::exit(___);}
#if 0
# 917
{ 
# 918
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 919
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 921
return make_float4(w.x, w.y, w.z, w.w); 
# 922
} 
#endif
# 930 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 931
{int volatile ___ = 1;(void)t;(void)x;
# 936
::exit(___);}
#if 0
# 931
{ 
# 932
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 933
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 935
return w.x; 
# 936
} 
#endif
# 938 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1D(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 939
{int volatile ___ = 1;(void)t;(void)x;
# 944
::exit(___);}
#if 0
# 939
{ 
# 940
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 941
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 943
return w.x; 
# 944
} 
#endif
# 946 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 947
{int volatile ___ = 1;(void)t;(void)x;
# 952
::exit(___);}
#if 0
# 947
{ 
# 948
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 949
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 951
return make_float1(w.x); 
# 952
} 
#endif
# 954 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1D(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 955
{int volatile ___ = 1;(void)t;(void)x;
# 960
::exit(___);}
#if 0
# 955
{ 
# 956
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 957
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 959
return make_float1(w.x); 
# 960
} 
#endif
# 962 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 963
{int volatile ___ = 1;(void)t;(void)x;
# 968
::exit(___);}
#if 0
# 963
{ 
# 964
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 965
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 967
return make_float2(w.x, w.y); 
# 968
} 
#endif
# 970 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1D(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 971
{int volatile ___ = 1;(void)t;(void)x;
# 976
::exit(___);}
#if 0
# 971
{ 
# 972
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 973
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 975
return make_float2(w.x, w.y); 
# 976
} 
#endif
# 978 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 979
{int volatile ___ = 1;(void)t;(void)x;
# 984
::exit(___);}
#if 0
# 979
{ 
# 980
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
# 981
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 983
return make_float4(w.x, w.y, w.z, w.w); 
# 984
} 
#endif
# 986 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1D(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 987
{int volatile ___ = 1;(void)t;(void)x;
# 992
::exit(___);}
#if 0
# 987
{ 
# 988
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
# 989
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 991
return make_float4(w.x, w.y, w.z, w.w); 
# 992
} 
#endif
# 1000 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex2D(texture< char, 2, cudaReadModeElementType>  t, float x, float y) 
# 1001
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1009
::exit(___);}
#if 0
# 1001
{ 
# 1005
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1008
return (char)(v.x); 
# 1009
} 
#endif
# 1011 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2D(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y) 
# 1012
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1016
::exit(___);}
#if 0
# 1012
{ 
# 1013
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1015
return (signed char)(v.x); 
# 1016
} 
#endif
# 1018 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2D(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y) 
# 1019
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1023
::exit(___);}
#if 0
# 1019
{ 
# 1020
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1022
return (unsigned char)(v.x); 
# 1023
} 
#endif
# 1025 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2D(texture< char1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1026
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1030
::exit(___);}
#if 0
# 1026
{ 
# 1027
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1029
return make_char1(v.x); 
# 1030
} 
#endif
# 1032 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2D(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1033
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1037
::exit(___);}
#if 0
# 1033
{ 
# 1034
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1036
return make_uchar1(v.x); 
# 1037
} 
#endif
# 1039 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2D(texture< char2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1040
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1044
::exit(___);}
#if 0
# 1040
{ 
# 1041
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1043
return make_char2(v.x, v.y); 
# 1044
} 
#endif
# 1046 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2D(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1047
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1051
::exit(___);}
#if 0
# 1047
{ 
# 1048
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1050
return make_uchar2(v.x, v.y); 
# 1051
} 
#endif
# 1053 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2D(texture< char4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1054
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1058
::exit(___);}
#if 0
# 1054
{ 
# 1055
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1057
return make_char4(v.x, v.y, v.z, v.w); 
# 1058
} 
#endif
# 1060 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2D(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1061
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1065
::exit(___);}
#if 0
# 1061
{ 
# 1062
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1064
return make_uchar4(v.x, v.y, v.z, v.w); 
# 1065
} 
#endif
# 1073 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex2D(texture< short, 2, cudaReadModeElementType>  t, float x, float y) 
# 1074
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1078
::exit(___);}
#if 0
# 1074
{ 
# 1075
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1077
return (short)(v.x); 
# 1078
} 
#endif
# 1080 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2D(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y) 
# 1081
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1085
::exit(___);}
#if 0
# 1081
{ 
# 1082
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1084
return (unsigned short)(v.x); 
# 1085
} 
#endif
# 1087 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2D(texture< short1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1088
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1092
::exit(___);}
#if 0
# 1088
{ 
# 1089
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1091
return make_short1(v.x); 
# 1092
} 
#endif
# 1094 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2D(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1095
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1099
::exit(___);}
#if 0
# 1095
{ 
# 1096
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1098
return make_ushort1(v.x); 
# 1099
} 
#endif
# 1101 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2D(texture< short2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1102
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1106
::exit(___);}
#if 0
# 1102
{ 
# 1103
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1105
return make_short2(v.x, v.y); 
# 1106
} 
#endif
# 1108 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2D(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1109
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1113
::exit(___);}
#if 0
# 1109
{ 
# 1110
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1112
return make_ushort2(v.x, v.y); 
# 1113
} 
#endif
# 1115 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2D(texture< short4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1116
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1120
::exit(___);}
#if 0
# 1116
{ 
# 1117
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1119
return make_short4(v.x, v.y, v.z, v.w); 
# 1120
} 
#endif
# 1122 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2D(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1123
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1127
::exit(___);}
#if 0
# 1123
{ 
# 1124
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1126
return make_ushort4(v.x, v.y, v.z, v.w); 
# 1127
} 
#endif
# 1135 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex2D(texture< int, 2, cudaReadModeElementType>  t, float x, float y) 
# 1136
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1140
::exit(___);}
#if 0
# 1136
{ 
# 1137
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1139
return (int)(v.x); 
# 1140
} 
#endif
# 1142 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2D(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y) 
# 1143
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1147
::exit(___);}
#if 0
# 1143
{ 
# 1144
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1146
return (unsigned)(v.x); 
# 1147
} 
#endif
# 1149 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2D(texture< int1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1150
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1154
::exit(___);}
#if 0
# 1150
{ 
# 1151
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1153
return make_int1(v.x); 
# 1154
} 
#endif
# 1156 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2D(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1157
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1161
::exit(___);}
#if 0
# 1157
{ 
# 1158
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1160
return make_uint1(v.x); 
# 1161
} 
#endif
# 1163 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2D(texture< int2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1164
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1168
::exit(___);}
#if 0
# 1164
{ 
# 1165
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1167
return make_int2(v.x, v.y); 
# 1168
} 
#endif
# 1170 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2D(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1171
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1175
::exit(___);}
#if 0
# 1171
{ 
# 1172
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1174
return make_uint2(v.x, v.y); 
# 1175
} 
#endif
# 1177 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2D(texture< int4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1178
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1182
::exit(___);}
#if 0
# 1178
{ 
# 1179
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1181
return make_int4(v.x, v.y, v.z, v.w); 
# 1182
} 
#endif
# 1184 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2D(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1185
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1189
::exit(___);}
#if 0
# 1185
{ 
# 1186
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1188
return make_uint4(v.x, v.y, v.z, v.w); 
# 1189
} 
#endif
# 1263 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< float, 2, cudaReadModeElementType>  t, float x, float y) 
# 1264
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1268
::exit(___);}
#if 0
# 1264
{ 
# 1265
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
# 1267
return v.x; 
# 1268
} 
#endif
# 1270 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< float1, 2, cudaReadModeElementType>  t, float x, float y) 
# 1271
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1275
::exit(___);}
#if 0
# 1271
{ 
# 1272
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
# 1274
return make_float1(v.x); 
# 1275
} 
#endif
# 1277 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< float2, 2, cudaReadModeElementType>  t, float x, float y) 
# 1278
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1282
::exit(___);}
#if 0
# 1278
{ 
# 1279
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
# 1281
return make_float2(v.x, v.y); 
# 1282
} 
#endif
# 1284 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< float4, 2, cudaReadModeElementType>  t, float x, float y) 
# 1285
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1289
::exit(___);}
#if 0
# 1285
{ 
# 1286
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
# 1288
return make_float4(v.x, v.y, v.z, v.w); 
# 1289
} 
#endif
# 1297 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1298
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1307
::exit(___);}
#if 0
# 1298
{ 
# 1302
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1304
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1306
return w.x; 
# 1307
} 
#endif
# 1309 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1310
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1315
::exit(___);}
#if 0
# 1310
{ 
# 1311
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1312
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1314
return w.x; 
# 1315
} 
#endif
# 1317 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1318
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1323
::exit(___);}
#if 0
# 1318
{ 
# 1319
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1320
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1322
return w.x; 
# 1323
} 
#endif
# 1325 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1326
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1331
::exit(___);}
#if 0
# 1326
{ 
# 1327
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1328
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1330
return make_float1(w.x); 
# 1331
} 
#endif
# 1333 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1334
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1339
::exit(___);}
#if 0
# 1334
{ 
# 1335
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1336
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1338
return make_float1(w.x); 
# 1339
} 
#endif
# 1341 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1342
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1347
::exit(___);}
#if 0
# 1342
{ 
# 1343
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1344
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1346
return make_float2(w.x, w.y); 
# 1347
} 
#endif
# 1349 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1350
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1355
::exit(___);}
#if 0
# 1350
{ 
# 1351
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1352
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1354
return make_float2(w.x, w.y); 
# 1355
} 
#endif
# 1357 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1358
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1363
::exit(___);}
#if 0
# 1358
{ 
# 1359
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1360
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1362
return make_float4(w.x, w.y, w.z, w.w); 
# 1363
} 
#endif
# 1365 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1366
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1371
::exit(___);}
#if 0
# 1366
{ 
# 1367
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1368
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1370
return make_float4(w.x, w.y, w.z, w.w); 
# 1371
} 
#endif
# 1379 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1380
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1385
::exit(___);}
#if 0
# 1380
{ 
# 1381
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1382
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1384
return w.x; 
# 1385
} 
#endif
# 1387 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2D(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1388
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1393
::exit(___);}
#if 0
# 1388
{ 
# 1389
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1390
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1392
return w.x; 
# 1393
} 
#endif
# 1395 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1396
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1401
::exit(___);}
#if 0
# 1396
{ 
# 1397
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1398
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1400
return make_float1(w.x); 
# 1401
} 
#endif
# 1403 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2D(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1404
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1409
::exit(___);}
#if 0
# 1404
{ 
# 1405
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1406
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1408
return make_float1(w.x); 
# 1409
} 
#endif
# 1411 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1412
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1417
::exit(___);}
#if 0
# 1412
{ 
# 1413
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1414
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1416
return make_float2(w.x, w.y); 
# 1417
} 
#endif
# 1419 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2D(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1420
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1425
::exit(___);}
#if 0
# 1420
{ 
# 1421
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1422
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1424
return make_float2(w.x, w.y); 
# 1425
} 
#endif
# 1427 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1428
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1433
::exit(___);}
#if 0
# 1428
{ 
# 1429
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
# 1430
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1432
return make_float4(w.x, w.y, w.z, w.w); 
# 1433
} 
#endif
# 1435 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2D(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 1436
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 1441
::exit(___);}
#if 0
# 1436
{ 
# 1437
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
# 1438
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1440
return make_float4(w.x, w.y, w.z, w.w); 
# 1441
} 
#endif
# 1449 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLayered(texture< char, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1450
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1458
::exit(___);}
#if 0
# 1450
{ 
# 1454
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1457
return (char)(v.x); 
# 1458
} 
#endif
# 1460 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLayered(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1461
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1465
::exit(___);}
#if 0
# 1461
{ 
# 1462
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1464
return (signed char)(v.x); 
# 1465
} 
#endif
# 1467 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLayered(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1468
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1472
::exit(___);}
#if 0
# 1468
{ 
# 1469
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1471
return (unsigned char)(v.x); 
# 1472
} 
#endif
# 1474 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLayered(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1475
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1479
::exit(___);}
#if 0
# 1475
{ 
# 1476
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1478
return make_char1(v.x); 
# 1479
} 
#endif
# 1481 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLayered(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1482
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1486
::exit(___);}
#if 0
# 1482
{ 
# 1483
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1485
return make_uchar1(v.x); 
# 1486
} 
#endif
# 1488 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLayered(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1489
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1493
::exit(___);}
#if 0
# 1489
{ 
# 1490
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1492
return make_char2(v.x, v.y); 
# 1493
} 
#endif
# 1495 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLayered(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1496
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1500
::exit(___);}
#if 0
# 1496
{ 
# 1497
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1499
return make_uchar2(v.x, v.y); 
# 1500
} 
#endif
# 1502 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLayered(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1503
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1507
::exit(___);}
#if 0
# 1503
{ 
# 1504
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1506
return make_char4(v.x, v.y, v.z, v.w); 
# 1507
} 
#endif
# 1509 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLayered(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1510
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1514
::exit(___);}
#if 0
# 1510
{ 
# 1511
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1513
return make_uchar4(v.x, v.y, v.z, v.w); 
# 1514
} 
#endif
# 1522 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLayered(texture< short, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1523
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1527
::exit(___);}
#if 0
# 1523
{ 
# 1524
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1526
return (short)(v.x); 
# 1527
} 
#endif
# 1529 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLayered(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1530
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1534
::exit(___);}
#if 0
# 1530
{ 
# 1531
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1533
return (unsigned short)(v.x); 
# 1534
} 
#endif
# 1536 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLayered(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1537
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1541
::exit(___);}
#if 0
# 1537
{ 
# 1538
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1540
return make_short1(v.x); 
# 1541
} 
#endif
# 1543 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLayered(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1544
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1548
::exit(___);}
#if 0
# 1544
{ 
# 1545
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1547
return make_ushort1(v.x); 
# 1548
} 
#endif
# 1550 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLayered(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1551
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1555
::exit(___);}
#if 0
# 1551
{ 
# 1552
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1554
return make_short2(v.x, v.y); 
# 1555
} 
#endif
# 1557 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLayered(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1558
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1562
::exit(___);}
#if 0
# 1558
{ 
# 1559
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1561
return make_ushort2(v.x, v.y); 
# 1562
} 
#endif
# 1564 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLayered(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1565
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1569
::exit(___);}
#if 0
# 1565
{ 
# 1566
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1568
return make_short4(v.x, v.y, v.z, v.w); 
# 1569
} 
#endif
# 1571 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLayered(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1572
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1576
::exit(___);}
#if 0
# 1572
{ 
# 1573
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1575
return make_ushort4(v.x, v.y, v.z, v.w); 
# 1576
} 
#endif
# 1584 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLayered(texture< int, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1585
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1589
::exit(___);}
#if 0
# 1585
{ 
# 1586
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1588
return (int)(v.x); 
# 1589
} 
#endif
# 1591 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLayered(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1592
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1596
::exit(___);}
#if 0
# 1592
{ 
# 1593
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1595
return (unsigned)(v.x); 
# 1596
} 
#endif
# 1598 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLayered(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1599
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1603
::exit(___);}
#if 0
# 1599
{ 
# 1600
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1602
return make_int1(v.x); 
# 1603
} 
#endif
# 1605 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLayered(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1606
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1610
::exit(___);}
#if 0
# 1606
{ 
# 1607
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1609
return make_uint1(v.x); 
# 1610
} 
#endif
# 1612 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLayered(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1613
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1617
::exit(___);}
#if 0
# 1613
{ 
# 1614
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1616
return make_int2(v.x, v.y); 
# 1617
} 
#endif
# 1619 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLayered(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1620
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1624
::exit(___);}
#if 0
# 1620
{ 
# 1621
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1623
return make_uint2(v.x, v.y); 
# 1624
} 
#endif
# 1626 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLayered(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1627
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1631
::exit(___);}
#if 0
# 1627
{ 
# 1628
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1630
return make_int4(v.x, v.y, v.z, v.w); 
# 1631
} 
#endif
# 1633 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLayered(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1634
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1638
::exit(___);}
#if 0
# 1634
{ 
# 1635
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1637
return make_uint4(v.x, v.y, v.z, v.w); 
# 1638
} 
#endif
# 1712 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< float, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1713
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1717
::exit(___);}
#if 0
# 1713
{ 
# 1714
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1716
return v.x; 
# 1717
} 
#endif
# 1719 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1720
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1724
::exit(___);}
#if 0
# 1720
{ 
# 1721
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1723
return make_float1(v.x); 
# 1724
} 
#endif
# 1726 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1727
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1731
::exit(___);}
#if 0
# 1727
{ 
# 1728
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1730
return make_float2(v.x, v.y); 
# 1731
} 
#endif
# 1733 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer) 
# 1734
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1738
::exit(___);}
#if 0
# 1734
{ 
# 1735
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1737
return make_float4(v.x, v.y, v.z, v.w); 
# 1738
} 
#endif
# 1746 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1747
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1756
::exit(___);}
#if 0
# 1747
{ 
# 1751
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1753
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1755
return w.x; 
# 1756
} 
#endif
# 1758 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1759
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1764
::exit(___);}
#if 0
# 1759
{ 
# 1760
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1761
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1763
return w.x; 
# 1764
} 
#endif
# 1766 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1767
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1772
::exit(___);}
#if 0
# 1767
{ 
# 1768
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1769
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1771
return w.x; 
# 1772
} 
#endif
# 1774 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1775
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1780
::exit(___);}
#if 0
# 1775
{ 
# 1776
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1777
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1779
return make_float1(w.x); 
# 1780
} 
#endif
# 1782 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1783
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1788
::exit(___);}
#if 0
# 1783
{ 
# 1784
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1785
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1787
return make_float1(w.x); 
# 1788
} 
#endif
# 1790 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1791
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1796
::exit(___);}
#if 0
# 1791
{ 
# 1792
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1793
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1795
return make_float2(w.x, w.y); 
# 1796
} 
#endif
# 1798 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1799
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1804
::exit(___);}
#if 0
# 1799
{ 
# 1800
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1801
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1803
return make_float2(w.x, w.y); 
# 1804
} 
#endif
# 1806 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1807
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1812
::exit(___);}
#if 0
# 1807
{ 
# 1808
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1809
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1811
return make_float4(w.x, w.y, w.z, w.w); 
# 1812
} 
#endif
# 1814 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1815
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1820
::exit(___);}
#if 0
# 1815
{ 
# 1816
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1817
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1819
return make_float4(w.x, w.y, w.z, w.w); 
# 1820
} 
#endif
# 1828 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1829
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1834
::exit(___);}
#if 0
# 1829
{ 
# 1830
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1831
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1833
return w.x; 
# 1834
} 
#endif
# 1836 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayered(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1837
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1842
::exit(___);}
#if 0
# 1837
{ 
# 1838
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1839
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1841
return w.x; 
# 1842
} 
#endif
# 1844 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1845
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1850
::exit(___);}
#if 0
# 1845
{ 
# 1846
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1847
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1849
return make_float1(w.x); 
# 1850
} 
#endif
# 1852 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayered(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1853
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1858
::exit(___);}
#if 0
# 1853
{ 
# 1854
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1855
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1857
return make_float1(w.x); 
# 1858
} 
#endif
# 1860 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1861
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1866
::exit(___);}
#if 0
# 1861
{ 
# 1862
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1863
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1865
return make_float2(w.x, w.y); 
# 1866
} 
#endif
# 1868 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayered(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1869
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1874
::exit(___);}
#if 0
# 1869
{ 
# 1870
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1871
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1873
return make_float2(w.x, w.y); 
# 1874
} 
#endif
# 1876 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1877
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1882
::exit(___);}
#if 0
# 1877
{ 
# 1878
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1879
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1881
return make_float4(w.x, w.y, w.z, w.w); 
# 1882
} 
#endif
# 1884 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayered(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 1885
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 1890
::exit(___);}
#if 0
# 1885
{ 
# 1886
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
# 1887
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 1889
return make_float4(w.x, w.y, w.z, w.w); 
# 1890
} 
#endif
# 1898 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLayered(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1899
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1907
::exit(___);}
#if 0
# 1899
{ 
# 1903
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1906
return (char)(v.x); 
# 1907
} 
#endif
# 1909 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLayered(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1910
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1914
::exit(___);}
#if 0
# 1910
{ 
# 1911
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1913
return (signed char)(v.x); 
# 1914
} 
#endif
# 1916 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLayered(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1917
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1921
::exit(___);}
#if 0
# 1917
{ 
# 1918
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1920
return (unsigned char)(v.x); 
# 1921
} 
#endif
# 1923 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLayered(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1924
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1928
::exit(___);}
#if 0
# 1924
{ 
# 1925
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1927
return make_char1(v.x); 
# 1928
} 
#endif
# 1930 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLayered(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1931
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1935
::exit(___);}
#if 0
# 1931
{ 
# 1932
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1934
return make_uchar1(v.x); 
# 1935
} 
#endif
# 1937 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLayered(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1942
::exit(___);}
#if 0
# 1938
{ 
# 1939
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1941
return make_char2(v.x, v.y); 
# 1942
} 
#endif
# 1944 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLayered(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1945
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1949
::exit(___);}
#if 0
# 1945
{ 
# 1946
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1948
return make_uchar2(v.x, v.y); 
# 1949
} 
#endif
# 1951 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLayered(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1952
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1956
::exit(___);}
#if 0
# 1952
{ 
# 1953
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1955
return make_char4(v.x, v.y, v.z, v.w); 
# 1956
} 
#endif
# 1958 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLayered(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1959
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1963
::exit(___);}
#if 0
# 1959
{ 
# 1960
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1962
return make_uchar4(v.x, v.y, v.z, v.w); 
# 1963
} 
#endif
# 1971 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLayered(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1972
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1976
::exit(___);}
#if 0
# 1972
{ 
# 1973
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1975
return (short)(v.x); 
# 1976
} 
#endif
# 1978 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLayered(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1979
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1983
::exit(___);}
#if 0
# 1979
{ 
# 1980
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1982
return (unsigned short)(v.x); 
# 1983
} 
#endif
# 1985 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLayered(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1986
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1990
::exit(___);}
#if 0
# 1986
{ 
# 1987
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1989
return make_short1(v.x); 
# 1990
} 
#endif
# 1992 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLayered(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 1993
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 1997
::exit(___);}
#if 0
# 1993
{ 
# 1994
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 1996
return make_ushort1(v.x); 
# 1997
} 
#endif
# 1999 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLayered(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2004
::exit(___);}
#if 0
# 2000
{ 
# 2001
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2003
return make_short2(v.x, v.y); 
# 2004
} 
#endif
# 2006 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLayered(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2011
::exit(___);}
#if 0
# 2007
{ 
# 2008
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2010
return make_ushort2(v.x, v.y); 
# 2011
} 
#endif
# 2013 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLayered(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2018
::exit(___);}
#if 0
# 2014
{ 
# 2015
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2017
return make_short4(v.x, v.y, v.z, v.w); 
# 2018
} 
#endif
# 2020 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLayered(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2021
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2025
::exit(___);}
#if 0
# 2021
{ 
# 2022
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2024
return make_ushort4(v.x, v.y, v.z, v.w); 
# 2025
} 
#endif
# 2033 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLayered(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2034
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2038
::exit(___);}
#if 0
# 2034
{ 
# 2035
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2037
return (int)(v.x); 
# 2038
} 
#endif
# 2040 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLayered(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2041
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2045
::exit(___);}
#if 0
# 2041
{ 
# 2042
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2044
return (unsigned)(v.x); 
# 2045
} 
#endif
# 2047 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLayered(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2048
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2052
::exit(___);}
#if 0
# 2048
{ 
# 2049
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2051
return make_int1(v.x); 
# 2052
} 
#endif
# 2054 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLayered(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2055
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2059
::exit(___);}
#if 0
# 2055
{ 
# 2056
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2058
return make_uint1(v.x); 
# 2059
} 
#endif
# 2061 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLayered(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2066
::exit(___);}
#if 0
# 2062
{ 
# 2063
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2065
return make_int2(v.x, v.y); 
# 2066
} 
#endif
# 2068 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLayered(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2069
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2073
::exit(___);}
#if 0
# 2069
{ 
# 2070
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2072
return make_uint2(v.x, v.y); 
# 2073
} 
#endif
# 2075 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLayered(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2076
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2080
::exit(___);}
#if 0
# 2076
{ 
# 2077
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2079
return make_int4(v.x, v.y, v.z, v.w); 
# 2080
} 
#endif
# 2082 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLayered(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2083
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2087
::exit(___);}
#if 0
# 2083
{ 
# 2084
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2086
return make_uint4(v.x, v.y, v.z, v.w); 
# 2087
} 
#endif
# 2161 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2162
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2166
::exit(___);}
#if 0
# 2162
{ 
# 2163
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2165
return v.x; 
# 2166
} 
#endif
# 2168 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2169
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2173
::exit(___);}
#if 0
# 2169
{ 
# 2170
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2172
return make_float1(v.x); 
# 2173
} 
#endif
# 2175 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2176
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2180
::exit(___);}
#if 0
# 2176
{ 
# 2177
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2179
return make_float2(v.x, v.y); 
# 2180
} 
#endif
# 2182 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 2183
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2187
::exit(___);}
#if 0
# 2183
{ 
# 2184
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2186
return make_float4(v.x, v.y, v.z, v.w); 
# 2187
} 
#endif
# 2195 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2196
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2205
::exit(___);}
#if 0
# 2196
{ 
# 2200
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2202
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2204
return w.x; 
# 2205
} 
#endif
# 2207 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2208
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2213
::exit(___);}
#if 0
# 2208
{ 
# 2209
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2210
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2212
return w.x; 
# 2213
} 
#endif
# 2215 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2216
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2221
::exit(___);}
#if 0
# 2216
{ 
# 2217
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2218
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2220
return w.x; 
# 2221
} 
#endif
# 2223 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2224
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2229
::exit(___);}
#if 0
# 2224
{ 
# 2225
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2226
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2228
return make_float1(w.x); 
# 2229
} 
#endif
# 2231 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2232
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2237
::exit(___);}
#if 0
# 2232
{ 
# 2233
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2234
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2236
return make_float1(w.x); 
# 2237
} 
#endif
# 2239 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2240
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2245
::exit(___);}
#if 0
# 2240
{ 
# 2241
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2242
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2244
return make_float2(w.x, w.y); 
# 2245
} 
#endif
# 2247 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2248
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2253
::exit(___);}
#if 0
# 2248
{ 
# 2249
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2250
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2252
return make_float2(w.x, w.y); 
# 2253
} 
#endif
# 2255 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2256
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2261
::exit(___);}
#if 0
# 2256
{ 
# 2257
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2258
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2260
return make_float4(w.x, w.y, w.z, w.w); 
# 2261
} 
#endif
# 2263 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2264
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2269
::exit(___);}
#if 0
# 2264
{ 
# 2265
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2266
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2268
return make_float4(w.x, w.y, w.z, w.w); 
# 2269
} 
#endif
# 2277 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2278
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2283
::exit(___);}
#if 0
# 2278
{ 
# 2279
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2280
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2282
return w.x; 
# 2283
} 
#endif
# 2285 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayered(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2286
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2291
::exit(___);}
#if 0
# 2286
{ 
# 2287
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2288
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2290
return w.x; 
# 2291
} 
#endif
# 2293 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2294
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2299
::exit(___);}
#if 0
# 2294
{ 
# 2295
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2296
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2298
return make_float1(w.x); 
# 2299
} 
#endif
# 2301 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayered(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2302
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2307
::exit(___);}
#if 0
# 2302
{ 
# 2303
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2304
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2306
return make_float1(w.x); 
# 2307
} 
#endif
# 2309 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2310
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2315
::exit(___);}
#if 0
# 2310
{ 
# 2311
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2312
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2314
return make_float2(w.x, w.y); 
# 2315
} 
#endif
# 2317 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayered(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2318
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2323
::exit(___);}
#if 0
# 2318
{ 
# 2319
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2320
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2322
return make_float2(w.x, w.y); 
# 2323
} 
#endif
# 2325 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2326
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2331
::exit(___);}
#if 0
# 2326
{ 
# 2327
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2328
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2330
return make_float4(w.x, w.y, w.z, w.w); 
# 2331
} 
#endif
# 2333 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayered(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 2334
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 2339
::exit(___);}
#if 0
# 2334
{ 
# 2335
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
# 2336
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2338
return make_float4(w.x, w.y, w.z, w.w); 
# 2339
} 
#endif
# 2347 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex3D(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2348
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2356
::exit(___);}
#if 0
# 2348
{ 
# 2352
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2355
return (char)(v.x); 
# 2356
} 
#endif
# 2358 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex3D(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2359
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2363
::exit(___);}
#if 0
# 2359
{ 
# 2360
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2362
return (signed char)(v.x); 
# 2363
} 
#endif
# 2365 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex3D(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2366
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2370
::exit(___);}
#if 0
# 2366
{ 
# 2367
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2369
return (unsigned char)(v.x); 
# 2370
} 
#endif
# 2372 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex3D(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2373
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2377
::exit(___);}
#if 0
# 2373
{ 
# 2374
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2376
return make_char1(v.x); 
# 2377
} 
#endif
# 2379 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex3D(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2380
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2384
::exit(___);}
#if 0
# 2380
{ 
# 2381
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2383
return make_uchar1(v.x); 
# 2384
} 
#endif
# 2386 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex3D(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2387
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2391
::exit(___);}
#if 0
# 2387
{ 
# 2388
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2390
return make_char2(v.x, v.y); 
# 2391
} 
#endif
# 2393 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex3D(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2394
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2398
::exit(___);}
#if 0
# 2394
{ 
# 2395
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2397
return make_uchar2(v.x, v.y); 
# 2398
} 
#endif
# 2400 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex3D(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2401
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2405
::exit(___);}
#if 0
# 2401
{ 
# 2402
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2404
return make_char4(v.x, v.y, v.z, v.w); 
# 2405
} 
#endif
# 2407 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex3D(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2408
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2412
::exit(___);}
#if 0
# 2408
{ 
# 2409
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2411
return make_uchar4(v.x, v.y, v.z, v.w); 
# 2412
} 
#endif
# 2420 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex3D(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2421
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2425
::exit(___);}
#if 0
# 2421
{ 
# 2422
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2424
return (short)(v.x); 
# 2425
} 
#endif
# 2427 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex3D(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2428
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2432
::exit(___);}
#if 0
# 2428
{ 
# 2429
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2431
return (unsigned short)(v.x); 
# 2432
} 
#endif
# 2434 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex3D(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2435
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2439
::exit(___);}
#if 0
# 2435
{ 
# 2436
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2438
return make_short1(v.x); 
# 2439
} 
#endif
# 2441 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex3D(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2442
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2446
::exit(___);}
#if 0
# 2442
{ 
# 2443
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2445
return make_ushort1(v.x); 
# 2446
} 
#endif
# 2448 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex3D(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2449
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2453
::exit(___);}
#if 0
# 2449
{ 
# 2450
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2452
return make_short2(v.x, v.y); 
# 2453
} 
#endif
# 2455 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex3D(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2456
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2460
::exit(___);}
#if 0
# 2456
{ 
# 2457
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2459
return make_ushort2(v.x, v.y); 
# 2460
} 
#endif
# 2462 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex3D(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2463
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2467
::exit(___);}
#if 0
# 2463
{ 
# 2464
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2466
return make_short4(v.x, v.y, v.z, v.w); 
# 2467
} 
#endif
# 2469 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex3D(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2470
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2474
::exit(___);}
#if 0
# 2470
{ 
# 2471
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2473
return make_ushort4(v.x, v.y, v.z, v.w); 
# 2474
} 
#endif
# 2482 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex3D(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2483
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2487
::exit(___);}
#if 0
# 2483
{ 
# 2484
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2486
return (int)(v.x); 
# 2487
} 
#endif
# 2489 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex3D(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2490
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2494
::exit(___);}
#if 0
# 2490
{ 
# 2491
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2493
return (unsigned)(v.x); 
# 2494
} 
#endif
# 2496 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex3D(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2497
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2501
::exit(___);}
#if 0
# 2497
{ 
# 2498
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2500
return make_int1(v.x); 
# 2501
} 
#endif
# 2503 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex3D(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2504
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2508
::exit(___);}
#if 0
# 2504
{ 
# 2505
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2507
return make_uint1(v.x); 
# 2508
} 
#endif
# 2510 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex3D(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2511
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2515
::exit(___);}
#if 0
# 2511
{ 
# 2512
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2514
return make_int2(v.x, v.y); 
# 2515
} 
#endif
# 2517 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex3D(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2518
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2522
::exit(___);}
#if 0
# 2518
{ 
# 2519
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2521
return make_uint2(v.x, v.y); 
# 2522
} 
#endif
# 2524 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex3D(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2525
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2529
::exit(___);}
#if 0
# 2525
{ 
# 2526
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2528
return make_int4(v.x, v.y, v.z, v.w); 
# 2529
} 
#endif
# 2531 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex3D(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2532
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2536
::exit(___);}
#if 0
# 2532
{ 
# 2533
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2535
return make_uint4(v.x, v.y, v.z, v.w); 
# 2536
} 
#endif
# 2610 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2611
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2615
::exit(___);}
#if 0
# 2611
{ 
# 2612
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
# 2614
return v.x; 
# 2615
} 
#endif
# 2617 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2618
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2622
::exit(___);}
#if 0
# 2618
{ 
# 2619
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
# 2621
return make_float1(v.x); 
# 2622
} 
#endif
# 2624 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2625
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2629
::exit(___);}
#if 0
# 2625
{ 
# 2626
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
# 2628
return make_float2(v.x, v.y); 
# 2629
} 
#endif
# 2631 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 2632
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2636
::exit(___);}
#if 0
# 2632
{ 
# 2633
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
# 2635
return make_float4(v.x, v.y, v.z, v.w); 
# 2636
} 
#endif
# 2644 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2645
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2654
::exit(___);}
#if 0
# 2645
{ 
# 2649
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2651
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2653
return w.x; 
# 2654
} 
#endif
# 2656 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2657
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2662
::exit(___);}
#if 0
# 2657
{ 
# 2658
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2659
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2661
return w.x; 
# 2662
} 
#endif
# 2664 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2665
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2670
::exit(___);}
#if 0
# 2665
{ 
# 2666
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2667
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2669
return w.x; 
# 2670
} 
#endif
# 2672 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2678
::exit(___);}
#if 0
# 2673
{ 
# 2674
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2675
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2677
return make_float1(w.x); 
# 2678
} 
#endif
# 2680 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2686
::exit(___);}
#if 0
# 2681
{ 
# 2682
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2683
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2685
return make_float1(w.x); 
# 2686
} 
#endif
# 2688 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2689
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2694
::exit(___);}
#if 0
# 2689
{ 
# 2690
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2691
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2693
return make_float2(w.x, w.y); 
# 2694
} 
#endif
# 2696 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2697
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2702
::exit(___);}
#if 0
# 2697
{ 
# 2698
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2699
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2701
return make_float2(w.x, w.y); 
# 2702
} 
#endif
# 2704 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2705
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2710
::exit(___);}
#if 0
# 2705
{ 
# 2706
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2707
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2709
return make_float4(w.x, w.y, w.z, w.w); 
# 2710
} 
#endif
# 2712 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2713
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2718
::exit(___);}
#if 0
# 2713
{ 
# 2714
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2715
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2717
return make_float4(w.x, w.y, w.z, w.w); 
# 2718
} 
#endif
# 2726 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2727
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2732
::exit(___);}
#if 0
# 2727
{ 
# 2728
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2729
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2731
return w.x; 
# 2732
} 
#endif
# 2734 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3D(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2735
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2740
::exit(___);}
#if 0
# 2735
{ 
# 2736
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2737
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2739
return w.x; 
# 2740
} 
#endif
# 2742 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2743
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2748
::exit(___);}
#if 0
# 2743
{ 
# 2744
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2745
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2747
return make_float1(w.x); 
# 2748
} 
#endif
# 2750 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3D(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2751
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2756
::exit(___);}
#if 0
# 2751
{ 
# 2752
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2753
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2755
return make_float1(w.x); 
# 2756
} 
#endif
# 2758 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2759
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2764
::exit(___);}
#if 0
# 2759
{ 
# 2760
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2761
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2763
return make_float2(w.x, w.y); 
# 2764
} 
#endif
# 2766 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3D(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2767
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2772
::exit(___);}
#if 0
# 2767
{ 
# 2768
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2769
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2771
return make_float2(w.x, w.y); 
# 2772
} 
#endif
# 2774 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2775
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2780
::exit(___);}
#if 0
# 2775
{ 
# 2776
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
# 2777
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2779
return make_float4(w.x, w.y, w.z, w.w); 
# 2780
} 
#endif
# 2782 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3D(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 2783
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2788
::exit(___);}
#if 0
# 2783
{ 
# 2784
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
# 2785
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 2787
return make_float4(w.x, w.y, w.z, w.w); 
# 2788
} 
#endif
# 2796 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemap(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2797
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2805
::exit(___);}
#if 0
# 2797
{ 
# 2801
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2804
return (char)(v.x); 
# 2805
} 
#endif
# 2807 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemap(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2808
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2812
::exit(___);}
#if 0
# 2808
{ 
# 2809
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2811
return (signed char)(v.x); 
# 2812
} 
#endif
# 2814 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemap(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2815
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2819
::exit(___);}
#if 0
# 2815
{ 
# 2816
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2818
return (unsigned char)(v.x); 
# 2819
} 
#endif
# 2821 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemap(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2822
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2826
::exit(___);}
#if 0
# 2822
{ 
# 2823
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2825
return make_char1(v.x); 
# 2826
} 
#endif
# 2828 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemap(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2829
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2833
::exit(___);}
#if 0
# 2829
{ 
# 2830
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2832
return make_uchar1(v.x); 
# 2833
} 
#endif
# 2835 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemap(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2836
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2840
::exit(___);}
#if 0
# 2836
{ 
# 2837
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2839
return make_char2(v.x, v.y); 
# 2840
} 
#endif
# 2842 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemap(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2847
::exit(___);}
#if 0
# 2843
{ 
# 2844
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2846
return make_uchar2(v.x, v.y); 
# 2847
} 
#endif
# 2849 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemap(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2854
::exit(___);}
#if 0
# 2850
{ 
# 2851
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2853
return make_char4(v.x, v.y, v.z, v.w); 
# 2854
} 
#endif
# 2856 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemap(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2861
::exit(___);}
#if 0
# 2857
{ 
# 2858
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2860
return make_uchar4(v.x, v.y, v.z, v.w); 
# 2861
} 
#endif
# 2869 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemap(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2870
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2874
::exit(___);}
#if 0
# 2870
{ 
# 2871
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2873
return (short)(v.x); 
# 2874
} 
#endif
# 2876 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemap(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2877
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2881
::exit(___);}
#if 0
# 2877
{ 
# 2878
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2880
return (unsigned short)(v.x); 
# 2881
} 
#endif
# 2883 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemap(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2884
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2888
::exit(___);}
#if 0
# 2884
{ 
# 2885
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2887
return make_short1(v.x); 
# 2888
} 
#endif
# 2890 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemap(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2891
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2895
::exit(___);}
#if 0
# 2891
{ 
# 2892
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2894
return make_ushort1(v.x); 
# 2895
} 
#endif
# 2897 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemap(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2902
::exit(___);}
#if 0
# 2898
{ 
# 2899
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2901
return make_short2(v.x, v.y); 
# 2902
} 
#endif
# 2904 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemap(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2909
::exit(___);}
#if 0
# 2905
{ 
# 2906
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2908
return make_ushort2(v.x, v.y); 
# 2909
} 
#endif
# 2911 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemap(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2912
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2916
::exit(___);}
#if 0
# 2912
{ 
# 2913
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2915
return make_short4(v.x, v.y, v.z, v.w); 
# 2916
} 
#endif
# 2918 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemap(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2919
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2923
::exit(___);}
#if 0
# 2919
{ 
# 2920
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2922
return make_ushort4(v.x, v.y, v.z, v.w); 
# 2923
} 
#endif
# 2931 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemap(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2932
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2936
::exit(___);}
#if 0
# 2932
{ 
# 2933
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2935
return (int)(v.x); 
# 2936
} 
#endif
# 2938 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemap(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2939
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2943
::exit(___);}
#if 0
# 2939
{ 
# 2940
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2942
return (unsigned)(v.x); 
# 2943
} 
#endif
# 2945 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemap(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2946
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2950
::exit(___);}
#if 0
# 2946
{ 
# 2947
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2949
return make_int1(v.x); 
# 2950
} 
#endif
# 2952 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemap(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2953
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2957
::exit(___);}
#if 0
# 2953
{ 
# 2954
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2956
return make_uint1(v.x); 
# 2957
} 
#endif
# 2959 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemap(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2960
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2964
::exit(___);}
#if 0
# 2960
{ 
# 2961
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2963
return make_int2(v.x, v.y); 
# 2964
} 
#endif
# 2966 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemap(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2967
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2971
::exit(___);}
#if 0
# 2967
{ 
# 2968
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2970
return make_uint2(v.x, v.y); 
# 2971
} 
#endif
# 2973 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemap(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2974
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2978
::exit(___);}
#if 0
# 2974
{ 
# 2975
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 2977
return make_int4(v.x, v.y, v.z, v.w); 
# 2978
} 
#endif
# 2980 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemap(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 2981
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 2985
::exit(___);}
#if 0
# 2981
{ 
# 2982
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 2984
return make_uint4(v.x, v.y, v.z, v.w); 
# 2985
} 
#endif
# 3059 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 3060
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3064
::exit(___);}
#if 0
# 3060
{ 
# 3061
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
# 3063
return v.x; 
# 3064
} 
#endif
# 3066 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 3067
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3071
::exit(___);}
#if 0
# 3067
{ 
# 3068
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
# 3070
return make_float1(v.x); 
# 3071
} 
#endif
# 3073 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 3074
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3078
::exit(___);}
#if 0
# 3074
{ 
# 3075
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
# 3077
return make_float2(v.x, v.y); 
# 3078
} 
#endif
# 3080 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 3081
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3085
::exit(___);}
#if 0
# 3081
{ 
# 3082
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
# 3084
return make_float4(v.x, v.y, v.z, v.w); 
# 3085
} 
#endif
# 3093 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3094
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3103
::exit(___);}
#if 0
# 3094
{ 
# 3098
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3100
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3102
return w.x; 
# 3103
} 
#endif
# 3105 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3106
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3111
::exit(___);}
#if 0
# 3106
{ 
# 3107
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3108
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3110
return w.x; 
# 3111
} 
#endif
# 3113 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3114
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3119
::exit(___);}
#if 0
# 3114
{ 
# 3115
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3116
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3118
return w.x; 
# 3119
} 
#endif
# 3121 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3122
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3127
::exit(___);}
#if 0
# 3122
{ 
# 3123
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3124
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3126
return make_float1(w.x); 
# 3127
} 
#endif
# 3129 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3130
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3135
::exit(___);}
#if 0
# 3130
{ 
# 3131
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3132
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3134
return make_float1(w.x); 
# 3135
} 
#endif
# 3137 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3138
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3143
::exit(___);}
#if 0
# 3138
{ 
# 3139
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3140
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3142
return make_float2(w.x, w.y); 
# 3143
} 
#endif
# 3145 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3146
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3151
::exit(___);}
#if 0
# 3146
{ 
# 3147
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3148
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3150
return make_float2(w.x, w.y); 
# 3151
} 
#endif
# 3153 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3154
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3159
::exit(___);}
#if 0
# 3154
{ 
# 3155
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3156
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3158
return make_float4(w.x, w.y, w.z, w.w); 
# 3159
} 
#endif
# 3161 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3162
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3167
::exit(___);}
#if 0
# 3162
{ 
# 3163
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3164
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3166
return make_float4(w.x, w.y, w.z, w.w); 
# 3167
} 
#endif
# 3175 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3176
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3181
::exit(___);}
#if 0
# 3176
{ 
# 3177
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3178
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3180
return w.x; 
# 3181
} 
#endif
# 3183 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemap(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3184
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3189
::exit(___);}
#if 0
# 3184
{ 
# 3185
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3186
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3188
return w.x; 
# 3189
} 
#endif
# 3191 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3192
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3197
::exit(___);}
#if 0
# 3192
{ 
# 3193
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3194
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3196
return make_float1(w.x); 
# 3197
} 
#endif
# 3199 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemap(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3200
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3205
::exit(___);}
#if 0
# 3200
{ 
# 3201
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3202
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3204
return make_float1(w.x); 
# 3205
} 
#endif
# 3207 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3208
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3213
::exit(___);}
#if 0
# 3208
{ 
# 3209
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3210
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3212
return make_float2(w.x, w.y); 
# 3213
} 
#endif
# 3215 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemap(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3216
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3221
::exit(___);}
#if 0
# 3216
{ 
# 3217
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3218
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3220
return make_float2(w.x, w.y); 
# 3221
} 
#endif
# 3223 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3224
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3229
::exit(___);}
#if 0
# 3224
{ 
# 3225
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
# 3226
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3228
return make_float4(w.x, w.y, w.z, w.w); 
# 3229
} 
#endif
# 3231 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemap(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 3232
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 3237
::exit(___);}
#if 0
# 3232
{ 
# 3233
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
# 3234
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3236
return make_float4(w.x, w.y, w.z, w.w); 
# 3237
} 
#endif
# 3245 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemapLayered(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3246
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3254
::exit(___);}
#if 0
# 3246
{ 
# 3250
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3253
return (char)(v.x); 
# 3254
} 
#endif
# 3256 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemapLayered(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3257
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3261
::exit(___);}
#if 0
# 3257
{ 
# 3258
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3260
return (signed char)(v.x); 
# 3261
} 
#endif
# 3263 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemapLayered(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3264
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3268
::exit(___);}
#if 0
# 3264
{ 
# 3265
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3267
return (unsigned char)(v.x); 
# 3268
} 
#endif
# 3270 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemapLayered(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3271
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3275
::exit(___);}
#if 0
# 3271
{ 
# 3272
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3274
return make_char1(v.x); 
# 3275
} 
#endif
# 3277 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemapLayered(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3278
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3282
::exit(___);}
#if 0
# 3278
{ 
# 3279
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3281
return make_uchar1(v.x); 
# 3282
} 
#endif
# 3284 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemapLayered(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3285
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3289
::exit(___);}
#if 0
# 3285
{ 
# 3286
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3288
return make_char2(v.x, v.y); 
# 3289
} 
#endif
# 3291 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemapLayered(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3292
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3296
::exit(___);}
#if 0
# 3292
{ 
# 3293
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3295
return make_uchar2(v.x, v.y); 
# 3296
} 
#endif
# 3298 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemapLayered(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3299
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3303
::exit(___);}
#if 0
# 3299
{ 
# 3300
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3302
return make_char4(v.x, v.y, v.z, v.w); 
# 3303
} 
#endif
# 3305 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemapLayered(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3306
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3310
::exit(___);}
#if 0
# 3306
{ 
# 3307
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3309
return make_uchar4(v.x, v.y, v.z, v.w); 
# 3310
} 
#endif
# 3318 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemapLayered(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3319
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3323
::exit(___);}
#if 0
# 3319
{ 
# 3320
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3322
return (short)(v.x); 
# 3323
} 
#endif
# 3325 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemapLayered(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3326
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3330
::exit(___);}
#if 0
# 3326
{ 
# 3327
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3329
return (unsigned short)(v.x); 
# 3330
} 
#endif
# 3332 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemapLayered(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3333
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3337
::exit(___);}
#if 0
# 3333
{ 
# 3334
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3336
return make_short1(v.x); 
# 3337
} 
#endif
# 3339 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemapLayered(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3340
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3344
::exit(___);}
#if 0
# 3340
{ 
# 3341
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3343
return make_ushort1(v.x); 
# 3344
} 
#endif
# 3346 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemapLayered(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3347
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3351
::exit(___);}
#if 0
# 3347
{ 
# 3348
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3350
return make_short2(v.x, v.y); 
# 3351
} 
#endif
# 3353 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemapLayered(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3354
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3358
::exit(___);}
#if 0
# 3354
{ 
# 3355
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3357
return make_ushort2(v.x, v.y); 
# 3358
} 
#endif
# 3360 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemapLayered(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3361
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3365
::exit(___);}
#if 0
# 3361
{ 
# 3362
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3364
return make_short4(v.x, v.y, v.z, v.w); 
# 3365
} 
#endif
# 3367 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemapLayered(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3368
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3372
::exit(___);}
#if 0
# 3368
{ 
# 3369
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3371
return make_ushort4(v.x, v.y, v.z, v.w); 
# 3372
} 
#endif
# 3380 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemapLayered(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3381
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3385
::exit(___);}
#if 0
# 3381
{ 
# 3382
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3384
return (int)(v.x); 
# 3385
} 
#endif
# 3387 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemapLayered(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3388
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3392
::exit(___);}
#if 0
# 3388
{ 
# 3389
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3391
return (unsigned)(v.x); 
# 3392
} 
#endif
# 3394 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemapLayered(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3395
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3399
::exit(___);}
#if 0
# 3395
{ 
# 3396
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3398
return make_int1(v.x); 
# 3399
} 
#endif
# 3401 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemapLayered(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3402
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3406
::exit(___);}
#if 0
# 3402
{ 
# 3403
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3405
return make_uint1(v.x); 
# 3406
} 
#endif
# 3408 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemapLayered(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3409
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3413
::exit(___);}
#if 0
# 3409
{ 
# 3410
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3412
return make_int2(v.x, v.y); 
# 3413
} 
#endif
# 3415 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemapLayered(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3416
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3420
::exit(___);}
#if 0
# 3416
{ 
# 3417
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3419
return make_uint2(v.x, v.y); 
# 3420
} 
#endif
# 3422 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemapLayered(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3423
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3427
::exit(___);}
#if 0
# 3423
{ 
# 3424
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3426
return make_int4(v.x, v.y, v.z, v.w); 
# 3427
} 
#endif
# 3429 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemapLayered(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3430
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3434
::exit(___);}
#if 0
# 3430
{ 
# 3431
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3433
return make_uint4(v.x, v.y, v.z, v.w); 
# 3434
} 
#endif
# 3508 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3509
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3513
::exit(___);}
#if 0
# 3509
{ 
# 3510
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3512
return v.x; 
# 3513
} 
#endif
# 3515 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3516
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3520
::exit(___);}
#if 0
# 3516
{ 
# 3517
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3519
return make_float1(v.x); 
# 3520
} 
#endif
# 3522 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3523
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3527
::exit(___);}
#if 0
# 3523
{ 
# 3524
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3526
return make_float2(v.x, v.y); 
# 3527
} 
#endif
# 3529 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 3530
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3534
::exit(___);}
#if 0
# 3530
{ 
# 3531
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3533
return make_float4(v.x, v.y, v.z, v.w); 
# 3534
} 
#endif
# 3542 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3543
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3552
::exit(___);}
#if 0
# 3543
{ 
# 3547
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3549
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3551
return w.x; 
# 3552
} 
#endif
# 3554 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3555
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3560
::exit(___);}
#if 0
# 3555
{ 
# 3556
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3557
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3559
return w.x; 
# 3560
} 
#endif
# 3562 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3563
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3568
::exit(___);}
#if 0
# 3563
{ 
# 3564
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3565
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3567
return w.x; 
# 3568
} 
#endif
# 3570 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3571
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3576
::exit(___);}
#if 0
# 3571
{ 
# 3572
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3573
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3575
return make_float1(w.x); 
# 3576
} 
#endif
# 3578 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3579
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3584
::exit(___);}
#if 0
# 3579
{ 
# 3580
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3581
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3583
return make_float1(w.x); 
# 3584
} 
#endif
# 3586 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3587
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3592
::exit(___);}
#if 0
# 3587
{ 
# 3588
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3589
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3591
return make_float2(w.x, w.y); 
# 3592
} 
#endif
# 3594 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3595
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3600
::exit(___);}
#if 0
# 3595
{ 
# 3596
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3597
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3599
return make_float2(w.x, w.y); 
# 3600
} 
#endif
# 3602 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3603
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3608
::exit(___);}
#if 0
# 3603
{ 
# 3604
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3605
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3607
return make_float4(w.x, w.y, w.z, w.w); 
# 3608
} 
#endif
# 3610 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3611
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3616
::exit(___);}
#if 0
# 3611
{ 
# 3612
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3613
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3615
return make_float4(w.x, w.y, w.z, w.w); 
# 3616
} 
#endif
# 3624 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3625
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3630
::exit(___);}
#if 0
# 3625
{ 
# 3626
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3627
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3629
return w.x; 
# 3630
} 
#endif
# 3632 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayered(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3638
::exit(___);}
#if 0
# 3633
{ 
# 3634
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3635
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3637
return w.x; 
# 3638
} 
#endif
# 3640 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3641
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3646
::exit(___);}
#if 0
# 3641
{ 
# 3642
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3643
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3645
return make_float1(w.x); 
# 3646
} 
#endif
# 3648 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayered(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3649
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3654
::exit(___);}
#if 0
# 3649
{ 
# 3650
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3651
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3653
return make_float1(w.x); 
# 3654
} 
#endif
# 3656 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3657
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3662
::exit(___);}
#if 0
# 3657
{ 
# 3658
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3659
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3661
return make_float2(w.x, w.y); 
# 3662
} 
#endif
# 3664 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayered(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3665
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3670
::exit(___);}
#if 0
# 3665
{ 
# 3666
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3667
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3669
return make_float2(w.x, w.y); 
# 3670
} 
#endif
# 3672 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3678
::exit(___);}
#if 0
# 3673
{ 
# 3674
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3675
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3677
return make_float4(w.x, w.y, w.z, w.w); 
# 3678
} 
#endif
# 3680 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayered(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 3681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 3686
::exit(___);}
#if 0
# 3681
{ 
# 3682
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
# 3683
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 3685
return make_float4(w.x, w.y, w.z, w.w); 
# 3686
} 
#endif
# 3807 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3808
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3810
::exit(___);}
#if 0
# 3808
{ 
# 3809
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
# 3810
} 
#endif
# 3812 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3813
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3815
::exit(___);}
#if 0
# 3813
{ 
# 3814
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
# 3815
} 
#endif
# 3817 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3818
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3820
::exit(___);}
#if 0
# 3818
{ 
# 3819
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } ; 
# 3820
} 
#endif
# 3822 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3823
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3825
::exit(___);}
#if 0
# 3823
{ 
# 3824
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
# 3825
} 
#endif
# 3827 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3828
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3830
::exit(___);}
#if 0
# 3828
{ 
# 3829
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } ; 
# 3830
} 
#endif
# 3832 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3833
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3835
::exit(___);}
#if 0
# 3833
{ 
# 3834
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  ; 
# 3835
} 
#endif
# 3837 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3838
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3840
::exit(___);}
#if 0
# 3838
{ 
# 3839
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  ; 
# 3840
} 
#endif
# 3842 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3845
::exit(___);}
#if 0
# 3843
{ 
# 3844
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  }  ; 
# 3845
} 
#endif
# 3847 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3848
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3850
::exit(___);}
#if 0
# 3848
{ 
# 3849
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  }  ; 
# 3850
} 
#endif
# 3852 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2Dgather(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3853
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3855
::exit(___);}
#if 0
# 3853
{ 
# 3854
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  }  }  ; 
# 3855
} 
#endif
# 3857 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2Dgather(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3858
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3860
::exit(___);}
#if 0
# 3858
{ 
# 3859
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  }  }  ; 
# 3860
} 
#endif
# 3862 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3863
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3865
::exit(___);}
#if 0
# 3863
{ 
# 3864
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } ; 
# 3865
} 
#endif
# 3867 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3868
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3870
::exit(___);}
#if 0
# 3868
{ 
# 3869
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } ; 
# 3870
} 
#endif
# 3872 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3873
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3875
::exit(___);}
#if 0
# 3873
{ 
# 3874
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } ; 
# 3875
} 
#endif
# 3877 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3878
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3880
::exit(___);}
#if 0
# 3878
{ 
# 3879
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } ; 
# 3880
} 
#endif
# 3882 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3883
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3885
::exit(___);}
#if 0
# 3883
{ 
# 3884
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  ; 
# 3885
} 
#endif
# 3887 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3888
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3890
::exit(___);}
#if 0
# 3888
{ 
# 3889
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  ; 
# 3890
} 
#endif
# 3892 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3893
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3895
::exit(___);}
#if 0
# 3893
{ 
# 3894
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  }  ; 
# 3895
} 
#endif
# 3897 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3900
::exit(___);}
#if 0
# 3898
{ 
# 3899
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  }  ; 
# 3900
} 
#endif
# 3902 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2Dgather(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3903
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3905
::exit(___);}
#if 0
# 3903
{ 
# 3904
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  }  }  ; 
# 3905
} 
#endif
# 3907 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2Dgather(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3908
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3910
::exit(___);}
#if 0
# 3908
{ 
# 3909
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  }  }  ; 
# 3910
} 
#endif
# 3912 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3913
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3915
::exit(___);}
#if 0
# 3913
{ 
# 3914
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3915
} 
#endif
# 3917 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3918
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3920
::exit(___);}
#if 0
# 3918
{ 
# 3919
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3920
} 
#endif
# 3922 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3923
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3925
::exit(___);}
#if 0
# 3923
{ 
# 3924
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3925
} 
#endif
# 3927 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3928
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3930
::exit(___);}
#if 0
# 3928
{ 
# 3929
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3930
} 
#endif
# 3932 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3933
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3935
::exit(___);}
#if 0
# 3933
{ 
# 3934
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
# 3935
} 
#endif
# 3937 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3940
::exit(___);}
#if 0
# 3938
{ 
# 3939
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
# 3940
} 
#endif
# 3942 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3943
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3945
::exit(___);}
#if 0
# 3943
{ 
# 3944
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
# 3945
} 
#endif
# 3947 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3948
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3950
::exit(___);}
#if 0
# 3948
{ 
# 3949
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
# 3950
} 
#endif
# 3952 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2Dgather(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3953
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3955
::exit(___);}
#if 0
# 3953
{ 
# 3954
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
# 3955
} 
#endif
# 3957 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2Dgather(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3958
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3960
::exit(___);}
#if 0
# 3958
{ 
# 3959
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
# 3960
} 
#endif
# 3962 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3963
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3965
::exit(___);}
#if 0
# 3963
{ 
# 3964
{ float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3965
} 
#endif
# 3967 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3968
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3970
::exit(___);}
#if 0
# 3968
{ 
# 3969
{ float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
# 3970
} 
#endif
# 3972 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3973
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3975
::exit(___);}
#if 0
# 3973
{ 
# 3974
if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
# 3975
} 
#endif
# 3977 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3978
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3980
::exit(___);}
#if 0
# 3978
{ 
# 3979
if (comp == 2) { float4 v = __ftex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
# 3980
} 
#endif
# 3982 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 3983
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3985
::exit(___);}
#if 0
# 3983
{ 
# 3984
if (comp == 3) { float4 v = __ftex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { float4 v = __ftex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
# 3985
} 
#endif
# 3994 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 3995
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 3997
::exit(___);}
#if 0
# 3995
{ 
# 3996
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 3997
} 
#endif
# 3999 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4002
::exit(___);}
#if 0
# 4000
{ 
# 4001
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 4002
} 
#endif
# 4004 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4005
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4007
::exit(___);}
#if 0
# 4005
{ 
# 4006
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 4007
} 
#endif
# 4009 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4010
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4012
::exit(___);}
#if 0
# 4010
{ 
# 4011
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 4012
} 
#endif
# 4014 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4015
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4017
::exit(___);}
#if 0
# 4015
{ 
# 4016
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 4017
} 
#endif
# 4019 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4020
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4022
::exit(___);}
#if 0
# 4020
{ 
# 4021
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
# 4022
} 
#endif
# 4024 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4025
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4027
::exit(___);}
#if 0
# 4025
{ 
# 4026
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
# 4027
} 
#endif
# 4029 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4030
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4032
::exit(___);}
#if 0
# 4030
{ 
# 4031
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
# 4032
} 
#endif
# 4034 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4035
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4037
::exit(___);}
#if 0
# 4035
{ 
# 4036
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
# 4037
} 
#endif
# 4039 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4040
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4042
::exit(___);}
#if 0
# 4040
{ 
# 4041
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
# 4042
} 
#endif
# 4044 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4045
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4047
::exit(___);}
#if 0
# 4045
{ 
# 4046
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
# 4047
} 
#endif
# 4049 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4050
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4052
::exit(___);}
#if 0
# 4050
{ 
# 4051
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 4052
} 
#endif
# 4054 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4055
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4057
::exit(___);}
#if 0
# 4055
{ 
# 4056
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 4057
} 
#endif
# 4059 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4060
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4062
::exit(___);}
#if 0
# 4060
{ 
# 4061
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 4062
} 
#endif
# 4064 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4065
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4067
::exit(___);}
#if 0
# 4065
{ 
# 4066
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
# 4067
} 
#endif
# 4069 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4070
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4072
::exit(___);}
#if 0
# 4070
{ 
# 4071
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
# 4072
} 
#endif
# 4074 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4075
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4077
::exit(___);}
#if 0
# 4075
{ 
# 4076
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
# 4077
} 
#endif
# 4079 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4080
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4082
::exit(___);}
#if 0
# 4080
{ 
# 4081
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
# 4082
} 
#endif
# 4084 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4085
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4087
::exit(___);}
#if 0
# 4085
{ 
# 4086
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
# 4087
} 
#endif
# 4089 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4090
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4092
::exit(___);}
#if 0
# 4090
{ 
# 4091
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
# 4092
} 
#endif
# 4094 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2Dgather(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 4095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 4097
::exit(___);}
#if 0
# 4095
{ 
# 4096
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
# 4097
} 
#endif
# 4124 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLod(texture< char, 1, cudaReadModeElementType>  t, float x, float level) 
# 4125
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4133
::exit(___);}
#if 0
# 4125
{ 
# 4129
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4132
return (char)(v.x); 
# 4133
} 
#endif
# 4135 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLod(texture< signed char, 1, cudaReadModeElementType>  t, float x, float level) 
# 4136
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4140
::exit(___);}
#if 0
# 4136
{ 
# 4137
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4139
return (signed char)(v.x); 
# 4140
} 
#endif
# 4142 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLod(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float level) 
# 4143
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4147
::exit(___);}
#if 0
# 4143
{ 
# 4144
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4146
return (unsigned char)(v.x); 
# 4147
} 
#endif
# 4149 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLod(texture< char1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4150
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4154
::exit(___);}
#if 0
# 4150
{ 
# 4151
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4153
return make_char1(v.x); 
# 4154
} 
#endif
# 4156 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLod(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4157
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4161
::exit(___);}
#if 0
# 4157
{ 
# 4158
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4160
return make_uchar1(v.x); 
# 4161
} 
#endif
# 4163 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLod(texture< char2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4164
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4168
::exit(___);}
#if 0
# 4164
{ 
# 4165
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4167
return make_char2(v.x, v.y); 
# 4168
} 
#endif
# 4170 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLod(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4171
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4175
::exit(___);}
#if 0
# 4171
{ 
# 4172
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4174
return make_uchar2(v.x, v.y); 
# 4175
} 
#endif
# 4177 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLod(texture< char4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4178
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4182
::exit(___);}
#if 0
# 4178
{ 
# 4179
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4181
return make_char4(v.x, v.y, v.z, v.w); 
# 4182
} 
#endif
# 4184 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLod(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4185
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4189
::exit(___);}
#if 0
# 4185
{ 
# 4186
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4188
return make_uchar4(v.x, v.y, v.z, v.w); 
# 4189
} 
#endif
# 4197 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLod(texture< short, 1, cudaReadModeElementType>  t, float x, float level) 
# 4198
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4202
::exit(___);}
#if 0
# 4198
{ 
# 4199
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4201
return (short)(v.x); 
# 4202
} 
#endif
# 4204 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLod(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float level) 
# 4205
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4209
::exit(___);}
#if 0
# 4205
{ 
# 4206
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4208
return (unsigned short)(v.x); 
# 4209
} 
#endif
# 4211 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLod(texture< short1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4212
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4216
::exit(___);}
#if 0
# 4212
{ 
# 4213
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4215
return make_short1(v.x); 
# 4216
} 
#endif
# 4218 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLod(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4219
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4223
::exit(___);}
#if 0
# 4219
{ 
# 4220
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4222
return make_ushort1(v.x); 
# 4223
} 
#endif
# 4225 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLod(texture< short2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4226
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4230
::exit(___);}
#if 0
# 4226
{ 
# 4227
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4229
return make_short2(v.x, v.y); 
# 4230
} 
#endif
# 4232 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLod(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4233
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4237
::exit(___);}
#if 0
# 4233
{ 
# 4234
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4236
return make_ushort2(v.x, v.y); 
# 4237
} 
#endif
# 4239 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLod(texture< short4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4240
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4244
::exit(___);}
#if 0
# 4240
{ 
# 4241
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4243
return make_short4(v.x, v.y, v.z, v.w); 
# 4244
} 
#endif
# 4246 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLod(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4247
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4251
::exit(___);}
#if 0
# 4247
{ 
# 4248
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4250
return make_ushort4(v.x, v.y, v.z, v.w); 
# 4251
} 
#endif
# 4259 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLod(texture< int, 1, cudaReadModeElementType>  t, float x, float level) 
# 4260
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4264
::exit(___);}
#if 0
# 4260
{ 
# 4261
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4263
return (int)(v.x); 
# 4264
} 
#endif
# 4266 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLod(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float level) 
# 4267
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4271
::exit(___);}
#if 0
# 4267
{ 
# 4268
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4270
return (unsigned)(v.x); 
# 4271
} 
#endif
# 4273 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLod(texture< int1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4274
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4278
::exit(___);}
#if 0
# 4274
{ 
# 4275
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4277
return make_int1(v.x); 
# 4278
} 
#endif
# 4280 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLod(texture< uint1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4281
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4285
::exit(___);}
#if 0
# 4281
{ 
# 4282
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4284
return make_uint1(v.x); 
# 4285
} 
#endif
# 4287 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLod(texture< int2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4288
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4292
::exit(___);}
#if 0
# 4288
{ 
# 4289
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4291
return make_int2(v.x, v.y); 
# 4292
} 
#endif
# 4294 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLod(texture< uint2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4295
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4299
::exit(___);}
#if 0
# 4295
{ 
# 4296
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4298
return make_uint2(v.x, v.y); 
# 4299
} 
#endif
# 4301 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLod(texture< int4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4302
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4306
::exit(___);}
#if 0
# 4302
{ 
# 4303
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4305
return make_int4(v.x, v.y, v.z, v.w); 
# 4306
} 
#endif
# 4308 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLod(texture< uint4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4309
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4313
::exit(___);}
#if 0
# 4309
{ 
# 4310
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4312
return make_uint4(v.x, v.y, v.z, v.w); 
# 4313
} 
#endif
# 4393 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< float, 1, cudaReadModeElementType>  t, float x, float level) 
# 4394
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4398
::exit(___);}
#if 0
# 4394
{ 
# 4395
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4397
return v.x; 
# 4398
} 
#endif
# 4400 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< float1, 1, cudaReadModeElementType>  t, float x, float level) 
# 4401
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4405
::exit(___);}
#if 0
# 4401
{ 
# 4402
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4404
return make_float1(v.x); 
# 4405
} 
#endif
# 4407 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< float2, 1, cudaReadModeElementType>  t, float x, float level) 
# 4408
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4412
::exit(___);}
#if 0
# 4408
{ 
# 4409
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4411
return make_float2(v.x, v.y); 
# 4412
} 
#endif
# 4414 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< float4, 1, cudaReadModeElementType>  t, float x, float level) 
# 4415
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4419
::exit(___);}
#if 0
# 4415
{ 
# 4416
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4418
return make_float4(v.x, v.y, v.z, v.w); 
# 4419
} 
#endif
# 4427 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4428
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4437
::exit(___);}
#if 0
# 4428
{ 
# 4432
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4434
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4436
return w.x; 
# 4437
} 
#endif
# 4439 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4440
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4445
::exit(___);}
#if 0
# 4440
{ 
# 4441
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4442
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4444
return w.x; 
# 4445
} 
#endif
# 4447 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4448
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4453
::exit(___);}
#if 0
# 4448
{ 
# 4449
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4450
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4452
return w.x; 
# 4453
} 
#endif
# 4455 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4456
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4461
::exit(___);}
#if 0
# 4456
{ 
# 4457
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4458
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4460
return make_float1(w.x); 
# 4461
} 
#endif
# 4463 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4464
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4469
::exit(___);}
#if 0
# 4464
{ 
# 4465
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4466
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4468
return make_float1(w.x); 
# 4469
} 
#endif
# 4471 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4472
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4477
::exit(___);}
#if 0
# 4472
{ 
# 4473
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4474
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4476
return make_float2(w.x, w.y); 
# 4477
} 
#endif
# 4479 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4480
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4485
::exit(___);}
#if 0
# 4480
{ 
# 4481
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4482
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4484
return make_float2(w.x, w.y); 
# 4485
} 
#endif
# 4487 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4488
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4493
::exit(___);}
#if 0
# 4488
{ 
# 4489
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4490
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4492
return make_float4(w.x, w.y, w.z, w.w); 
# 4493
} 
#endif
# 4495 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4496
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4501
::exit(___);}
#if 0
# 4496
{ 
# 4497
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4498
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4500
return make_float4(w.x, w.y, w.z, w.w); 
# 4501
} 
#endif
# 4509 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4510
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4515
::exit(___);}
#if 0
# 4510
{ 
# 4511
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4512
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4514
return w.x; 
# 4515
} 
#endif
# 4517 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLod(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4518
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4523
::exit(___);}
#if 0
# 4518
{ 
# 4519
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4520
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4522
return w.x; 
# 4523
} 
#endif
# 4525 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4526
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4531
::exit(___);}
#if 0
# 4526
{ 
# 4527
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4528
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4530
return make_float1(w.x); 
# 4531
} 
#endif
# 4533 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLod(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4534
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4539
::exit(___);}
#if 0
# 4534
{ 
# 4535
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4536
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4538
return make_float1(w.x); 
# 4539
} 
#endif
# 4541 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4542
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4547
::exit(___);}
#if 0
# 4542
{ 
# 4543
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4544
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4546
return make_float2(w.x, w.y); 
# 4547
} 
#endif
# 4549 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLod(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4550
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4555
::exit(___);}
#if 0
# 4550
{ 
# 4551
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4552
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4554
return make_float2(w.x, w.y); 
# 4555
} 
#endif
# 4557 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4558
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4563
::exit(___);}
#if 0
# 4558
{ 
# 4559
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4560
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4562
return make_float4(w.x, w.y, w.z, w.w); 
# 4563
} 
#endif
# 4565 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLod(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 4566
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 4571
::exit(___);}
#if 0
# 4566
{ 
# 4567
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
# 4568
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4570
return make_float4(w.x, w.y, w.z, w.w); 
# 4571
} 
#endif
# 4579 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLod(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4580
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4588
::exit(___);}
#if 0
# 4580
{ 
# 4584
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4587
return (char)(v.x); 
# 4588
} 
#endif
# 4590 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLod(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4591
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4595
::exit(___);}
#if 0
# 4591
{ 
# 4592
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4594
return (signed char)(v.x); 
# 4595
} 
#endif
# 4597 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLod(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4598
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4602
::exit(___);}
#if 0
# 4598
{ 
# 4599
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4601
return (unsigned char)(v.x); 
# 4602
} 
#endif
# 4604 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLod(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4605
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4609
::exit(___);}
#if 0
# 4605
{ 
# 4606
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4608
return make_char1(v.x); 
# 4609
} 
#endif
# 4611 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLod(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4612
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4616
::exit(___);}
#if 0
# 4612
{ 
# 4613
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4615
return make_uchar1(v.x); 
# 4616
} 
#endif
# 4618 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLod(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4619
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4623
::exit(___);}
#if 0
# 4619
{ 
# 4620
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4622
return make_char2(v.x, v.y); 
# 4623
} 
#endif
# 4625 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLod(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4626
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4630
::exit(___);}
#if 0
# 4626
{ 
# 4627
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4629
return make_uchar2(v.x, v.y); 
# 4630
} 
#endif
# 4632 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLod(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4637
::exit(___);}
#if 0
# 4633
{ 
# 4634
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4636
return make_char4(v.x, v.y, v.z, v.w); 
# 4637
} 
#endif
# 4639 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLod(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4640
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4644
::exit(___);}
#if 0
# 4640
{ 
# 4641
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4643
return make_uchar4(v.x, v.y, v.z, v.w); 
# 4644
} 
#endif
# 4652 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLod(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4653
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4657
::exit(___);}
#if 0
# 4653
{ 
# 4654
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4656
return (short)(v.x); 
# 4657
} 
#endif
# 4659 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLod(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4664
::exit(___);}
#if 0
# 4660
{ 
# 4661
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4663
return (unsigned short)(v.x); 
# 4664
} 
#endif
# 4666 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLod(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4667
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4671
::exit(___);}
#if 0
# 4667
{ 
# 4668
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4670
return make_short1(v.x); 
# 4671
} 
#endif
# 4673 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLod(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4674
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4678
::exit(___);}
#if 0
# 4674
{ 
# 4675
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4677
return make_ushort1(v.x); 
# 4678
} 
#endif
# 4680 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLod(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4685
::exit(___);}
#if 0
# 4681
{ 
# 4682
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4684
return make_short2(v.x, v.y); 
# 4685
} 
#endif
# 4687 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLod(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4688
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4692
::exit(___);}
#if 0
# 4688
{ 
# 4689
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4691
return make_ushort2(v.x, v.y); 
# 4692
} 
#endif
# 4694 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLod(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4695
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4699
::exit(___);}
#if 0
# 4695
{ 
# 4696
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4698
return make_short4(v.x, v.y, v.z, v.w); 
# 4699
} 
#endif
# 4701 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLod(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4702
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4706
::exit(___);}
#if 0
# 4702
{ 
# 4703
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4705
return make_ushort4(v.x, v.y, v.z, v.w); 
# 4706
} 
#endif
# 4714 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLod(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4715
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4719
::exit(___);}
#if 0
# 4715
{ 
# 4716
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4718
return (int)(v.x); 
# 4719
} 
#endif
# 4721 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLod(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4722
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4726
::exit(___);}
#if 0
# 4722
{ 
# 4723
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4725
return (unsigned)(v.x); 
# 4726
} 
#endif
# 4728 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLod(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4729
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4733
::exit(___);}
#if 0
# 4729
{ 
# 4730
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4732
return make_int1(v.x); 
# 4733
} 
#endif
# 4735 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLod(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4736
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4740
::exit(___);}
#if 0
# 4736
{ 
# 4737
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4739
return make_uint1(v.x); 
# 4740
} 
#endif
# 4742 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLod(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4743
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4747
::exit(___);}
#if 0
# 4743
{ 
# 4744
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4746
return make_int2(v.x, v.y); 
# 4747
} 
#endif
# 4749 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLod(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4750
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4754
::exit(___);}
#if 0
# 4750
{ 
# 4751
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4753
return make_uint2(v.x, v.y); 
# 4754
} 
#endif
# 4756 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLod(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4757
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4761
::exit(___);}
#if 0
# 4757
{ 
# 4758
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4760
return make_int4(v.x, v.y, v.z, v.w); 
# 4761
} 
#endif
# 4763 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLod(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4764
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4768
::exit(___);}
#if 0
# 4764
{ 
# 4765
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4767
return make_uint4(v.x, v.y, v.z, v.w); 
# 4768
} 
#endif
# 4842 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4847
::exit(___);}
#if 0
# 4843
{ 
# 4844
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4846
return v.x; 
# 4847
} 
#endif
# 4849 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4854
::exit(___);}
#if 0
# 4850
{ 
# 4851
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4853
return make_float1(v.x); 
# 4854
} 
#endif
# 4856 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4861
::exit(___);}
#if 0
# 4857
{ 
# 4858
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4860
return make_float2(v.x, v.y); 
# 4861
} 
#endif
# 4863 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 4864
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4868
::exit(___);}
#if 0
# 4864
{ 
# 4865
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4867
return make_float4(v.x, v.y, v.z, v.w); 
# 4868
} 
#endif
# 4876 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4877
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4886
::exit(___);}
#if 0
# 4877
{ 
# 4881
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4883
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4885
return w.x; 
# 4886
} 
#endif
# 4888 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4889
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4894
::exit(___);}
#if 0
# 4889
{ 
# 4890
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4891
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4893
return w.x; 
# 4894
} 
#endif
# 4896 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4897
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4902
::exit(___);}
#if 0
# 4897
{ 
# 4898
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4899
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4901
return w.x; 
# 4902
} 
#endif
# 4904 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4910
::exit(___);}
#if 0
# 4905
{ 
# 4906
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4907
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4909
return make_float1(w.x); 
# 4910
} 
#endif
# 4912 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4913
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4918
::exit(___);}
#if 0
# 4913
{ 
# 4914
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4915
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4917
return make_float1(w.x); 
# 4918
} 
#endif
# 4920 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4921
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4926
::exit(___);}
#if 0
# 4921
{ 
# 4922
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4923
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4925
return make_float2(w.x, w.y); 
# 4926
} 
#endif
# 4928 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4929
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4934
::exit(___);}
#if 0
# 4929
{ 
# 4930
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4931
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4933
return make_float2(w.x, w.y); 
# 4934
} 
#endif
# 4936 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4937
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4942
::exit(___);}
#if 0
# 4937
{ 
# 4938
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4939
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4941
return make_float4(w.x, w.y, w.z, w.w); 
# 4942
} 
#endif
# 4944 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4945
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4950
::exit(___);}
#if 0
# 4945
{ 
# 4946
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4947
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4949
return make_float4(w.x, w.y, w.z, w.w); 
# 4950
} 
#endif
# 4958 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4959
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4964
::exit(___);}
#if 0
# 4959
{ 
# 4960
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4961
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4963
return w.x; 
# 4964
} 
#endif
# 4966 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLod(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4967
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4972
::exit(___);}
#if 0
# 4967
{ 
# 4968
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4969
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4971
return w.x; 
# 4972
} 
#endif
# 4974 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4975
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4980
::exit(___);}
#if 0
# 4975
{ 
# 4976
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4977
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4979
return make_float1(w.x); 
# 4980
} 
#endif
# 4982 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLod(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4983
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4988
::exit(___);}
#if 0
# 4983
{ 
# 4984
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4985
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4987
return make_float1(w.x); 
# 4988
} 
#endif
# 4990 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4991
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 4996
::exit(___);}
#if 0
# 4991
{ 
# 4992
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 4993
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 4995
return make_float2(w.x, w.y); 
# 4996
} 
#endif
# 4998 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLod(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 4999
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 5004
::exit(___);}
#if 0
# 4999
{ 
# 5000
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 5001
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5003
return make_float2(w.x, w.y); 
# 5004
} 
#endif
# 5006 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 5007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 5012
::exit(___);}
#if 0
# 5007
{ 
# 5008
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 5009
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5011
return make_float4(w.x, w.y, w.z, w.w); 
# 5012
} 
#endif
# 5014 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLod(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 5015
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 5020
::exit(___);}
#if 0
# 5015
{ 
# 5016
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
# 5017
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5019
return make_float4(w.x, w.y, w.z, w.w); 
# 5020
} 
#endif
# 5028 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLayeredLod(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5029
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5037
::exit(___);}
#if 0
# 5029
{ 
# 5033
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5036
return (char)(v.x); 
# 5037
} 
#endif
# 5039 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLayeredLod(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5040
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5044
::exit(___);}
#if 0
# 5040
{ 
# 5041
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5043
return (signed char)(v.x); 
# 5044
} 
#endif
# 5046 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5047
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5051
::exit(___);}
#if 0
# 5047
{ 
# 5048
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5050
return (unsigned char)(v.x); 
# 5051
} 
#endif
# 5053 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLayeredLod(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5054
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5058
::exit(___);}
#if 0
# 5054
{ 
# 5055
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5057
return make_char1(v.x); 
# 5058
} 
#endif
# 5060 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5061
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5065
::exit(___);}
#if 0
# 5061
{ 
# 5062
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5064
return make_uchar1(v.x); 
# 5065
} 
#endif
# 5067 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLayeredLod(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5068
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5072
::exit(___);}
#if 0
# 5068
{ 
# 5069
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5071
return make_char2(v.x, v.y); 
# 5072
} 
#endif
# 5074 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5075
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5079
::exit(___);}
#if 0
# 5075
{ 
# 5076
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5078
return make_uchar2(v.x, v.y); 
# 5079
} 
#endif
# 5081 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLayeredLod(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5082
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5086
::exit(___);}
#if 0
# 5082
{ 
# 5083
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5085
return make_char4(v.x, v.y, v.z, v.w); 
# 5086
} 
#endif
# 5088 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5089
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5093
::exit(___);}
#if 0
# 5089
{ 
# 5090
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5092
return make_uchar4(v.x, v.y, v.z, v.w); 
# 5093
} 
#endif
# 5101 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLayeredLod(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5102
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5106
::exit(___);}
#if 0
# 5102
{ 
# 5103
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5105
return (short)(v.x); 
# 5106
} 
#endif
# 5108 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5109
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5113
::exit(___);}
#if 0
# 5109
{ 
# 5110
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5112
return (unsigned short)(v.x); 
# 5113
} 
#endif
# 5115 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLayeredLod(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5116
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5120
::exit(___);}
#if 0
# 5116
{ 
# 5117
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5119
return make_short1(v.x); 
# 5120
} 
#endif
# 5122 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5123
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5127
::exit(___);}
#if 0
# 5123
{ 
# 5124
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5126
return make_ushort1(v.x); 
# 5127
} 
#endif
# 5129 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLayeredLod(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5130
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5134
::exit(___);}
#if 0
# 5130
{ 
# 5131
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5133
return make_short2(v.x, v.y); 
# 5134
} 
#endif
# 5136 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5137
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5141
::exit(___);}
#if 0
# 5137
{ 
# 5138
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5140
return make_ushort2(v.x, v.y); 
# 5141
} 
#endif
# 5143 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLayeredLod(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5144
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5148
::exit(___);}
#if 0
# 5144
{ 
# 5145
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5147
return make_short4(v.x, v.y, v.z, v.w); 
# 5148
} 
#endif
# 5150 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5151
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5155
::exit(___);}
#if 0
# 5151
{ 
# 5152
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5154
return make_ushort4(v.x, v.y, v.z, v.w); 
# 5155
} 
#endif
# 5163 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLayeredLod(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5164
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5168
::exit(___);}
#if 0
# 5164
{ 
# 5165
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5167
return (int)(v.x); 
# 5168
} 
#endif
# 5170 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLayeredLod(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5171
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5175
::exit(___);}
#if 0
# 5171
{ 
# 5172
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5174
return (unsigned)(v.x); 
# 5175
} 
#endif
# 5177 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLayeredLod(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5178
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5182
::exit(___);}
#if 0
# 5178
{ 
# 5179
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5181
return make_int1(v.x); 
# 5182
} 
#endif
# 5184 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLayeredLod(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5185
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5189
::exit(___);}
#if 0
# 5185
{ 
# 5186
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5188
return make_uint1(v.x); 
# 5189
} 
#endif
# 5191 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLayeredLod(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5192
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5196
::exit(___);}
#if 0
# 5192
{ 
# 5193
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5195
return make_int2(v.x, v.y); 
# 5196
} 
#endif
# 5198 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLayeredLod(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5199
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5203
::exit(___);}
#if 0
# 5199
{ 
# 5200
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5202
return make_uint2(v.x, v.y); 
# 5203
} 
#endif
# 5205 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLayeredLod(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5206
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5210
::exit(___);}
#if 0
# 5206
{ 
# 5207
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5209
return make_int4(v.x, v.y, v.z, v.w); 
# 5210
} 
#endif
# 5212 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLayeredLod(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5213
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5217
::exit(___);}
#if 0
# 5213
{ 
# 5214
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5216
return make_uint4(v.x, v.y, v.z, v.w); 
# 5217
} 
#endif
# 5291 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5292
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5296
::exit(___);}
#if 0
# 5292
{ 
# 5293
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5295
return v.x; 
# 5296
} 
#endif
# 5298 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5299
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5303
::exit(___);}
#if 0
# 5299
{ 
# 5300
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5302
return make_float1(v.x); 
# 5303
} 
#endif
# 5305 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5306
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5310
::exit(___);}
#if 0
# 5306
{ 
# 5307
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5309
return make_float2(v.x, v.y); 
# 5310
} 
#endif
# 5312 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 5313
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5317
::exit(___);}
#if 0
# 5313
{ 
# 5314
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5316
return make_float4(v.x, v.y, v.z, v.w); 
# 5317
} 
#endif
# 5325 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5326
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5335
::exit(___);}
#if 0
# 5326
{ 
# 5330
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5332
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5334
return w.x; 
# 5335
} 
#endif
# 5337 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5338
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5343
::exit(___);}
#if 0
# 5338
{ 
# 5339
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5340
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5342
return w.x; 
# 5343
} 
#endif
# 5345 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5346
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5351
::exit(___);}
#if 0
# 5346
{ 
# 5347
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5348
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5350
return w.x; 
# 5351
} 
#endif
# 5353 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5354
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5359
::exit(___);}
#if 0
# 5354
{ 
# 5355
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5356
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5358
return make_float1(w.x); 
# 5359
} 
#endif
# 5361 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5362
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5367
::exit(___);}
#if 0
# 5362
{ 
# 5363
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5364
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5366
return make_float1(w.x); 
# 5367
} 
#endif
# 5369 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5370
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5375
::exit(___);}
#if 0
# 5370
{ 
# 5371
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5372
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5374
return make_float2(w.x, w.y); 
# 5375
} 
#endif
# 5377 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5378
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5383
::exit(___);}
#if 0
# 5378
{ 
# 5379
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5380
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5382
return make_float2(w.x, w.y); 
# 5383
} 
#endif
# 5385 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5386
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5391
::exit(___);}
#if 0
# 5386
{ 
# 5387
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5388
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5390
return make_float4(w.x, w.y, w.z, w.w); 
# 5391
} 
#endif
# 5393 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5394
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5399
::exit(___);}
#if 0
# 5394
{ 
# 5395
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5396
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5398
return make_float4(w.x, w.y, w.z, w.w); 
# 5399
} 
#endif
# 5407 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5408
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5413
::exit(___);}
#if 0
# 5408
{ 
# 5409
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5410
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5412
return w.x; 
# 5413
} 
#endif
# 5415 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5416
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5421
::exit(___);}
#if 0
# 5416
{ 
# 5417
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5418
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5420
return w.x; 
# 5421
} 
#endif
# 5423 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5424
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5429
::exit(___);}
#if 0
# 5424
{ 
# 5425
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5426
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5428
return make_float1(w.x); 
# 5429
} 
#endif
# 5431 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5432
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5437
::exit(___);}
#if 0
# 5432
{ 
# 5433
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5434
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5436
return make_float1(w.x); 
# 5437
} 
#endif
# 5439 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5440
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5445
::exit(___);}
#if 0
# 5440
{ 
# 5441
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5442
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5444
return make_float2(w.x, w.y); 
# 5445
} 
#endif
# 5447 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5448
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5453
::exit(___);}
#if 0
# 5448
{ 
# 5449
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5450
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5452
return make_float2(w.x, w.y); 
# 5453
} 
#endif
# 5455 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5456
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5461
::exit(___);}
#if 0
# 5456
{ 
# 5457
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5458
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5460
return make_float4(w.x, w.y, w.z, w.w); 
# 5461
} 
#endif
# 5463 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 5464
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 5469
::exit(___);}
#if 0
# 5464
{ 
# 5465
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
# 5466
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5468
return make_float4(w.x, w.y, w.z, w.w); 
# 5469
} 
#endif
# 5477 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLayeredLod(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5478
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5486
::exit(___);}
#if 0
# 5478
{ 
# 5482
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5485
return (char)(v.x); 
# 5486
} 
#endif
# 5488 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLayeredLod(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5489
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5493
::exit(___);}
#if 0
# 5489
{ 
# 5490
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5492
return (signed char)(v.x); 
# 5493
} 
#endif
# 5495 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5496
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5500
::exit(___);}
#if 0
# 5496
{ 
# 5497
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5499
return (unsigned char)(v.x); 
# 5500
} 
#endif
# 5502 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLayeredLod(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5503
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5507
::exit(___);}
#if 0
# 5503
{ 
# 5504
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5506
return make_char1(v.x); 
# 5507
} 
#endif
# 5509 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5510
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5514
::exit(___);}
#if 0
# 5510
{ 
# 5511
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5513
return make_uchar1(v.x); 
# 5514
} 
#endif
# 5516 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLayeredLod(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5517
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5521
::exit(___);}
#if 0
# 5517
{ 
# 5518
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5520
return make_char2(v.x, v.y); 
# 5521
} 
#endif
# 5523 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5524
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5528
::exit(___);}
#if 0
# 5524
{ 
# 5525
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5527
return make_uchar2(v.x, v.y); 
# 5528
} 
#endif
# 5530 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLayeredLod(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5531
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5535
::exit(___);}
#if 0
# 5531
{ 
# 5532
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5534
return make_char4(v.x, v.y, v.z, v.w); 
# 5535
} 
#endif
# 5537 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5538
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5542
::exit(___);}
#if 0
# 5538
{ 
# 5539
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5541
return make_uchar4(v.x, v.y, v.z, v.w); 
# 5542
} 
#endif
# 5550 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLayeredLod(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5551
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5555
::exit(___);}
#if 0
# 5551
{ 
# 5552
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5554
return (short)(v.x); 
# 5555
} 
#endif
# 5557 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5558
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5562
::exit(___);}
#if 0
# 5558
{ 
# 5559
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5561
return (unsigned short)(v.x); 
# 5562
} 
#endif
# 5564 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLayeredLod(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5565
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5569
::exit(___);}
#if 0
# 5565
{ 
# 5566
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5568
return make_short1(v.x); 
# 5569
} 
#endif
# 5571 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5572
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5576
::exit(___);}
#if 0
# 5572
{ 
# 5573
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5575
return make_ushort1(v.x); 
# 5576
} 
#endif
# 5578 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLayeredLod(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5579
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5583
::exit(___);}
#if 0
# 5579
{ 
# 5580
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5582
return make_short2(v.x, v.y); 
# 5583
} 
#endif
# 5585 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5586
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5590
::exit(___);}
#if 0
# 5586
{ 
# 5587
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5589
return make_ushort2(v.x, v.y); 
# 5590
} 
#endif
# 5592 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLayeredLod(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5593
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5597
::exit(___);}
#if 0
# 5593
{ 
# 5594
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5596
return make_short4(v.x, v.y, v.z, v.w); 
# 5597
} 
#endif
# 5599 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5600
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5604
::exit(___);}
#if 0
# 5600
{ 
# 5601
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5603
return make_ushort4(v.x, v.y, v.z, v.w); 
# 5604
} 
#endif
# 5612 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLayeredLod(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5613
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5617
::exit(___);}
#if 0
# 5613
{ 
# 5614
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5616
return (int)(v.x); 
# 5617
} 
#endif
# 5619 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLayeredLod(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5620
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5624
::exit(___);}
#if 0
# 5620
{ 
# 5621
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5623
return (unsigned)(v.x); 
# 5624
} 
#endif
# 5626 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLayeredLod(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5627
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5631
::exit(___);}
#if 0
# 5627
{ 
# 5628
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5630
return make_int1(v.x); 
# 5631
} 
#endif
# 5633 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLayeredLod(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5634
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5638
::exit(___);}
#if 0
# 5634
{ 
# 5635
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5637
return make_uint1(v.x); 
# 5638
} 
#endif
# 5640 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLayeredLod(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5641
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5645
::exit(___);}
#if 0
# 5641
{ 
# 5642
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5644
return make_int2(v.x, v.y); 
# 5645
} 
#endif
# 5647 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLayeredLod(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5648
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5652
::exit(___);}
#if 0
# 5648
{ 
# 5649
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5651
return make_uint2(v.x, v.y); 
# 5652
} 
#endif
# 5654 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLayeredLod(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5655
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5659
::exit(___);}
#if 0
# 5655
{ 
# 5656
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5658
return make_int4(v.x, v.y, v.z, v.w); 
# 5659
} 
#endif
# 5661 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLayeredLod(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5662
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5666
::exit(___);}
#if 0
# 5662
{ 
# 5663
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5665
return make_uint4(v.x, v.y, v.z, v.w); 
# 5666
} 
#endif
# 5740 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5741
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5745
::exit(___);}
#if 0
# 5741
{ 
# 5742
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5744
return v.x; 
# 5745
} 
#endif
# 5747 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5748
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5752
::exit(___);}
#if 0
# 5748
{ 
# 5749
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5751
return make_float1(v.x); 
# 5752
} 
#endif
# 5754 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5755
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5759
::exit(___);}
#if 0
# 5755
{ 
# 5756
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5758
return make_float2(v.x, v.y); 
# 5759
} 
#endif
# 5761 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 5762
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5766
::exit(___);}
#if 0
# 5762
{ 
# 5763
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5765
return make_float4(v.x, v.y, v.z, v.w); 
# 5766
} 
#endif
# 5774 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5775
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5784
::exit(___);}
#if 0
# 5775
{ 
# 5779
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5781
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5783
return w.x; 
# 5784
} 
#endif
# 5786 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5787
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5792
::exit(___);}
#if 0
# 5787
{ 
# 5788
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5789
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5791
return w.x; 
# 5792
} 
#endif
# 5794 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5795
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5800
::exit(___);}
#if 0
# 5795
{ 
# 5796
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5797
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5799
return w.x; 
# 5800
} 
#endif
# 5802 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5803
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5808
::exit(___);}
#if 0
# 5803
{ 
# 5804
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5805
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5807
return make_float1(w.x); 
# 5808
} 
#endif
# 5810 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5811
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5816
::exit(___);}
#if 0
# 5811
{ 
# 5812
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5813
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5815
return make_float1(w.x); 
# 5816
} 
#endif
# 5818 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5819
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5824
::exit(___);}
#if 0
# 5819
{ 
# 5820
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5821
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5823
return make_float2(w.x, w.y); 
# 5824
} 
#endif
# 5826 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5827
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5832
::exit(___);}
#if 0
# 5827
{ 
# 5828
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5829
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5831
return make_float2(w.x, w.y); 
# 5832
} 
#endif
# 5834 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5835
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5840
::exit(___);}
#if 0
# 5835
{ 
# 5836
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5837
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5839
return make_float4(w.x, w.y, w.z, w.w); 
# 5840
} 
#endif
# 5842 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5848
::exit(___);}
#if 0
# 5843
{ 
# 5844
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5845
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5847
return make_float4(w.x, w.y, w.z, w.w); 
# 5848
} 
#endif
# 5856 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5862
::exit(___);}
#if 0
# 5857
{ 
# 5858
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5859
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5861
return w.x; 
# 5862
} 
#endif
# 5864 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5865
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5870
::exit(___);}
#if 0
# 5865
{ 
# 5866
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5867
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5869
return w.x; 
# 5870
} 
#endif
# 5872 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5873
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5878
::exit(___);}
#if 0
# 5873
{ 
# 5874
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5875
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5877
return make_float1(w.x); 
# 5878
} 
#endif
# 5880 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5881
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5886
::exit(___);}
#if 0
# 5881
{ 
# 5882
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5883
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5885
return make_float1(w.x); 
# 5886
} 
#endif
# 5888 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5889
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5894
::exit(___);}
#if 0
# 5889
{ 
# 5890
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5891
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5893
return make_float2(w.x, w.y); 
# 5894
} 
#endif
# 5896 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5897
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5902
::exit(___);}
#if 0
# 5897
{ 
# 5898
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5899
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5901
return make_float2(w.x, w.y); 
# 5902
} 
#endif
# 5904 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5910
::exit(___);}
#if 0
# 5905
{ 
# 5906
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5907
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5909
return make_float4(w.x, w.y, w.z, w.w); 
# 5910
} 
#endif
# 5912 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 5913
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 5918
::exit(___);}
#if 0
# 5913
{ 
# 5914
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
# 5915
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 5917
return make_float4(w.x, w.y, w.z, w.w); 
# 5918
} 
#endif
# 5926 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex3DLod(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5927
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5935
::exit(___);}
#if 0
# 5927
{ 
# 5931
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5934
return (char)(v.x); 
# 5935
} 
#endif
# 5937 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex3DLod(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5942
::exit(___);}
#if 0
# 5938
{ 
# 5939
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5941
return (signed char)(v.x); 
# 5942
} 
#endif
# 5944 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex3DLod(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5945
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5949
::exit(___);}
#if 0
# 5945
{ 
# 5946
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5948
return (unsigned char)(v.x); 
# 5949
} 
#endif
# 5951 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex3DLod(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5952
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5956
::exit(___);}
#if 0
# 5952
{ 
# 5953
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5955
return make_char1(v.x); 
# 5956
} 
#endif
# 5958 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex3DLod(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5959
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5963
::exit(___);}
#if 0
# 5959
{ 
# 5960
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5962
return make_uchar1(v.x); 
# 5963
} 
#endif
# 5965 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex3DLod(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5966
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5970
::exit(___);}
#if 0
# 5966
{ 
# 5967
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5969
return make_char2(v.x, v.y); 
# 5970
} 
#endif
# 5972 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex3DLod(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5973
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5977
::exit(___);}
#if 0
# 5973
{ 
# 5974
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5976
return make_uchar2(v.x, v.y); 
# 5977
} 
#endif
# 5979 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex3DLod(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5980
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5984
::exit(___);}
#if 0
# 5980
{ 
# 5981
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5983
return make_char4(v.x, v.y, v.z, v.w); 
# 5984
} 
#endif
# 5986 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex3DLod(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 5987
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 5991
::exit(___);}
#if 0
# 5987
{ 
# 5988
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 5990
return make_uchar4(v.x, v.y, v.z, v.w); 
# 5991
} 
#endif
# 5999 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex3DLod(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6004
::exit(___);}
#if 0
# 6000
{ 
# 6001
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6003
return (short)(v.x); 
# 6004
} 
#endif
# 6006 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex3DLod(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6011
::exit(___);}
#if 0
# 6007
{ 
# 6008
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6010
return (unsigned short)(v.x); 
# 6011
} 
#endif
# 6013 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex3DLod(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6018
::exit(___);}
#if 0
# 6014
{ 
# 6015
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6017
return make_short1(v.x); 
# 6018
} 
#endif
# 6020 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex3DLod(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6021
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6025
::exit(___);}
#if 0
# 6021
{ 
# 6022
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6024
return make_ushort1(v.x); 
# 6025
} 
#endif
# 6027 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex3DLod(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6028
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6032
::exit(___);}
#if 0
# 6028
{ 
# 6029
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6031
return make_short2(v.x, v.y); 
# 6032
} 
#endif
# 6034 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex3DLod(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6035
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6039
::exit(___);}
#if 0
# 6035
{ 
# 6036
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6038
return make_ushort2(v.x, v.y); 
# 6039
} 
#endif
# 6041 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex3DLod(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6042
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6046
::exit(___);}
#if 0
# 6042
{ 
# 6043
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6045
return make_short4(v.x, v.y, v.z, v.w); 
# 6046
} 
#endif
# 6048 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex3DLod(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6049
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6053
::exit(___);}
#if 0
# 6049
{ 
# 6050
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6052
return make_ushort4(v.x, v.y, v.z, v.w); 
# 6053
} 
#endif
# 6061 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex3DLod(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6066
::exit(___);}
#if 0
# 6062
{ 
# 6063
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6065
return (int)(v.x); 
# 6066
} 
#endif
# 6068 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex3DLod(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6069
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6073
::exit(___);}
#if 0
# 6069
{ 
# 6070
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6072
return (unsigned)(v.x); 
# 6073
} 
#endif
# 6075 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex3DLod(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6076
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6080
::exit(___);}
#if 0
# 6076
{ 
# 6077
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6079
return make_int1(v.x); 
# 6080
} 
#endif
# 6082 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex3DLod(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6083
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6087
::exit(___);}
#if 0
# 6083
{ 
# 6084
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6086
return make_uint1(v.x); 
# 6087
} 
#endif
# 6089 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex3DLod(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6090
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6094
::exit(___);}
#if 0
# 6090
{ 
# 6091
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6093
return make_int2(v.x, v.y); 
# 6094
} 
#endif
# 6096 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex3DLod(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6097
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6101
::exit(___);}
#if 0
# 6097
{ 
# 6098
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6100
return make_uint2(v.x, v.y); 
# 6101
} 
#endif
# 6103 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex3DLod(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6104
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6108
::exit(___);}
#if 0
# 6104
{ 
# 6105
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6107
return make_int4(v.x, v.y, v.z, v.w); 
# 6108
} 
#endif
# 6110 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex3DLod(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6111
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6115
::exit(___);}
#if 0
# 6111
{ 
# 6112
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6114
return make_uint4(v.x, v.y, v.z, v.w); 
# 6115
} 
#endif
# 6189 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6190
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6194
::exit(___);}
#if 0
# 6190
{ 
# 6191
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6193
return v.x; 
# 6194
} 
#endif
# 6196 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6197
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6201
::exit(___);}
#if 0
# 6197
{ 
# 6198
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6200
return make_float1(v.x); 
# 6201
} 
#endif
# 6203 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6204
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6208
::exit(___);}
#if 0
# 6204
{ 
# 6205
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6207
return make_float2(v.x, v.y); 
# 6208
} 
#endif
# 6210 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6211
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6215
::exit(___);}
#if 0
# 6211
{ 
# 6212
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6214
return make_float4(v.x, v.y, v.z, v.w); 
# 6215
} 
#endif
# 6223 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6224
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6233
::exit(___);}
#if 0
# 6224
{ 
# 6228
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6230
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6232
return w.x; 
# 6233
} 
#endif
# 6235 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6236
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6241
::exit(___);}
#if 0
# 6236
{ 
# 6237
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6238
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6240
return w.x; 
# 6241
} 
#endif
# 6243 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6244
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6249
::exit(___);}
#if 0
# 6244
{ 
# 6245
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6246
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6248
return w.x; 
# 6249
} 
#endif
# 6251 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6252
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6257
::exit(___);}
#if 0
# 6252
{ 
# 6253
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6254
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6256
return make_float1(w.x); 
# 6257
} 
#endif
# 6259 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6260
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6265
::exit(___);}
#if 0
# 6260
{ 
# 6261
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6262
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6264
return make_float1(w.x); 
# 6265
} 
#endif
# 6267 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6268
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6273
::exit(___);}
#if 0
# 6268
{ 
# 6269
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6270
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6272
return make_float2(w.x, w.y); 
# 6273
} 
#endif
# 6275 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6276
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6281
::exit(___);}
#if 0
# 6276
{ 
# 6277
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6278
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6280
return make_float2(w.x, w.y); 
# 6281
} 
#endif
# 6283 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6284
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6289
::exit(___);}
#if 0
# 6284
{ 
# 6285
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6286
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6288
return make_float4(w.x, w.y, w.z, w.w); 
# 6289
} 
#endif
# 6291 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6292
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6297
::exit(___);}
#if 0
# 6292
{ 
# 6293
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6294
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6296
return make_float4(w.x, w.y, w.z, w.w); 
# 6297
} 
#endif
# 6305 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6306
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6311
::exit(___);}
#if 0
# 6306
{ 
# 6307
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6308
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6310
return w.x; 
# 6311
} 
#endif
# 6313 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DLod(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6314
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6319
::exit(___);}
#if 0
# 6314
{ 
# 6315
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6316
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6318
return w.x; 
# 6319
} 
#endif
# 6321 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6322
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6327
::exit(___);}
#if 0
# 6322
{ 
# 6323
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6324
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6326
return make_float1(w.x); 
# 6327
} 
#endif
# 6329 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DLod(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6330
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6335
::exit(___);}
#if 0
# 6330
{ 
# 6331
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6332
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6334
return make_float1(w.x); 
# 6335
} 
#endif
# 6337 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6338
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6343
::exit(___);}
#if 0
# 6338
{ 
# 6339
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6340
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6342
return make_float2(w.x, w.y); 
# 6343
} 
#endif
# 6345 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DLod(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6346
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6351
::exit(___);}
#if 0
# 6346
{ 
# 6347
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6348
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6350
return make_float2(w.x, w.y); 
# 6351
} 
#endif
# 6353 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6354
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6359
::exit(___);}
#if 0
# 6354
{ 
# 6355
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6356
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6358
return make_float4(w.x, w.y, w.z, w.w); 
# 6359
} 
#endif
# 6361 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DLod(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6362
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6367
::exit(___);}
#if 0
# 6362
{ 
# 6363
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
# 6364
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6366
return make_float4(w.x, w.y, w.z, w.w); 
# 6367
} 
#endif
# 6375 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemapLod(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6376
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6384
::exit(___);}
#if 0
# 6376
{ 
# 6380
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6383
return (char)(v.x); 
# 6384
} 
#endif
# 6386 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemapLod(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6387
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6391
::exit(___);}
#if 0
# 6387
{ 
# 6388
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6390
return (signed char)(v.x); 
# 6391
} 
#endif
# 6393 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemapLod(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6394
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6398
::exit(___);}
#if 0
# 6394
{ 
# 6395
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6397
return (unsigned char)(v.x); 
# 6398
} 
#endif
# 6400 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemapLod(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6401
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6405
::exit(___);}
#if 0
# 6401
{ 
# 6402
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6404
return make_char1(v.x); 
# 6405
} 
#endif
# 6407 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemapLod(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6408
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6412
::exit(___);}
#if 0
# 6408
{ 
# 6409
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6411
return make_uchar1(v.x); 
# 6412
} 
#endif
# 6414 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemapLod(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6415
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6419
::exit(___);}
#if 0
# 6415
{ 
# 6416
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6418
return make_char2(v.x, v.y); 
# 6419
} 
#endif
# 6421 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemapLod(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6422
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6426
::exit(___);}
#if 0
# 6422
{ 
# 6423
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6425
return make_uchar2(v.x, v.y); 
# 6426
} 
#endif
# 6428 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemapLod(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6429
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6433
::exit(___);}
#if 0
# 6429
{ 
# 6430
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6432
return make_char4(v.x, v.y, v.z, v.w); 
# 6433
} 
#endif
# 6435 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemapLod(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6436
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6440
::exit(___);}
#if 0
# 6436
{ 
# 6437
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6439
return make_uchar4(v.x, v.y, v.z, v.w); 
# 6440
} 
#endif
# 6448 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemapLod(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6449
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6453
::exit(___);}
#if 0
# 6449
{ 
# 6450
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6452
return (short)(v.x); 
# 6453
} 
#endif
# 6455 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemapLod(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6456
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6460
::exit(___);}
#if 0
# 6456
{ 
# 6457
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6459
return (unsigned short)(v.x); 
# 6460
} 
#endif
# 6462 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemapLod(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6463
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6467
::exit(___);}
#if 0
# 6463
{ 
# 6464
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6466
return make_short1(v.x); 
# 6467
} 
#endif
# 6469 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemapLod(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6470
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6474
::exit(___);}
#if 0
# 6470
{ 
# 6471
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6473
return make_ushort1(v.x); 
# 6474
} 
#endif
# 6476 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemapLod(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6477
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6481
::exit(___);}
#if 0
# 6477
{ 
# 6478
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6480
return make_short2(v.x, v.y); 
# 6481
} 
#endif
# 6483 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemapLod(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6484
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6488
::exit(___);}
#if 0
# 6484
{ 
# 6485
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6487
return make_ushort2(v.x, v.y); 
# 6488
} 
#endif
# 6490 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemapLod(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6491
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6495
::exit(___);}
#if 0
# 6491
{ 
# 6492
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6494
return make_short4(v.x, v.y, v.z, v.w); 
# 6495
} 
#endif
# 6497 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemapLod(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6498
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6502
::exit(___);}
#if 0
# 6498
{ 
# 6499
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6501
return make_ushort4(v.x, v.y, v.z, v.w); 
# 6502
} 
#endif
# 6510 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemapLod(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6511
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6515
::exit(___);}
#if 0
# 6511
{ 
# 6512
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6514
return (int)(v.x); 
# 6515
} 
#endif
# 6517 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemapLod(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6518
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6522
::exit(___);}
#if 0
# 6518
{ 
# 6519
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6521
return (unsigned)(v.x); 
# 6522
} 
#endif
# 6524 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemapLod(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6525
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6529
::exit(___);}
#if 0
# 6525
{ 
# 6526
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6528
return make_int1(v.x); 
# 6529
} 
#endif
# 6531 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemapLod(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6532
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6536
::exit(___);}
#if 0
# 6532
{ 
# 6533
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6535
return make_uint1(v.x); 
# 6536
} 
#endif
# 6538 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemapLod(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6539
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6543
::exit(___);}
#if 0
# 6539
{ 
# 6540
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6542
return make_int2(v.x, v.y); 
# 6543
} 
#endif
# 6545 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemapLod(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6546
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6550
::exit(___);}
#if 0
# 6546
{ 
# 6547
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6549
return make_uint2(v.x, v.y); 
# 6550
} 
#endif
# 6552 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemapLod(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6553
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6557
::exit(___);}
#if 0
# 6553
{ 
# 6554
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6556
return make_int4(v.x, v.y, v.z, v.w); 
# 6557
} 
#endif
# 6559 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemapLod(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6560
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6564
::exit(___);}
#if 0
# 6560
{ 
# 6561
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6563
return make_uint4(v.x, v.y, v.z, v.w); 
# 6564
} 
#endif
# 6638 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6639
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6643
::exit(___);}
#if 0
# 6639
{ 
# 6640
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6642
return v.x; 
# 6643
} 
#endif
# 6645 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6650
::exit(___);}
#if 0
# 6646
{ 
# 6647
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6649
return make_float1(v.x); 
# 6650
} 
#endif
# 6652 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6653
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6657
::exit(___);}
#if 0
# 6653
{ 
# 6654
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6656
return make_float2(v.x, v.y); 
# 6657
} 
#endif
# 6659 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 6660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6664
::exit(___);}
#if 0
# 6660
{ 
# 6661
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6663
return make_float4(v.x, v.y, v.z, v.w); 
# 6664
} 
#endif
# 6672 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6682
::exit(___);}
#if 0
# 6673
{ 
# 6677
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6679
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6681
return w.x; 
# 6682
} 
#endif
# 6684 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6685
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6690
::exit(___);}
#if 0
# 6685
{ 
# 6686
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6687
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6689
return w.x; 
# 6690
} 
#endif
# 6692 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6693
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6698
::exit(___);}
#if 0
# 6693
{ 
# 6694
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6695
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6697
return w.x; 
# 6698
} 
#endif
# 6700 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6701
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6706
::exit(___);}
#if 0
# 6701
{ 
# 6702
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6703
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6705
return make_float1(w.x); 
# 6706
} 
#endif
# 6708 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6709
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6714
::exit(___);}
#if 0
# 6709
{ 
# 6710
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6711
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6713
return make_float1(w.x); 
# 6714
} 
#endif
# 6716 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6717
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6722
::exit(___);}
#if 0
# 6717
{ 
# 6718
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6719
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6721
return make_float2(w.x, w.y); 
# 6722
} 
#endif
# 6724 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6725
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6730
::exit(___);}
#if 0
# 6725
{ 
# 6726
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6727
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6729
return make_float2(w.x, w.y); 
# 6730
} 
#endif
# 6732 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6733
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6738
::exit(___);}
#if 0
# 6733
{ 
# 6734
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6735
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6737
return make_float4(w.x, w.y, w.z, w.w); 
# 6738
} 
#endif
# 6740 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6741
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6746
::exit(___);}
#if 0
# 6741
{ 
# 6742
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6743
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6745
return make_float4(w.x, w.y, w.z, w.w); 
# 6746
} 
#endif
# 6754 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6755
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6760
::exit(___);}
#if 0
# 6755
{ 
# 6756
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6757
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6759
return w.x; 
# 6760
} 
#endif
# 6762 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLod(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6763
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6768
::exit(___);}
#if 0
# 6763
{ 
# 6764
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6765
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6767
return w.x; 
# 6768
} 
#endif
# 6770 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6771
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6776
::exit(___);}
#if 0
# 6771
{ 
# 6772
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6773
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6775
return make_float1(w.x); 
# 6776
} 
#endif
# 6778 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLod(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6779
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6784
::exit(___);}
#if 0
# 6779
{ 
# 6780
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6781
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6783
return make_float1(w.x); 
# 6784
} 
#endif
# 6786 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6787
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6792
::exit(___);}
#if 0
# 6787
{ 
# 6788
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6789
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6791
return make_float2(w.x, w.y); 
# 6792
} 
#endif
# 6794 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLod(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6795
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6800
::exit(___);}
#if 0
# 6795
{ 
# 6796
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6797
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6799
return make_float2(w.x, w.y); 
# 6800
} 
#endif
# 6802 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6803
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6808
::exit(___);}
#if 0
# 6803
{ 
# 6804
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6805
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6807
return make_float4(w.x, w.y, w.z, w.w); 
# 6808
} 
#endif
# 6810 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLod(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 6811
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 6816
::exit(___);}
#if 0
# 6811
{ 
# 6812
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
# 6813
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 6815
return make_float4(w.x, w.y, w.z, w.w); 
# 6816
} 
#endif
# 6824 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char texCubemapLayeredLod(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6825
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6833
::exit(___);}
#if 0
# 6825
{ 
# 6829
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6832
return (char)(v.x); 
# 6833
} 
#endif
# 6835 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char texCubemapLayeredLod(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6836
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6840
::exit(___);}
#if 0
# 6836
{ 
# 6837
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6839
return (signed char)(v.x); 
# 6840
} 
#endif
# 6842 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6847
::exit(___);}
#if 0
# 6843
{ 
# 6844
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6846
return (unsigned char)(v.x); 
# 6847
} 
#endif
# 6849 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6854
::exit(___);}
#if 0
# 6850
{ 
# 6851
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6853
return make_char1(v.x); 
# 6854
} 
#endif
# 6856 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6861
::exit(___);}
#if 0
# 6857
{ 
# 6858
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6860
return make_uchar1(v.x); 
# 6861
} 
#endif
# 6863 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6864
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6868
::exit(___);}
#if 0
# 6864
{ 
# 6865
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6867
return make_char2(v.x, v.y); 
# 6868
} 
#endif
# 6870 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6871
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6875
::exit(___);}
#if 0
# 6871
{ 
# 6872
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6874
return make_uchar2(v.x, v.y); 
# 6875
} 
#endif
# 6877 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6878
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6882
::exit(___);}
#if 0
# 6878
{ 
# 6879
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6881
return make_char4(v.x, v.y, v.z, v.w); 
# 6882
} 
#endif
# 6884 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6885
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6889
::exit(___);}
#if 0
# 6885
{ 
# 6886
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6888
return make_uchar4(v.x, v.y, v.z, v.w); 
# 6889
} 
#endif
# 6897 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short texCubemapLayeredLod(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6902
::exit(___);}
#if 0
# 6898
{ 
# 6899
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6901
return (short)(v.x); 
# 6902
} 
#endif
# 6904 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6909
::exit(___);}
#if 0
# 6905
{ 
# 6906
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6908
return (unsigned short)(v.x); 
# 6909
} 
#endif
# 6911 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6912
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6916
::exit(___);}
#if 0
# 6912
{ 
# 6913
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6915
return make_short1(v.x); 
# 6916
} 
#endif
# 6918 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6919
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6923
::exit(___);}
#if 0
# 6919
{ 
# 6920
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6922
return make_ushort1(v.x); 
# 6923
} 
#endif
# 6925 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6926
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6930
::exit(___);}
#if 0
# 6926
{ 
# 6927
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6929
return make_short2(v.x, v.y); 
# 6930
} 
#endif
# 6932 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6933
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6937
::exit(___);}
#if 0
# 6933
{ 
# 6934
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6936
return make_ushort2(v.x, v.y); 
# 6937
} 
#endif
# 6939 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6940
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6944
::exit(___);}
#if 0
# 6940
{ 
# 6941
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6943
return make_short4(v.x, v.y, v.z, v.w); 
# 6944
} 
#endif
# 6946 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6947
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6951
::exit(___);}
#if 0
# 6947
{ 
# 6948
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6950
return make_ushort4(v.x, v.y, v.z, v.w); 
# 6951
} 
#endif
# 6959 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int texCubemapLayeredLod(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6960
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6964
::exit(___);}
#if 0
# 6960
{ 
# 6961
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6963
return (int)(v.x); 
# 6964
} 
#endif
# 6966 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned texCubemapLayeredLod(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6967
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6971
::exit(___);}
#if 0
# 6967
{ 
# 6968
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6970
return (unsigned)(v.x); 
# 6971
} 
#endif
# 6973 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 texCubemapLayeredLod(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6974
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6978
::exit(___);}
#if 0
# 6974
{ 
# 6975
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6977
return make_int1(v.x); 
# 6978
} 
#endif
# 6980 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 texCubemapLayeredLod(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6981
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6985
::exit(___);}
#if 0
# 6981
{ 
# 6982
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6984
return make_uint1(v.x); 
# 6985
} 
#endif
# 6987 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 texCubemapLayeredLod(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6988
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6992
::exit(___);}
#if 0
# 6988
{ 
# 6989
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6991
return make_int2(v.x, v.y); 
# 6992
} 
#endif
# 6994 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 texCubemapLayeredLod(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 6995
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 6999
::exit(___);}
#if 0
# 6995
{ 
# 6996
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 6998
return make_uint2(v.x, v.y); 
# 6999
} 
#endif
# 7001 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 texCubemapLayeredLod(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 7002
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7006
::exit(___);}
#if 0
# 7002
{ 
# 7003
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7005
return make_int4(v.x, v.y, v.z, v.w); 
# 7006
} 
#endif
# 7008 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 texCubemapLayeredLod(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 7009
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7013
::exit(___);}
#if 0
# 7009
{ 
# 7010
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7012
return make_uint4(v.x, v.y, v.z, v.w); 
# 7013
} 
#endif
# 7087 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 7088
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7092
::exit(___);}
#if 0
# 7088
{ 
# 7089
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7091
return v.x; 
# 7092
} 
#endif
# 7094 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 7095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7099
::exit(___);}
#if 0
# 7095
{ 
# 7096
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7098
return make_float1(v.x); 
# 7099
} 
#endif
# 7101 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 7102
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7106
::exit(___);}
#if 0
# 7102
{ 
# 7103
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7105
return make_float2(v.x, v.y); 
# 7106
} 
#endif
# 7108 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 7109
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7113
::exit(___);}
#if 0
# 7109
{ 
# 7110
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7112
return make_float4(v.x, v.y, v.z, v.w); 
# 7113
} 
#endif
# 7121 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7122
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7131
::exit(___);}
#if 0
# 7122
{ 
# 7126
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7128
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7130
return w.x; 
# 7131
} 
#endif
# 7133 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7134
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7139
::exit(___);}
#if 0
# 7134
{ 
# 7135
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7136
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7138
return w.x; 
# 7139
} 
#endif
# 7141 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7142
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7147
::exit(___);}
#if 0
# 7142
{ 
# 7143
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7144
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7146
return w.x; 
# 7147
} 
#endif
# 7149 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7150
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7155
::exit(___);}
#if 0
# 7150
{ 
# 7151
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7152
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7154
return make_float1(w.x); 
# 7155
} 
#endif
# 7157 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7158
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7163
::exit(___);}
#if 0
# 7158
{ 
# 7159
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7160
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7162
return make_float1(w.x); 
# 7163
} 
#endif
# 7165 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7166
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7171
::exit(___);}
#if 0
# 7166
{ 
# 7167
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7168
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7170
return make_float2(w.x, w.y); 
# 7171
} 
#endif
# 7173 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7174
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7179
::exit(___);}
#if 0
# 7174
{ 
# 7175
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7176
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7178
return make_float2(w.x, w.y); 
# 7179
} 
#endif
# 7181 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7182
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7187
::exit(___);}
#if 0
# 7182
{ 
# 7183
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7184
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7186
return make_float4(w.x, w.y, w.z, w.w); 
# 7187
} 
#endif
# 7189 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7190
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7195
::exit(___);}
#if 0
# 7190
{ 
# 7191
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7192
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7194
return make_float4(w.x, w.y, w.z, w.w); 
# 7195
} 
#endif
# 7203 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7204
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7209
::exit(___);}
#if 0
# 7204
{ 
# 7205
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7206
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7208
return w.x; 
# 7209
} 
#endif
# 7211 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7212
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7217
::exit(___);}
#if 0
# 7212
{ 
# 7213
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7214
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7216
return w.x; 
# 7217
} 
#endif
# 7219 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7220
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7225
::exit(___);}
#if 0
# 7220
{ 
# 7221
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7222
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7224
return make_float1(w.x); 
# 7225
} 
#endif
# 7227 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7228
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7233
::exit(___);}
#if 0
# 7228
{ 
# 7229
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7230
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7232
return make_float1(w.x); 
# 7233
} 
#endif
# 7235 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7236
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7241
::exit(___);}
#if 0
# 7236
{ 
# 7237
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7238
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7240
return make_float2(w.x, w.y); 
# 7241
} 
#endif
# 7243 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7244
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7249
::exit(___);}
#if 0
# 7244
{ 
# 7245
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7246
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7248
return make_float2(w.x, w.y); 
# 7249
} 
#endif
# 7251 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7252
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7257
::exit(___);}
#if 0
# 7252
{ 
# 7253
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7254
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7256
return make_float4(w.x, w.y, w.z, w.w); 
# 7257
} 
#endif
# 7259 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 7260
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 7265
::exit(___);}
#if 0
# 7260
{ 
# 7261
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
# 7262
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7264
return make_float4(w.x, w.y, w.z, w.w); 
# 7265
} 
#endif
# 7281 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DGrad(texture< char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7282
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7290
::exit(___);}
#if 0
# 7282
{ 
# 7286
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7289
return (char)(v.x); 
# 7290
} 
#endif
# 7292 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DGrad(texture< signed char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7293
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7297
::exit(___);}
#if 0
# 7293
{ 
# 7294
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7296
return (signed char)(v.x); 
# 7297
} 
#endif
# 7299 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DGrad(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7300
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7304
::exit(___);}
#if 0
# 7300
{ 
# 7301
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7303
return (unsigned char)(v.x); 
# 7304
} 
#endif
# 7306 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DGrad(texture< char1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7307
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7311
::exit(___);}
#if 0
# 7307
{ 
# 7308
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7310
return make_char1(v.x); 
# 7311
} 
#endif
# 7313 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DGrad(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7314
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7318
::exit(___);}
#if 0
# 7314
{ 
# 7315
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7317
return make_uchar1(v.x); 
# 7318
} 
#endif
# 7320 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DGrad(texture< char2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7321
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7325
::exit(___);}
#if 0
# 7321
{ 
# 7322
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7324
return make_char2(v.x, v.y); 
# 7325
} 
#endif
# 7327 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DGrad(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7328
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7332
::exit(___);}
#if 0
# 7328
{ 
# 7329
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7331
return make_uchar2(v.x, v.y); 
# 7332
} 
#endif
# 7334 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DGrad(texture< char4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7335
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7339
::exit(___);}
#if 0
# 7335
{ 
# 7336
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7338
return make_char4(v.x, v.y, v.z, v.w); 
# 7339
} 
#endif
# 7341 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DGrad(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7342
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7346
::exit(___);}
#if 0
# 7342
{ 
# 7343
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7345
return make_uchar4(v.x, v.y, v.z, v.w); 
# 7346
} 
#endif
# 7354 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DGrad(texture< short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7355
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7359
::exit(___);}
#if 0
# 7355
{ 
# 7356
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7358
return (short)(v.x); 
# 7359
} 
#endif
# 7361 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DGrad(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7362
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7366
::exit(___);}
#if 0
# 7362
{ 
# 7363
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7365
return (unsigned short)(v.x); 
# 7366
} 
#endif
# 7368 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DGrad(texture< short1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7369
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7373
::exit(___);}
#if 0
# 7369
{ 
# 7370
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7372
return make_short1(v.x); 
# 7373
} 
#endif
# 7375 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DGrad(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7376
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7380
::exit(___);}
#if 0
# 7376
{ 
# 7377
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7379
return make_ushort1(v.x); 
# 7380
} 
#endif
# 7382 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DGrad(texture< short2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7383
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7387
::exit(___);}
#if 0
# 7383
{ 
# 7384
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7386
return make_short2(v.x, v.y); 
# 7387
} 
#endif
# 7389 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DGrad(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7390
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7394
::exit(___);}
#if 0
# 7390
{ 
# 7391
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7393
return make_ushort2(v.x, v.y); 
# 7394
} 
#endif
# 7396 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DGrad(texture< short4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7397
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7401
::exit(___);}
#if 0
# 7397
{ 
# 7398
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7400
return make_short4(v.x, v.y, v.z, v.w); 
# 7401
} 
#endif
# 7403 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DGrad(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7404
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7408
::exit(___);}
#if 0
# 7404
{ 
# 7405
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7407
return make_ushort4(v.x, v.y, v.z, v.w); 
# 7408
} 
#endif
# 7416 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DGrad(texture< int, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7417
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7421
::exit(___);}
#if 0
# 7417
{ 
# 7418
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7420
return (int)(v.x); 
# 7421
} 
#endif
# 7423 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DGrad(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7424
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7428
::exit(___);}
#if 0
# 7424
{ 
# 7425
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7427
return (unsigned)(v.x); 
# 7428
} 
#endif
# 7430 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DGrad(texture< int1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7431
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7435
::exit(___);}
#if 0
# 7431
{ 
# 7432
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7434
return make_int1(v.x); 
# 7435
} 
#endif
# 7437 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DGrad(texture< uint1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7438
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7442
::exit(___);}
#if 0
# 7438
{ 
# 7439
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7441
return make_uint1(v.x); 
# 7442
} 
#endif
# 7444 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DGrad(texture< int2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7445
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7449
::exit(___);}
#if 0
# 7445
{ 
# 7446
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7448
return make_int2(v.x, v.y); 
# 7449
} 
#endif
# 7451 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DGrad(texture< uint2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7452
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7456
::exit(___);}
#if 0
# 7452
{ 
# 7453
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7455
return make_uint2(v.x, v.y); 
# 7456
} 
#endif
# 7458 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DGrad(texture< int4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7459
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7463
::exit(___);}
#if 0
# 7459
{ 
# 7460
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7462
return make_int4(v.x, v.y, v.z, v.w); 
# 7463
} 
#endif
# 7465 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DGrad(texture< uint4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7466
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7470
::exit(___);}
#if 0
# 7466
{ 
# 7467
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7469
return make_uint4(v.x, v.y, v.z, v.w); 
# 7470
} 
#endif
# 7550 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< float, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7551
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7555
::exit(___);}
#if 0
# 7551
{ 
# 7552
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7554
return v.x; 
# 7555
} 
#endif
# 7557 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< float1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7558
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7562
::exit(___);}
#if 0
# 7558
{ 
# 7559
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7561
return make_float1(v.x); 
# 7562
} 
#endif
# 7564 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< float2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7565
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7569
::exit(___);}
#if 0
# 7565
{ 
# 7566
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7568
return make_float2(v.x, v.y); 
# 7569
} 
#endif
# 7571 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< float4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 7572
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7576
::exit(___);}
#if 0
# 7572
{ 
# 7573
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7575
return make_float4(v.x, v.y, v.z, v.w); 
# 7576
} 
#endif
# 7584 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7585
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7594
::exit(___);}
#if 0
# 7585
{ 
# 7589
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7591
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7593
return w.x; 
# 7594
} 
#endif
# 7596 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7597
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7602
::exit(___);}
#if 0
# 7597
{ 
# 7598
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7599
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7601
return w.x; 
# 7602
} 
#endif
# 7604 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7605
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7610
::exit(___);}
#if 0
# 7605
{ 
# 7606
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7607
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7609
return w.x; 
# 7610
} 
#endif
# 7612 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7613
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7618
::exit(___);}
#if 0
# 7613
{ 
# 7614
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7615
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7617
return make_float1(w.x); 
# 7618
} 
#endif
# 7620 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7621
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7626
::exit(___);}
#if 0
# 7621
{ 
# 7622
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7623
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7625
return make_float1(w.x); 
# 7626
} 
#endif
# 7628 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7629
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7634
::exit(___);}
#if 0
# 7629
{ 
# 7630
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7631
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7633
return make_float2(w.x, w.y); 
# 7634
} 
#endif
# 7636 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7637
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7642
::exit(___);}
#if 0
# 7637
{ 
# 7638
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7639
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7641
return make_float2(w.x, w.y); 
# 7642
} 
#endif
# 7644 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7645
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7650
::exit(___);}
#if 0
# 7645
{ 
# 7646
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7647
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7649
return make_float4(w.x, w.y, w.z, w.w); 
# 7650
} 
#endif
# 7652 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7653
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7658
::exit(___);}
#if 0
# 7653
{ 
# 7654
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7655
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7657
return make_float4(w.x, w.y, w.z, w.w); 
# 7658
} 
#endif
# 7666 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7667
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7672
::exit(___);}
#if 0
# 7667
{ 
# 7668
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7669
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7671
return w.x; 
# 7672
} 
#endif
# 7674 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DGrad(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7675
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7680
::exit(___);}
#if 0
# 7675
{ 
# 7676
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7677
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7679
return w.x; 
# 7680
} 
#endif
# 7682 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7683
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7688
::exit(___);}
#if 0
# 7683
{ 
# 7684
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7685
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7687
return make_float1(w.x); 
# 7688
} 
#endif
# 7690 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DGrad(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7691
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7696
::exit(___);}
#if 0
# 7691
{ 
# 7692
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7693
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7695
return make_float1(w.x); 
# 7696
} 
#endif
# 7698 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7699
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7704
::exit(___);}
#if 0
# 7699
{ 
# 7700
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7701
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7703
return make_float2(w.x, w.y); 
# 7704
} 
#endif
# 7706 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DGrad(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7707
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7712
::exit(___);}
#if 0
# 7707
{ 
# 7708
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7709
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7711
return make_float2(w.x, w.y); 
# 7712
} 
#endif
# 7714 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7715
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7720
::exit(___);}
#if 0
# 7715
{ 
# 7716
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7717
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7719
return make_float4(w.x, w.y, w.z, w.w); 
# 7720
} 
#endif
# 7722 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DGrad(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 7723
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 7728
::exit(___);}
#if 0
# 7723
{ 
# 7724
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 7725
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 7727
return make_float4(w.x, w.y, w.z, w.w); 
# 7728
} 
#endif
# 7736 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DGrad(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7737
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7745
::exit(___);}
#if 0
# 7737
{ 
# 7741
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7744
return (char)(v.x); 
# 7745
} 
#endif
# 7747 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DGrad(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7748
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7752
::exit(___);}
#if 0
# 7748
{ 
# 7749
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7751
return (signed char)(v.x); 
# 7752
} 
#endif
# 7754 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DGrad(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7755
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7759
::exit(___);}
#if 0
# 7755
{ 
# 7756
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7758
return (unsigned char)(v.x); 
# 7759
} 
#endif
# 7761 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DGrad(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7762
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7766
::exit(___);}
#if 0
# 7762
{ 
# 7763
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7765
return make_char1(v.x); 
# 7766
} 
#endif
# 7768 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DGrad(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7769
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7773
::exit(___);}
#if 0
# 7769
{ 
# 7770
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7772
return make_uchar1(v.x); 
# 7773
} 
#endif
# 7775 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DGrad(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7776
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7780
::exit(___);}
#if 0
# 7776
{ 
# 7777
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7779
return make_char2(v.x, v.y); 
# 7780
} 
#endif
# 7782 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DGrad(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7783
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7787
::exit(___);}
#if 0
# 7783
{ 
# 7784
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7786
return make_uchar2(v.x, v.y); 
# 7787
} 
#endif
# 7789 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DGrad(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7790
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7794
::exit(___);}
#if 0
# 7790
{ 
# 7791
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7793
return make_char4(v.x, v.y, v.z, v.w); 
# 7794
} 
#endif
# 7796 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DGrad(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7797
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7801
::exit(___);}
#if 0
# 7797
{ 
# 7798
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7800
return make_uchar4(v.x, v.y, v.z, v.w); 
# 7801
} 
#endif
# 7809 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DGrad(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7810
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7814
::exit(___);}
#if 0
# 7810
{ 
# 7811
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7813
return (short)(v.x); 
# 7814
} 
#endif
# 7816 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DGrad(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7817
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7821
::exit(___);}
#if 0
# 7817
{ 
# 7818
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7820
return (unsigned short)(v.x); 
# 7821
} 
#endif
# 7823 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DGrad(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7824
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7828
::exit(___);}
#if 0
# 7824
{ 
# 7825
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7827
return make_short1(v.x); 
# 7828
} 
#endif
# 7830 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DGrad(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7831
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7835
::exit(___);}
#if 0
# 7831
{ 
# 7832
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7834
return make_ushort1(v.x); 
# 7835
} 
#endif
# 7837 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DGrad(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7838
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7842
::exit(___);}
#if 0
# 7838
{ 
# 7839
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7841
return make_short2(v.x, v.y); 
# 7842
} 
#endif
# 7844 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DGrad(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7845
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7849
::exit(___);}
#if 0
# 7845
{ 
# 7846
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7848
return make_ushort2(v.x, v.y); 
# 7849
} 
#endif
# 7851 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DGrad(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7852
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7856
::exit(___);}
#if 0
# 7852
{ 
# 7853
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7855
return make_short4(v.x, v.y, v.z, v.w); 
# 7856
} 
#endif
# 7858 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DGrad(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7859
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7863
::exit(___);}
#if 0
# 7859
{ 
# 7860
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7862
return make_ushort4(v.x, v.y, v.z, v.w); 
# 7863
} 
#endif
# 7871 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DGrad(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7872
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7876
::exit(___);}
#if 0
# 7872
{ 
# 7873
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7875
return (int)(v.x); 
# 7876
} 
#endif
# 7878 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DGrad(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7879
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7883
::exit(___);}
#if 0
# 7879
{ 
# 7880
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7882
return (unsigned)(v.x); 
# 7883
} 
#endif
# 7885 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DGrad(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7886
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7890
::exit(___);}
#if 0
# 7886
{ 
# 7887
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7889
return make_int1(v.x); 
# 7890
} 
#endif
# 7892 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DGrad(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7893
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7897
::exit(___);}
#if 0
# 7893
{ 
# 7894
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7896
return make_uint1(v.x); 
# 7897
} 
#endif
# 7899 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DGrad(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7900
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7904
::exit(___);}
#if 0
# 7900
{ 
# 7901
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7903
return make_int2(v.x, v.y); 
# 7904
} 
#endif
# 7906 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DGrad(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7907
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7911
::exit(___);}
#if 0
# 7907
{ 
# 7908
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7910
return make_uint2(v.x, v.y); 
# 7911
} 
#endif
# 7913 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DGrad(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7914
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7918
::exit(___);}
#if 0
# 7914
{ 
# 7915
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7917
return make_int4(v.x, v.y, v.z, v.w); 
# 7918
} 
#endif
# 7920 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DGrad(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 7921
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 7925
::exit(___);}
#if 0
# 7921
{ 
# 7922
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 7924
return make_uint4(v.x, v.y, v.z, v.w); 
# 7925
} 
#endif
# 7999 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8004
::exit(___);}
#if 0
# 8000
{ 
# 8001
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8003
return v.x; 
# 8004
} 
#endif
# 8006 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8007
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8011
::exit(___);}
#if 0
# 8007
{ 
# 8008
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8010
return make_float1(v.x); 
# 8011
} 
#endif
# 8013 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8018
::exit(___);}
#if 0
# 8014
{ 
# 8015
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8017
return make_float2(v.x, v.y); 
# 8018
} 
#endif
# 8020 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8021
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8025
::exit(___);}
#if 0
# 8021
{ 
# 8022
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8024
return make_float4(v.x, v.y, v.z, v.w); 
# 8025
} 
#endif
# 8033 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8034
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8043
::exit(___);}
#if 0
# 8034
{ 
# 8038
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8040
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8042
return w.x; 
# 8043
} 
#endif
# 8045 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8046
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8051
::exit(___);}
#if 0
# 8046
{ 
# 8047
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8048
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8050
return w.x; 
# 8051
} 
#endif
# 8053 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8054
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8059
::exit(___);}
#if 0
# 8054
{ 
# 8055
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8056
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8058
return w.x; 
# 8059
} 
#endif
# 8061 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8067
::exit(___);}
#if 0
# 8062
{ 
# 8063
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8064
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8066
return make_float1(w.x); 
# 8067
} 
#endif
# 8069 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8070
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8075
::exit(___);}
#if 0
# 8070
{ 
# 8071
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8072
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8074
return make_float1(w.x); 
# 8075
} 
#endif
# 8077 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8078
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8083
::exit(___);}
#if 0
# 8078
{ 
# 8079
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8080
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8082
return make_float2(w.x, w.y); 
# 8083
} 
#endif
# 8085 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8086
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8091
::exit(___);}
#if 0
# 8086
{ 
# 8087
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8088
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8090
return make_float2(w.x, w.y); 
# 8091
} 
#endif
# 8093 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8094
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8099
::exit(___);}
#if 0
# 8094
{ 
# 8095
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8096
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8098
return make_float4(w.x, w.y, w.z, w.w); 
# 8099
} 
#endif
# 8101 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8102
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8107
::exit(___);}
#if 0
# 8102
{ 
# 8103
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8104
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8106
return make_float4(w.x, w.y, w.z, w.w); 
# 8107
} 
#endif
# 8115 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8116
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8121
::exit(___);}
#if 0
# 8116
{ 
# 8117
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8118
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8120
return w.x; 
# 8121
} 
#endif
# 8123 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DGrad(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8124
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8129
::exit(___);}
#if 0
# 8124
{ 
# 8125
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8126
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8128
return w.x; 
# 8129
} 
#endif
# 8131 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8132
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8137
::exit(___);}
#if 0
# 8132
{ 
# 8133
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8134
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8136
return make_float1(w.x); 
# 8137
} 
#endif
# 8139 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DGrad(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8140
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8145
::exit(___);}
#if 0
# 8140
{ 
# 8141
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8142
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8144
return make_float1(w.x); 
# 8145
} 
#endif
# 8147 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8148
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8153
::exit(___);}
#if 0
# 8148
{ 
# 8149
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8150
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8152
return make_float2(w.x, w.y); 
# 8153
} 
#endif
# 8155 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DGrad(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8156
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8161
::exit(___);}
#if 0
# 8156
{ 
# 8157
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8158
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8160
return make_float2(w.x, w.y); 
# 8161
} 
#endif
# 8163 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8164
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8169
::exit(___);}
#if 0
# 8164
{ 
# 8165
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8166
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8168
return make_float4(w.x, w.y, w.z, w.w); 
# 8169
} 
#endif
# 8171 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DGrad(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 8172
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 8177
::exit(___);}
#if 0
# 8172
{ 
# 8173
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8174
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8176
return make_float4(w.x, w.y, w.z, w.w); 
# 8177
} 
#endif
# 8185 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex1DLayeredGrad(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8186
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8194
::exit(___);}
#if 0
# 8186
{ 
# 8190
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8193
return (char)(v.x); 
# 8194
} 
#endif
# 8196 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex1DLayeredGrad(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8197
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8201
::exit(___);}
#if 0
# 8197
{ 
# 8198
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8200
return (signed char)(v.x); 
# 8201
} 
#endif
# 8203 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8204
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8208
::exit(___);}
#if 0
# 8204
{ 
# 8205
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8207
return (unsigned char)(v.x); 
# 8208
} 
#endif
# 8210 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8211
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8215
::exit(___);}
#if 0
# 8211
{ 
# 8212
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8214
return make_char1(v.x); 
# 8215
} 
#endif
# 8217 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8218
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8222
::exit(___);}
#if 0
# 8218
{ 
# 8219
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8221
return make_uchar1(v.x); 
# 8222
} 
#endif
# 8224 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8225
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8229
::exit(___);}
#if 0
# 8225
{ 
# 8226
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8228
return make_char2(v.x, v.y); 
# 8229
} 
#endif
# 8231 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8232
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8236
::exit(___);}
#if 0
# 8232
{ 
# 8233
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8235
return make_uchar2(v.x, v.y); 
# 8236
} 
#endif
# 8238 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8239
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8243
::exit(___);}
#if 0
# 8239
{ 
# 8240
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8242
return make_char4(v.x, v.y, v.z, v.w); 
# 8243
} 
#endif
# 8245 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8246
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8250
::exit(___);}
#if 0
# 8246
{ 
# 8247
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8249
return make_uchar4(v.x, v.y, v.z, v.w); 
# 8250
} 
#endif
# 8258 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex1DLayeredGrad(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8259
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8263
::exit(___);}
#if 0
# 8259
{ 
# 8260
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8262
return (short)(v.x); 
# 8263
} 
#endif
# 8265 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8266
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8270
::exit(___);}
#if 0
# 8266
{ 
# 8267
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8269
return (unsigned short)(v.x); 
# 8270
} 
#endif
# 8272 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8273
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8277
::exit(___);}
#if 0
# 8273
{ 
# 8274
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8276
return make_short1(v.x); 
# 8277
} 
#endif
# 8279 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8280
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8284
::exit(___);}
#if 0
# 8280
{ 
# 8281
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8283
return make_ushort1(v.x); 
# 8284
} 
#endif
# 8286 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8287
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8291
::exit(___);}
#if 0
# 8287
{ 
# 8288
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8290
return make_short2(v.x, v.y); 
# 8291
} 
#endif
# 8293 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8294
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8298
::exit(___);}
#if 0
# 8294
{ 
# 8295
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8297
return make_ushort2(v.x, v.y); 
# 8298
} 
#endif
# 8300 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8301
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8305
::exit(___);}
#if 0
# 8301
{ 
# 8302
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8304
return make_short4(v.x, v.y, v.z, v.w); 
# 8305
} 
#endif
# 8307 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8308
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8312
::exit(___);}
#if 0
# 8308
{ 
# 8309
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8311
return make_ushort4(v.x, v.y, v.z, v.w); 
# 8312
} 
#endif
# 8320 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex1DLayeredGrad(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8321
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8325
::exit(___);}
#if 0
# 8321
{ 
# 8322
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8324
return (int)(v.x); 
# 8325
} 
#endif
# 8327 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex1DLayeredGrad(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8328
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8332
::exit(___);}
#if 0
# 8328
{ 
# 8329
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8331
return (unsigned)(v.x); 
# 8332
} 
#endif
# 8334 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex1DLayeredGrad(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8335
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8339
::exit(___);}
#if 0
# 8335
{ 
# 8336
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8338
return make_int1(v.x); 
# 8339
} 
#endif
# 8341 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex1DLayeredGrad(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8342
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8346
::exit(___);}
#if 0
# 8342
{ 
# 8343
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8345
return make_uint1(v.x); 
# 8346
} 
#endif
# 8348 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex1DLayeredGrad(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8349
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8353
::exit(___);}
#if 0
# 8349
{ 
# 8350
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8352
return make_int2(v.x, v.y); 
# 8353
} 
#endif
# 8355 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex1DLayeredGrad(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8356
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8360
::exit(___);}
#if 0
# 8356
{ 
# 8357
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8359
return make_uint2(v.x, v.y); 
# 8360
} 
#endif
# 8362 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex1DLayeredGrad(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8363
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8367
::exit(___);}
#if 0
# 8363
{ 
# 8364
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8366
return make_int4(v.x, v.y, v.z, v.w); 
# 8367
} 
#endif
# 8369 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex1DLayeredGrad(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8370
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8374
::exit(___);}
#if 0
# 8370
{ 
# 8371
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8373
return make_uint4(v.x, v.y, v.z, v.w); 
# 8374
} 
#endif
# 8448 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8449
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8453
::exit(___);}
#if 0
# 8449
{ 
# 8450
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8452
return v.x; 
# 8453
} 
#endif
# 8455 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8456
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8460
::exit(___);}
#if 0
# 8456
{ 
# 8457
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8459
return make_float1(v.x); 
# 8460
} 
#endif
# 8462 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8463
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8467
::exit(___);}
#if 0
# 8463
{ 
# 8464
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8466
return make_float2(v.x, v.y); 
# 8467
} 
#endif
# 8469 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 8470
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8474
::exit(___);}
#if 0
# 8470
{ 
# 8471
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8473
return make_float4(v.x, v.y, v.z, v.w); 
# 8474
} 
#endif
# 8482 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8483
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8492
::exit(___);}
#if 0
# 8483
{ 
# 8487
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8489
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8491
return w.x; 
# 8492
} 
#endif
# 8494 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8495
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8500
::exit(___);}
#if 0
# 8495
{ 
# 8496
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8497
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8499
return w.x; 
# 8500
} 
#endif
# 8502 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8503
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8508
::exit(___);}
#if 0
# 8503
{ 
# 8504
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8505
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8507
return w.x; 
# 8508
} 
#endif
# 8510 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8511
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8516
::exit(___);}
#if 0
# 8511
{ 
# 8512
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8513
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8515
return make_float1(w.x); 
# 8516
} 
#endif
# 8518 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8519
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8524
::exit(___);}
#if 0
# 8519
{ 
# 8520
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8521
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8523
return make_float1(w.x); 
# 8524
} 
#endif
# 8526 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8527
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8532
::exit(___);}
#if 0
# 8527
{ 
# 8528
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8529
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8531
return make_float2(w.x, w.y); 
# 8532
} 
#endif
# 8534 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8535
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8540
::exit(___);}
#if 0
# 8535
{ 
# 8536
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8537
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8539
return make_float2(w.x, w.y); 
# 8540
} 
#endif
# 8542 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8543
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8548
::exit(___);}
#if 0
# 8543
{ 
# 8544
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8545
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8547
return make_float4(w.x, w.y, w.z, w.w); 
# 8548
} 
#endif
# 8550 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8551
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8556
::exit(___);}
#if 0
# 8551
{ 
# 8552
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8553
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8555
return make_float4(w.x, w.y, w.z, w.w); 
# 8556
} 
#endif
# 8564 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8565
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8570
::exit(___);}
#if 0
# 8565
{ 
# 8566
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8567
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8569
return w.x; 
# 8570
} 
#endif
# 8572 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8573
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8578
::exit(___);}
#if 0
# 8573
{ 
# 8574
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8575
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8577
return w.x; 
# 8578
} 
#endif
# 8580 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8581
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8586
::exit(___);}
#if 0
# 8581
{ 
# 8582
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8583
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8585
return make_float1(w.x); 
# 8586
} 
#endif
# 8588 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8589
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8594
::exit(___);}
#if 0
# 8589
{ 
# 8590
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8591
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8593
return make_float1(w.x); 
# 8594
} 
#endif
# 8596 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8597
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8602
::exit(___);}
#if 0
# 8597
{ 
# 8598
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8599
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8601
return make_float2(w.x, w.y); 
# 8602
} 
#endif
# 8604 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8605
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8610
::exit(___);}
#if 0
# 8605
{ 
# 8606
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8607
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8609
return make_float2(w.x, w.y); 
# 8610
} 
#endif
# 8612 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8613
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8618
::exit(___);}
#if 0
# 8613
{ 
# 8614
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8615
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8617
return make_float4(w.x, w.y, w.z, w.w); 
# 8618
} 
#endif
# 8620 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 8621
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 8626
::exit(___);}
#if 0
# 8621
{ 
# 8622
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
# 8623
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8625
return make_float4(w.x, w.y, w.z, w.w); 
# 8626
} 
#endif
# 8634 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex2DLayeredGrad(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8635
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8643
::exit(___);}
#if 0
# 8635
{ 
# 8639
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8642
return (char)(v.x); 
# 8643
} 
#endif
# 8645 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex2DLayeredGrad(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8650
::exit(___);}
#if 0
# 8646
{ 
# 8647
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8649
return (signed char)(v.x); 
# 8650
} 
#endif
# 8652 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8653
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8657
::exit(___);}
#if 0
# 8653
{ 
# 8654
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8656
return (unsigned char)(v.x); 
# 8657
} 
#endif
# 8659 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8664
::exit(___);}
#if 0
# 8660
{ 
# 8661
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8663
return make_char1(v.x); 
# 8664
} 
#endif
# 8666 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8667
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8671
::exit(___);}
#if 0
# 8667
{ 
# 8668
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8670
return make_uchar1(v.x); 
# 8671
} 
#endif
# 8673 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8674
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8678
::exit(___);}
#if 0
# 8674
{ 
# 8675
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8677
return make_char2(v.x, v.y); 
# 8678
} 
#endif
# 8680 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8685
::exit(___);}
#if 0
# 8681
{ 
# 8682
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8684
return make_uchar2(v.x, v.y); 
# 8685
} 
#endif
# 8687 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8688
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8692
::exit(___);}
#if 0
# 8688
{ 
# 8689
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8691
return make_char4(v.x, v.y, v.z, v.w); 
# 8692
} 
#endif
# 8694 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8695
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8699
::exit(___);}
#if 0
# 8695
{ 
# 8696
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8698
return make_uchar4(v.x, v.y, v.z, v.w); 
# 8699
} 
#endif
# 8707 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex2DLayeredGrad(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8708
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8712
::exit(___);}
#if 0
# 8708
{ 
# 8709
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8711
return (short)(v.x); 
# 8712
} 
#endif
# 8714 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8715
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8719
::exit(___);}
#if 0
# 8715
{ 
# 8716
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8718
return (unsigned short)(v.x); 
# 8719
} 
#endif
# 8721 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8722
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8726
::exit(___);}
#if 0
# 8722
{ 
# 8723
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8725
return make_short1(v.x); 
# 8726
} 
#endif
# 8728 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8729
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8733
::exit(___);}
#if 0
# 8729
{ 
# 8730
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8732
return make_ushort1(v.x); 
# 8733
} 
#endif
# 8735 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8736
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8740
::exit(___);}
#if 0
# 8736
{ 
# 8737
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8739
return make_short2(v.x, v.y); 
# 8740
} 
#endif
# 8742 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8743
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8747
::exit(___);}
#if 0
# 8743
{ 
# 8744
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8746
return make_ushort2(v.x, v.y); 
# 8747
} 
#endif
# 8749 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8750
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8754
::exit(___);}
#if 0
# 8750
{ 
# 8751
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8753
return make_short4(v.x, v.y, v.z, v.w); 
# 8754
} 
#endif
# 8756 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8757
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8761
::exit(___);}
#if 0
# 8757
{ 
# 8758
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8760
return make_ushort4(v.x, v.y, v.z, v.w); 
# 8761
} 
#endif
# 8769 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex2DLayeredGrad(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8770
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8774
::exit(___);}
#if 0
# 8770
{ 
# 8771
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8773
return (int)(v.x); 
# 8774
} 
#endif
# 8776 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex2DLayeredGrad(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8777
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8781
::exit(___);}
#if 0
# 8777
{ 
# 8778
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8780
return (unsigned)(v.x); 
# 8781
} 
#endif
# 8783 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex2DLayeredGrad(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8784
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8788
::exit(___);}
#if 0
# 8784
{ 
# 8785
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8787
return make_int1(v.x); 
# 8788
} 
#endif
# 8790 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex2DLayeredGrad(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8791
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8795
::exit(___);}
#if 0
# 8791
{ 
# 8792
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8794
return make_uint1(v.x); 
# 8795
} 
#endif
# 8797 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex2DLayeredGrad(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8798
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8802
::exit(___);}
#if 0
# 8798
{ 
# 8799
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8801
return make_int2(v.x, v.y); 
# 8802
} 
#endif
# 8804 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex2DLayeredGrad(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8805
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8809
::exit(___);}
#if 0
# 8805
{ 
# 8806
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8808
return make_uint2(v.x, v.y); 
# 8809
} 
#endif
# 8811 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex2DLayeredGrad(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8812
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8816
::exit(___);}
#if 0
# 8812
{ 
# 8813
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8815
return make_int4(v.x, v.y, v.z, v.w); 
# 8816
} 
#endif
# 8818 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex2DLayeredGrad(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8819
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8823
::exit(___);}
#if 0
# 8819
{ 
# 8820
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8822
return make_uint4(v.x, v.y, v.z, v.w); 
# 8823
} 
#endif
# 8897 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8902
::exit(___);}
#if 0
# 8898
{ 
# 8899
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8901
return v.x; 
# 8902
} 
#endif
# 8904 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8905
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8909
::exit(___);}
#if 0
# 8905
{ 
# 8906
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8908
return make_float1(v.x); 
# 8909
} 
#endif
# 8911 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8912
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8916
::exit(___);}
#if 0
# 8912
{ 
# 8913
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8915
return make_float2(v.x, v.y); 
# 8916
} 
#endif
# 8918 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8919
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8923
::exit(___);}
#if 0
# 8919
{ 
# 8920
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8922
return make_float4(v.x, v.y, v.z, v.w); 
# 8923
} 
#endif
# 8931 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8932
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8941
::exit(___);}
#if 0
# 8932
{ 
# 8936
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8938
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8940
return w.x; 
# 8941
} 
#endif
# 8943 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8944
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8949
::exit(___);}
#if 0
# 8944
{ 
# 8945
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8946
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8948
return w.x; 
# 8949
} 
#endif
# 8951 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8952
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8957
::exit(___);}
#if 0
# 8952
{ 
# 8953
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8954
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8956
return w.x; 
# 8957
} 
#endif
# 8959 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8960
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8965
::exit(___);}
#if 0
# 8960
{ 
# 8961
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8962
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8964
return make_float1(w.x); 
# 8965
} 
#endif
# 8967 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8968
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8973
::exit(___);}
#if 0
# 8968
{ 
# 8969
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8970
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8972
return make_float1(w.x); 
# 8973
} 
#endif
# 8975 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8976
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8981
::exit(___);}
#if 0
# 8976
{ 
# 8977
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8978
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8980
return make_float2(w.x, w.y); 
# 8981
} 
#endif
# 8983 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8984
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8989
::exit(___);}
#if 0
# 8984
{ 
# 8985
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8986
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8988
return make_float2(w.x, w.y); 
# 8989
} 
#endif
# 8991 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 8992
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 8997
::exit(___);}
#if 0
# 8992
{ 
# 8993
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 8994
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 8996
return make_float4(w.x, w.y, w.z, w.w); 
# 8997
} 
#endif
# 8999 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 9000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 9005
::exit(___);}
#if 0
# 9000
{ 
# 9001
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 9002
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9004
return make_float4(w.x, w.y, w.z, w.w); 
# 9005
} 
#endif
# 9013 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 9014
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 9019
::exit(___);}
#if 0
# 9014
{ 
# 9015
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 9016
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9018
return w.x; 
# 9019
} 
#endif
# 9021 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 9022
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 9027
::exit(___);}
#if 0
# 9022
{ 
# 9023
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 9024
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9026
return w.x; 
# 9027
} 
#endif
# 9029 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 9030
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 9035
::exit(___);}
#if 0
# 9030
{ 
# 9031
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 9032
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9034
return make_float1(w.x); 
# 9035
} 
#endif
# 9037 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 9038
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 9043
::exit(___);}
#if 0
# 9038
{ 
# 9039
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 9040
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9042
return make_float1(w.x); 
# 9043
} 
#endif
# 9045 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 9046
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 9051
::exit(___);}
#if 0
# 9046
{ 
# 9047
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 9048
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9050
return make_float2(w.x, w.y); 
# 9051
} 
#endif
# 9053 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 9054
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 9059
::exit(___);}
#if 0
# 9054
{ 
# 9055
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 9056
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9058
return make_float2(w.x, w.y); 
# 9059
} 
#endif
# 9061 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 9062
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 9067
::exit(___);}
#if 0
# 9062
{ 
# 9063
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 9064
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9066
return make_float4(w.x, w.y, w.z, w.w); 
# 9067
} 
#endif
# 9069 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 9070
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 9075
::exit(___);}
#if 0
# 9070
{ 
# 9071
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
# 9072
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9074
return make_float4(w.x, w.y, w.z, w.w); 
# 9075
} 
#endif
# 9083 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char tex3DGrad(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9084
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9092
::exit(___);}
#if 0
# 9084
{ 
# 9088
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9091
return (char)(v.x); 
# 9092
} 
#endif
# 9094 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline signed char tex3DGrad(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9099
::exit(___);}
#if 0
# 9095
{ 
# 9096
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9098
return (signed char)(v.x); 
# 9099
} 
#endif
# 9101 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned char tex3DGrad(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9102
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9106
::exit(___);}
#if 0
# 9102
{ 
# 9103
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9105
return (unsigned char)(v.x); 
# 9106
} 
#endif
# 9108 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char1 tex3DGrad(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9109
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9113
::exit(___);}
#if 0
# 9109
{ 
# 9110
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9112
return make_char1(v.x); 
# 9113
} 
#endif
# 9115 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar1 tex3DGrad(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9116
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9120
::exit(___);}
#if 0
# 9116
{ 
# 9117
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9119
return make_uchar1(v.x); 
# 9120
} 
#endif
# 9122 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char2 tex3DGrad(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9123
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9127
::exit(___);}
#if 0
# 9123
{ 
# 9124
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9126
return make_char2(v.x, v.y); 
# 9127
} 
#endif
# 9129 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar2 tex3DGrad(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9130
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9134
::exit(___);}
#if 0
# 9130
{ 
# 9131
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9133
return make_uchar2(v.x, v.y); 
# 9134
} 
#endif
# 9136 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline char4 tex3DGrad(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9137
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9141
::exit(___);}
#if 0
# 9137
{ 
# 9138
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9140
return make_char4(v.x, v.y, v.z, v.w); 
# 9141
} 
#endif
# 9143 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uchar4 tex3DGrad(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9144
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9148
::exit(___);}
#if 0
# 9144
{ 
# 9145
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9147
return make_uchar4(v.x, v.y, v.z, v.w); 
# 9148
} 
#endif
# 9156 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short tex3DGrad(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9157
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9161
::exit(___);}
#if 0
# 9157
{ 
# 9158
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9160
return (short)(v.x); 
# 9161
} 
#endif
# 9163 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned short tex3DGrad(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9164
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9168
::exit(___);}
#if 0
# 9164
{ 
# 9165
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9167
return (unsigned short)(v.x); 
# 9168
} 
#endif
# 9170 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short1 tex3DGrad(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9171
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9175
::exit(___);}
#if 0
# 9171
{ 
# 9172
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9174
return make_short1(v.x); 
# 9175
} 
#endif
# 9177 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort1 tex3DGrad(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9178
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9182
::exit(___);}
#if 0
# 9178
{ 
# 9179
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9181
return make_ushort1(v.x); 
# 9182
} 
#endif
# 9184 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short2 tex3DGrad(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9185
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9189
::exit(___);}
#if 0
# 9185
{ 
# 9186
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9188
return make_short2(v.x, v.y); 
# 9189
} 
#endif
# 9191 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort2 tex3DGrad(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9192
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9196
::exit(___);}
#if 0
# 9192
{ 
# 9193
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9195
return make_ushort2(v.x, v.y); 
# 9196
} 
#endif
# 9198 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline short4 tex3DGrad(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9199
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9203
::exit(___);}
#if 0
# 9199
{ 
# 9200
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9202
return make_short4(v.x, v.y, v.z, v.w); 
# 9203
} 
#endif
# 9205 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline ushort4 tex3DGrad(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9206
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9210
::exit(___);}
#if 0
# 9206
{ 
# 9207
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9209
return make_ushort4(v.x, v.y, v.z, v.w); 
# 9210
} 
#endif
# 9218 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int tex3DGrad(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9219
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9223
::exit(___);}
#if 0
# 9219
{ 
# 9220
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9222
return (int)(v.x); 
# 9223
} 
#endif
# 9225 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline unsigned tex3DGrad(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9226
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9230
::exit(___);}
#if 0
# 9226
{ 
# 9227
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9229
return (unsigned)(v.x); 
# 9230
} 
#endif
# 9232 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int1 tex3DGrad(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9233
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9237
::exit(___);}
#if 0
# 9233
{ 
# 9234
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9236
return make_int1(v.x); 
# 9237
} 
#endif
# 9239 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint1 tex3DGrad(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9240
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9244
::exit(___);}
#if 0
# 9240
{ 
# 9241
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9243
return make_uint1(v.x); 
# 9244
} 
#endif
# 9246 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int2 tex3DGrad(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9247
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9251
::exit(___);}
#if 0
# 9247
{ 
# 9248
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9250
return make_int2(v.x, v.y); 
# 9251
} 
#endif
# 9253 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint2 tex3DGrad(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9254
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9258
::exit(___);}
#if 0
# 9254
{ 
# 9255
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9257
return make_uint2(v.x, v.y); 
# 9258
} 
#endif
# 9260 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline int4 tex3DGrad(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9261
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9265
::exit(___);}
#if 0
# 9261
{ 
# 9262
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9264
return make_int4(v.x, v.y, v.z, v.w); 
# 9265
} 
#endif
# 9267 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline uint4 tex3DGrad(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9268
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9272
::exit(___);}
#if 0
# 9268
{ 
# 9269
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9271
return make_uint4(v.x, v.y, v.z, v.w); 
# 9272
} 
#endif
# 9346 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9347
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9351
::exit(___);}
#if 0
# 9347
{ 
# 9348
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9350
return v.x; 
# 9351
} 
#endif
# 9353 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9354
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9358
::exit(___);}
#if 0
# 9354
{ 
# 9355
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9357
return make_float1(v.x); 
# 9358
} 
#endif
# 9360 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9361
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9365
::exit(___);}
#if 0
# 9361
{ 
# 9362
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9364
return make_float2(v.x, v.y); 
# 9365
} 
#endif
# 9367 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9368
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9372
::exit(___);}
#if 0
# 9368
{ 
# 9369
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9371
return make_float4(v.x, v.y, v.z, v.w); 
# 9372
} 
#endif
# 9380 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9381
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9390
::exit(___);}
#if 0
# 9381
{ 
# 9385
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9387
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9389
return w.x; 
# 9390
} 
#endif
# 9392 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9393
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9398
::exit(___);}
#if 0
# 9393
{ 
# 9394
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9395
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9397
return w.x; 
# 9398
} 
#endif
# 9400 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9401
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9406
::exit(___);}
#if 0
# 9401
{ 
# 9402
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9403
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9405
return w.x; 
# 9406
} 
#endif
# 9408 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9409
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9414
::exit(___);}
#if 0
# 9409
{ 
# 9410
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9411
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9413
return make_float1(w.x); 
# 9414
} 
#endif
# 9416 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9417
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9422
::exit(___);}
#if 0
# 9417
{ 
# 9418
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9419
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9421
return make_float1(w.x); 
# 9422
} 
#endif
# 9424 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9425
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9430
::exit(___);}
#if 0
# 9425
{ 
# 9426
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9427
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9429
return make_float2(w.x, w.y); 
# 9430
} 
#endif
# 9432 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9433
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9438
::exit(___);}
#if 0
# 9433
{ 
# 9434
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9435
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9437
return make_float2(w.x, w.y); 
# 9438
} 
#endif
# 9440 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9441
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9446
::exit(___);}
#if 0
# 9441
{ 
# 9442
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9443
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9445
return make_float4(w.x, w.y, w.z, w.w); 
# 9446
} 
#endif
# 9448 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9449
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9454
::exit(___);}
#if 0
# 9449
{ 
# 9450
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9451
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9453
return make_float4(w.x, w.y, w.z, w.w); 
# 9454
} 
#endif
# 9462 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9463
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9468
::exit(___);}
#if 0
# 9463
{ 
# 9464
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9465
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9467
return w.x; 
# 9468
} 
#endif
# 9470 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float tex3DGrad(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9471
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9476
::exit(___);}
#if 0
# 9471
{ 
# 9472
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9473
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9475
return w.x; 
# 9476
} 
#endif
# 9478 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9479
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9484
::exit(___);}
#if 0
# 9479
{ 
# 9480
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9481
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9483
return make_float1(w.x); 
# 9484
} 
#endif
# 9486 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float1 tex3DGrad(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9487
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9492
::exit(___);}
#if 0
# 9487
{ 
# 9488
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9489
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9491
return make_float1(w.x); 
# 9492
} 
#endif
# 9494 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9495
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9500
::exit(___);}
#if 0
# 9495
{ 
# 9496
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9497
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9499
return make_float2(w.x, w.y); 
# 9500
} 
#endif
# 9502 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float2 tex3DGrad(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9503
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9508
::exit(___);}
#if 0
# 9503
{ 
# 9504
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9505
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9507
return make_float2(w.x, w.y); 
# 9508
} 
#endif
# 9510 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9511
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9516
::exit(___);}
#if 0
# 9511
{ 
# 9512
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9513
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9515
return make_float4(w.x, w.y, w.z, w.w); 
# 9516
} 
#endif
# 9518 "/usr/local/cuda/bin/..//include/texture_fetch_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline float4 tex3DGrad(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 9519
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 9524
::exit(___);}
#if 0
# 9519
{ 
# 9520
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
# 9521
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
# 9523
return make_float4(w.x, w.y, w.z, w.w); 
# 9524
} 
#endif
# 70 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char *retVal, cudaTextureObject_t texObject, int x) 
# 71
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 80
::exit(___);}
#if 0
# 71
{ 
# 76
int4 tmp; 
# 77
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 79
(*retVal) = ((char)(tmp.x)); 
# 80
} 
#endif
# 81 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(signed char *retVal, cudaTextureObject_t texObject, int x) 
# 82
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 86
::exit(___);}
#if 0
# 82
{ 
# 83
int4 tmp; 
# 84
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 85
(*retVal) = ((signed char)(tmp.x)); 
# 86
} 
#endif
# 88 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char1 *retVal, cudaTextureObject_t texObject, int x) 
# 89
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 93
::exit(___);}
#if 0
# 89
{ 
# 90
int4 tmp; 
# 91
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 92
(*retVal) = make_char1(tmp.x); 
# 93
} 
#endif
# 95 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char2 *retVal, cudaTextureObject_t texObject, int x) 
# 96
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 100
::exit(___);}
#if 0
# 96
{ 
# 97
int4 tmp; 
# 98
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 99
(*retVal) = make_char2(tmp.x, tmp.y); 
# 100
} 
#endif
# 102 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(char4 *retVal, cudaTextureObject_t texObject, int x) 
# 103
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 107
::exit(___);}
#if 0
# 103
{ 
# 104
int4 tmp; 
# 105
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 106
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 107
} 
#endif
# 109 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(unsigned char *retVal, cudaTextureObject_t texObject, int x) 
# 110
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 114
::exit(___);}
#if 0
# 110
{ 
# 111
uint4 tmp; 
# 112
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 113
(*retVal) = ((unsigned char)(tmp.x)); 
# 114
} 
#endif
# 116 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uchar1 *retVal, cudaTextureObject_t texObject, int x) 
# 117
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 121
::exit(___);}
#if 0
# 117
{ 
# 118
uint4 tmp; 
# 119
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 120
(*retVal) = make_uchar1(tmp.x); 
# 121
} 
#endif
# 123 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uchar2 *retVal, cudaTextureObject_t texObject, int x) 
# 124
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 128
::exit(___);}
#if 0
# 124
{ 
# 125
uint4 tmp; 
# 126
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 127
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 128
} 
#endif
# 130 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uchar4 *retVal, cudaTextureObject_t texObject, int x) 
# 131
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 135
::exit(___);}
#if 0
# 131
{ 
# 132
uint4 tmp; 
# 133
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 134
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 135
} 
#endif
# 143 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short *retVal, cudaTextureObject_t texObject, int x) 
# 144
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 148
::exit(___);}
#if 0
# 144
{ 
# 145
int4 tmp; 
# 146
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 147
(*retVal) = ((short)(tmp.x)); 
# 148
} 
#endif
# 150 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short1 *retVal, cudaTextureObject_t texObject, int x) 
# 151
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 155
::exit(___);}
#if 0
# 151
{ 
# 152
int4 tmp; 
# 153
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 154
(*retVal) = make_short1(tmp.x); 
# 155
} 
#endif
# 157 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short2 *retVal, cudaTextureObject_t texObject, int x) 
# 158
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 162
::exit(___);}
#if 0
# 158
{ 
# 159
int4 tmp; 
# 160
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 161
(*retVal) = make_short2(tmp.x, tmp.y); 
# 162
} 
#endif
# 164 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(short4 *retVal, cudaTextureObject_t texObject, int x) 
# 165
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 169
::exit(___);}
#if 0
# 165
{ 
# 166
int4 tmp; 
# 167
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 168
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 169
} 
#endif
# 171 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(unsigned short *retVal, cudaTextureObject_t texObject, int x) 
# 172
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 176
::exit(___);}
#if 0
# 172
{ 
# 173
uint4 tmp; 
# 174
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 175
(*retVal) = ((unsigned short)(tmp.x)); 
# 176
} 
#endif
# 178 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(ushort1 *retVal, cudaTextureObject_t texObject, int x) 
# 179
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 183
::exit(___);}
#if 0
# 179
{ 
# 180
uint4 tmp; 
# 181
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 182
(*retVal) = make_ushort1(tmp.x); 
# 183
} 
#endif
# 185 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(ushort2 *retVal, cudaTextureObject_t texObject, int x) 
# 186
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 190
::exit(___);}
#if 0
# 186
{ 
# 187
uint4 tmp; 
# 188
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 189
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 190
} 
#endif
# 192 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(ushort4 *retVal, cudaTextureObject_t texObject, int x) 
# 193
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 197
::exit(___);}
#if 0
# 193
{ 
# 194
uint4 tmp; 
# 195
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 196
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 197
} 
#endif
# 205 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int *retVal, cudaTextureObject_t texObject, int x) 
# 206
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 210
::exit(___);}
#if 0
# 206
{ 
# 207
int4 tmp; 
# 208
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 209
(*retVal) = ((int)(tmp.x)); 
# 210
} 
#endif
# 212 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int1 *retVal, cudaTextureObject_t texObject, int x) 
# 213
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 217
::exit(___);}
#if 0
# 213
{ 
# 214
int4 tmp; 
# 215
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 216
(*retVal) = make_int1(tmp.x); 
# 217
} 
#endif
# 219 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int2 *retVal, cudaTextureObject_t texObject, int x) 
# 220
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 224
::exit(___);}
#if 0
# 220
{ 
# 221
int4 tmp; 
# 222
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 223
(*retVal) = make_int2(tmp.x, tmp.y); 
# 224
} 
#endif
# 226 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(int4 *retVal, cudaTextureObject_t texObject, int x) 
# 227
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 231
::exit(___);}
#if 0
# 227
{ 
# 228
int4 tmp; 
# 229
__asm__ volatile("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 230
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 231
} 
#endif
# 233 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(unsigned *retVal, cudaTextureObject_t texObject, int x) 
# 234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 238
::exit(___);}
#if 0
# 234
{ 
# 235
uint4 tmp; 
# 236
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 237
(*retVal) = ((unsigned)(tmp.x)); 
# 238
} 
#endif
# 240 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uint1 *retVal, cudaTextureObject_t texObject, int x) 
# 241
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 245
::exit(___);}
#if 0
# 241
{ 
# 242
uint4 tmp; 
# 243
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 244
(*retVal) = make_uint1(tmp.x); 
# 245
} 
#endif
# 247 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uint2 *retVal, cudaTextureObject_t texObject, int x) 
# 248
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 252
::exit(___);}
#if 0
# 248
{ 
# 249
uint4 tmp; 
# 250
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 251
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 252
} 
#endif
# 254 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(uint4 *retVal, cudaTextureObject_t texObject, int x) 
# 255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 259
::exit(___);}
#if 0
# 255
{ 
# 256
uint4 tmp; 
# 257
__asm__ volatile("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (x)); 
# 258
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 259
} 
#endif
# 334 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float *retVal, cudaTextureObject_t texObject, int x) 
# 335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 339
::exit(___);}
#if 0
# 335
{ 
# 336
float4 tmp; 
# 337
__asm__ volatile("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (x)); 
# 338
(*retVal) = ((float)(tmp.x)); 
# 339
} 
#endif
# 341 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float1 *retVal, cudaTextureObject_t texObject, int x) 
# 342
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 346
::exit(___);}
#if 0
# 342
{ 
# 343
float4 tmp; 
# 344
__asm__ volatile("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (x)); 
# 345
(*retVal) = make_float1(tmp.x); 
# 346
} 
#endif
# 348 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float2 *retVal, cudaTextureObject_t texObject, int x) 
# 349
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 353
::exit(___);}
#if 0
# 349
{ 
# 350
float4 tmp; 
# 351
__asm__ volatile("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (x)); 
# 352
(*retVal) = make_float2(tmp.x, tmp.y); 
# 353
} 
#endif
# 355 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1Dfetch(float4 *retVal, cudaTextureObject_t texObject, int x) 
# 356
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 360
::exit(___);}
#if 0
# 356
{ 
# 357
float4 tmp; 
# 358
__asm__ volatile("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (x)); 
# 359
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 360
} 
#endif
# 368 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 369
__attribute((always_inline)) __attribute__((unused)) static inline T tex1Dfetch(cudaTextureObject_t texObject, int x) 
# 370
{int volatile ___ = 1;(void)texObject;(void)x;
# 374
::exit(___);}
#if 0
# 370
{ 
# 371
T ret; 
# 372
tex1Dfetch(&ret, texObject, x); 
# 373
return ret; 
# 374
} 
#endif
# 382 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char *retVal, cudaTextureObject_t texObject, float x) 
# 383
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 392
::exit(___);}
#if 0
# 383
{ 
# 388
int4 tmp; 
# 389
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 391
(*retVal) = ((char)(tmp.x)); 
# 392
} 
#endif
# 393 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(signed char *retVal, cudaTextureObject_t texObject, float x) 
# 394
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 398
::exit(___);}
#if 0
# 394
{ 
# 395
int4 tmp; 
# 396
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 397
(*retVal) = ((signed char)(tmp.x)); 
# 398
} 
#endif
# 400 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char1 *retVal, cudaTextureObject_t texObject, float x) 
# 401
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 405
::exit(___);}
#if 0
# 401
{ 
# 402
int4 tmp; 
# 403
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 404
(*retVal) = make_char1(tmp.x); 
# 405
} 
#endif
# 407 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char2 *retVal, cudaTextureObject_t texObject, float x) 
# 408
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 412
::exit(___);}
#if 0
# 408
{ 
# 409
int4 tmp; 
# 410
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 411
(*retVal) = make_char2(tmp.x, tmp.y); 
# 412
} 
#endif
# 414 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(char4 *retVal, cudaTextureObject_t texObject, float x) 
# 415
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 419
::exit(___);}
#if 0
# 415
{ 
# 416
int4 tmp; 
# 417
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 418
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 419
} 
#endif
# 421 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(unsigned char *retVal, cudaTextureObject_t texObject, float x) 
# 422
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 426
::exit(___);}
#if 0
# 422
{ 
# 423
uint4 tmp; 
# 424
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 425
(*retVal) = ((unsigned char)(tmp.x)); 
# 426
} 
#endif
# 428 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uchar1 *retVal, cudaTextureObject_t texObject, float x) 
# 429
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 433
::exit(___);}
#if 0
# 429
{ 
# 430
uint4 tmp; 
# 431
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 432
(*retVal) = make_uchar1(tmp.x); 
# 433
} 
#endif
# 435 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uchar2 *retVal, cudaTextureObject_t texObject, float x) 
# 436
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 440
::exit(___);}
#if 0
# 436
{ 
# 437
uint4 tmp; 
# 438
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 439
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 440
} 
#endif
# 442 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uchar4 *retVal, cudaTextureObject_t texObject, float x) 
# 443
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 447
::exit(___);}
#if 0
# 443
{ 
# 444
uint4 tmp; 
# 445
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 446
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 447
} 
#endif
# 455 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short *retVal, cudaTextureObject_t texObject, float x) 
# 456
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 460
::exit(___);}
#if 0
# 456
{ 
# 457
int4 tmp; 
# 458
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 459
(*retVal) = ((short)(tmp.x)); 
# 460
} 
#endif
# 462 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short1 *retVal, cudaTextureObject_t texObject, float x) 
# 463
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 467
::exit(___);}
#if 0
# 463
{ 
# 464
int4 tmp; 
# 465
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 466
(*retVal) = make_short1(tmp.x); 
# 467
} 
#endif
# 469 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short2 *retVal, cudaTextureObject_t texObject, float x) 
# 470
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 474
::exit(___);}
#if 0
# 470
{ 
# 471
int4 tmp; 
# 472
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 473
(*retVal) = make_short2(tmp.x, tmp.y); 
# 474
} 
#endif
# 476 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(short4 *retVal, cudaTextureObject_t texObject, float x) 
# 477
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 481
::exit(___);}
#if 0
# 477
{ 
# 478
int4 tmp; 
# 479
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 480
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 481
} 
#endif
# 483 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(unsigned short *retVal, cudaTextureObject_t texObject, float x) 
# 484
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 488
::exit(___);}
#if 0
# 484
{ 
# 485
uint4 tmp; 
# 486
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 487
(*retVal) = ((unsigned short)(tmp.x)); 
# 488
} 
#endif
# 490 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(ushort1 *retVal, cudaTextureObject_t texObject, float x) 
# 491
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 495
::exit(___);}
#if 0
# 491
{ 
# 492
uint4 tmp; 
# 493
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 494
(*retVal) = make_ushort1(tmp.x); 
# 495
} 
#endif
# 497 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(ushort2 *retVal, cudaTextureObject_t texObject, float x) 
# 498
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 502
::exit(___);}
#if 0
# 498
{ 
# 499
uint4 tmp; 
# 500
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 501
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 502
} 
#endif
# 504 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(ushort4 *retVal, cudaTextureObject_t texObject, float x) 
# 505
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 509
::exit(___);}
#if 0
# 505
{ 
# 506
uint4 tmp; 
# 507
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 508
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 509
} 
#endif
# 517 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int *retVal, cudaTextureObject_t texObject, float x) 
# 518
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 522
::exit(___);}
#if 0
# 518
{ 
# 519
int4 tmp; 
# 520
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 521
(*retVal) = ((int)(tmp.x)); 
# 522
} 
#endif
# 524 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int1 *retVal, cudaTextureObject_t texObject, float x) 
# 525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 529
::exit(___);}
#if 0
# 525
{ 
# 526
int4 tmp; 
# 527
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 528
(*retVal) = make_int1(tmp.x); 
# 529
} 
#endif
# 531 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int2 *retVal, cudaTextureObject_t texObject, float x) 
# 532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 536
::exit(___);}
#if 0
# 532
{ 
# 533
int4 tmp; 
# 534
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 535
(*retVal) = make_int2(tmp.x, tmp.y); 
# 536
} 
#endif
# 538 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(int4 *retVal, cudaTextureObject_t texObject, float x) 
# 539
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 543
::exit(___);}
#if 0
# 539
{ 
# 540
int4 tmp; 
# 541
__asm__ volatile("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 542
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 543
} 
#endif
# 545 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(unsigned *retVal, cudaTextureObject_t texObject, float x) 
# 546
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 550
::exit(___);}
#if 0
# 546
{ 
# 547
uint4 tmp; 
# 548
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 549
(*retVal) = ((unsigned)(tmp.x)); 
# 550
} 
#endif
# 552 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uint1 *retVal, cudaTextureObject_t texObject, float x) 
# 553
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 557
::exit(___);}
#if 0
# 553
{ 
# 554
uint4 tmp; 
# 555
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 556
(*retVal) = make_uint1(tmp.x); 
# 557
} 
#endif
# 559 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uint2 *retVal, cudaTextureObject_t texObject, float x) 
# 560
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 564
::exit(___);}
#if 0
# 560
{ 
# 561
uint4 tmp; 
# 562
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 563
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 564
} 
#endif
# 566 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(uint4 *retVal, cudaTextureObject_t texObject, float x) 
# 567
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 571
::exit(___);}
#if 0
# 567
{ 
# 568
uint4 tmp; 
# 569
__asm__ volatile("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x)); 
# 570
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 571
} 
#endif
# 646 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float *retVal, cudaTextureObject_t texObject, float x) 
# 647
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 651
::exit(___);}
#if 0
# 647
{ 
# 648
float4 tmp; 
# 649
__asm__ volatile("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x)); 
# 650
(*retVal) = ((float)(tmp.x)); 
# 651
} 
#endif
# 653 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float1 *retVal, cudaTextureObject_t texObject, float x) 
# 654
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 658
::exit(___);}
#if 0
# 654
{ 
# 655
float4 tmp; 
# 656
__asm__ volatile("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x)); 
# 657
(*retVal) = make_float1(tmp.x); 
# 658
} 
#endif
# 660 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float2 *retVal, cudaTextureObject_t texObject, float x) 
# 661
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 665
::exit(___);}
#if 0
# 661
{ 
# 662
float4 tmp; 
# 663
__asm__ volatile("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x)); 
# 664
(*retVal) = make_float2(tmp.x, tmp.y); 
# 665
} 
#endif
# 667 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1D(float4 *retVal, cudaTextureObject_t texObject, float x) 
# 668
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
# 672
::exit(___);}
#if 0
# 668
{ 
# 669
float4 tmp; 
# 670
__asm__ volatile("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x)); 
# 671
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 672
} 
#endif
# 680 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 681
__attribute((always_inline)) __attribute__((unused)) static inline T tex1D(cudaTextureObject_t texObject, float x) 
# 682
{int volatile ___ = 1;(void)texObject;(void)x;
# 686
::exit(___);}
#if 0
# 682
{ 
# 683
T ret; 
# 684
tex1D(&ret, texObject, x); 
# 685
return ret; 
# 686
} 
#endif
# 694 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char *retVal, cudaTextureObject_t texObject, float x, float y) 
# 695
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 704
::exit(___);}
#if 0
# 695
{ 
# 700
int4 tmp; 
# 701
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 703
(*retVal) = ((char)(tmp.x)); 
# 704
} 
#endif
# 705 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(signed char *retVal, cudaTextureObject_t texObject, float x, float y) 
# 706
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 710
::exit(___);}
#if 0
# 706
{ 
# 707
int4 tmp; 
# 708
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 709
(*retVal) = ((signed char)(tmp.x)); 
# 710
} 
#endif
# 712 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 713
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 717
::exit(___);}
#if 0
# 713
{ 
# 714
int4 tmp; 
# 715
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 716
(*retVal) = make_char1(tmp.x); 
# 717
} 
#endif
# 719 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 720
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 724
::exit(___);}
#if 0
# 720
{ 
# 721
int4 tmp; 
# 722
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 723
(*retVal) = make_char2(tmp.x, tmp.y); 
# 724
} 
#endif
# 726 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(char4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 727
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 731
::exit(___);}
#if 0
# 727
{ 
# 728
int4 tmp; 
# 729
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 730
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 731
} 
#endif
# 733 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y) 
# 734
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 738
::exit(___);}
#if 0
# 734
{ 
# 735
uint4 tmp; 
# 736
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 737
(*retVal) = ((unsigned char)(tmp.x)); 
# 738
} 
#endif
# 740 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 741
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 745
::exit(___);}
#if 0
# 741
{ 
# 742
uint4 tmp; 
# 743
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 744
(*retVal) = make_uchar1(tmp.x); 
# 745
} 
#endif
# 747 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 748
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 752
::exit(___);}
#if 0
# 748
{ 
# 749
uint4 tmp; 
# 750
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 751
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 752
} 
#endif
# 754 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 755
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 759
::exit(___);}
#if 0
# 755
{ 
# 756
uint4 tmp; 
# 757
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 758
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 759
} 
#endif
# 767 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short *retVal, cudaTextureObject_t texObject, float x, float y) 
# 768
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 772
::exit(___);}
#if 0
# 768
{ 
# 769
int4 tmp; 
# 770
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 771
(*retVal) = ((short)(tmp.x)); 
# 772
} 
#endif
# 774 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 775
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 779
::exit(___);}
#if 0
# 775
{ 
# 776
int4 tmp; 
# 777
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 778
(*retVal) = make_short1(tmp.x); 
# 779
} 
#endif
# 781 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 782
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 786
::exit(___);}
#if 0
# 782
{ 
# 783
int4 tmp; 
# 784
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 785
(*retVal) = make_short2(tmp.x, tmp.y); 
# 786
} 
#endif
# 788 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(short4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 793
::exit(___);}
#if 0
# 789
{ 
# 790
int4 tmp; 
# 791
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 792
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 793
} 
#endif
# 795 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y) 
# 796
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 800
::exit(___);}
#if 0
# 796
{ 
# 797
uint4 tmp; 
# 798
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 799
(*retVal) = ((unsigned short)(tmp.x)); 
# 800
} 
#endif
# 802 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 803
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 807
::exit(___);}
#if 0
# 803
{ 
# 804
uint4 tmp; 
# 805
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 806
(*retVal) = make_ushort1(tmp.x); 
# 807
} 
#endif
# 809 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 810
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 814
::exit(___);}
#if 0
# 810
{ 
# 811
uint4 tmp; 
# 812
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 813
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 814
} 
#endif
# 816 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 817
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 821
::exit(___);}
#if 0
# 817
{ 
# 818
uint4 tmp; 
# 819
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 820
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 821
} 
#endif
# 829 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int *retVal, cudaTextureObject_t texObject, float x, float y) 
# 830
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 834
::exit(___);}
#if 0
# 830
{ 
# 831
int4 tmp; 
# 832
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 833
(*retVal) = ((int)(tmp.x)); 
# 834
} 
#endif
# 836 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 841
::exit(___);}
#if 0
# 837
{ 
# 838
int4 tmp; 
# 839
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 840
(*retVal) = make_int1(tmp.x); 
# 841
} 
#endif
# 843 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 844
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 848
::exit(___);}
#if 0
# 844
{ 
# 845
int4 tmp; 
# 846
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 847
(*retVal) = make_int2(tmp.x, tmp.y); 
# 848
} 
#endif
# 850 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(int4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 851
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 855
::exit(___);}
#if 0
# 851
{ 
# 852
int4 tmp; 
# 853
__asm__ volatile("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 854
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 855
} 
#endif
# 857 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(unsigned *retVal, cudaTextureObject_t texObject, float x, float y) 
# 858
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 862
::exit(___);}
#if 0
# 858
{ 
# 859
uint4 tmp; 
# 860
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 861
(*retVal) = ((unsigned)(tmp.x)); 
# 862
} 
#endif
# 864 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 865
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 869
::exit(___);}
#if 0
# 865
{ 
# 866
uint4 tmp; 
# 867
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 868
(*retVal) = make_uint1(tmp.x); 
# 869
} 
#endif
# 871 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 872
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 876
::exit(___);}
#if 0
# 872
{ 
# 873
uint4 tmp; 
# 874
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 875
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 876
} 
#endif
# 878 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 879
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 883
::exit(___);}
#if 0
# 879
{ 
# 880
uint4 tmp; 
# 881
__asm__ volatile("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 882
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 883
} 
#endif
# 958 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float *retVal, cudaTextureObject_t texObject, float x, float y) 
# 959
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 963
::exit(___);}
#if 0
# 959
{ 
# 960
float4 tmp; 
# 961
__asm__ volatile("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 962
(*retVal) = ((float)(tmp.x)); 
# 963
} 
#endif
# 965 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float1 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 966
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 970
::exit(___);}
#if 0
# 966
{ 
# 967
float4 tmp; 
# 968
__asm__ volatile("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 969
(*retVal) = make_float1(tmp.x); 
# 970
} 
#endif
# 972 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float2 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 973
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 977
::exit(___);}
#if 0
# 973
{ 
# 974
float4 tmp; 
# 975
__asm__ volatile("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 976
(*retVal) = make_float2(tmp.x, tmp.y); 
# 977
} 
#endif
# 979 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2D(float4 *retVal, cudaTextureObject_t texObject, float x, float y) 
# 980
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
# 984
::exit(___);}
#if 0
# 980
{ 
# 981
float4 tmp; 
# 982
__asm__ volatile("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 983
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 984
} 
#endif
# 992 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 993
__attribute((always_inline)) __attribute__((unused)) static inline T tex2D(cudaTextureObject_t texObject, float x, float y) 
# 994
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;
# 998
::exit(___);}
#if 0
# 994
{ 
# 995
T ret; 
# 996
tex2D(&ret, texObject, x, y); 
# 997
return ret; 
# 998
} 
#endif
# 1006 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1007
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1016
::exit(___);}
#if 0
# 1007
{ 
# 1012
int4 tmp; 
# 1013
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1015
(*retVal) = ((char)(tmp.x)); 
# 1016
} 
#endif
# 1017 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1018
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1022
::exit(___);}
#if 0
# 1018
{ 
# 1019
int4 tmp; 
# 1020
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1021
(*retVal) = ((signed char)(tmp.x)); 
# 1022
} 
#endif
# 1024 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1025
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1029
::exit(___);}
#if 0
# 1025
{ 
# 1026
int4 tmp; 
# 1027
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1028
(*retVal) = make_char1(tmp.x); 
# 1029
} 
#endif
# 1031 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1032
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1036
::exit(___);}
#if 0
# 1032
{ 
# 1033
int4 tmp; 
# 1034
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1035
(*retVal) = make_char2(tmp.x, tmp.y); 
# 1036
} 
#endif
# 1038 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1039
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1043
::exit(___);}
#if 0
# 1039
{ 
# 1040
int4 tmp; 
# 1041
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1042
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1043
} 
#endif
# 1045 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1046
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1050
::exit(___);}
#if 0
# 1046
{ 
# 1047
uint4 tmp; 
# 1048
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1049
(*retVal) = ((unsigned char)(tmp.x)); 
# 1050
} 
#endif
# 1052 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1053
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1057
::exit(___);}
#if 0
# 1053
{ 
# 1054
uint4 tmp; 
# 1055
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1056
(*retVal) = make_uchar1(tmp.x); 
# 1057
} 
#endif
# 1059 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1060
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1064
::exit(___);}
#if 0
# 1060
{ 
# 1061
uint4 tmp; 
# 1062
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1063
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 1064
} 
#endif
# 1066 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1067
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1071
::exit(___);}
#if 0
# 1067
{ 
# 1068
uint4 tmp; 
# 1069
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1070
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1071
} 
#endif
# 1079 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1080
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1084
::exit(___);}
#if 0
# 1080
{ 
# 1081
int4 tmp; 
# 1082
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1083
(*retVal) = ((short)(tmp.x)); 
# 1084
} 
#endif
# 1086 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1087
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1091
::exit(___);}
#if 0
# 1087
{ 
# 1088
int4 tmp; 
# 1089
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1090
(*retVal) = make_short1(tmp.x); 
# 1091
} 
#endif
# 1093 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1094
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1098
::exit(___);}
#if 0
# 1094
{ 
# 1095
int4 tmp; 
# 1096
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1097
(*retVal) = make_short2(tmp.x, tmp.y); 
# 1098
} 
#endif
# 1100 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1101
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1105
::exit(___);}
#if 0
# 1101
{ 
# 1102
int4 tmp; 
# 1103
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1104
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1105
} 
#endif
# 1107 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1108
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1112
::exit(___);}
#if 0
# 1108
{ 
# 1109
uint4 tmp; 
# 1110
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1111
(*retVal) = ((unsigned short)(tmp.x)); 
# 1112
} 
#endif
# 1114 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1115
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1119
::exit(___);}
#if 0
# 1115
{ 
# 1116
uint4 tmp; 
# 1117
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1118
(*retVal) = make_ushort1(tmp.x); 
# 1119
} 
#endif
# 1121 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1122
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1126
::exit(___);}
#if 0
# 1122
{ 
# 1123
uint4 tmp; 
# 1124
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1125
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 1126
} 
#endif
# 1128 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1129
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1133
::exit(___);}
#if 0
# 1129
{ 
# 1130
uint4 tmp; 
# 1131
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1132
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1133
} 
#endif
# 1141 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1142
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1146
::exit(___);}
#if 0
# 1142
{ 
# 1143
int4 tmp; 
# 1144
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1145
(*retVal) = ((int)(tmp.x)); 
# 1146
} 
#endif
# 1148 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1153
::exit(___);}
#if 0
# 1149
{ 
# 1150
int4 tmp; 
# 1151
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1152
(*retVal) = make_int1(tmp.x); 
# 1153
} 
#endif
# 1155 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1156
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1160
::exit(___);}
#if 0
# 1156
{ 
# 1157
int4 tmp; 
# 1158
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1159
(*retVal) = make_int2(tmp.x, tmp.y); 
# 1160
} 
#endif
# 1162 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1163
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1167
::exit(___);}
#if 0
# 1163
{ 
# 1164
int4 tmp; 
# 1165
__asm__ volatile("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1166
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1167
} 
#endif
# 1169 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1170
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1174
::exit(___);}
#if 0
# 1170
{ 
# 1171
uint4 tmp; 
# 1172
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1173
(*retVal) = ((unsigned)(tmp.x)); 
# 1174
} 
#endif
# 1176 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1177
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1181
::exit(___);}
#if 0
# 1177
{ 
# 1178
uint4 tmp; 
# 1179
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1180
(*retVal) = make_uint1(tmp.x); 
# 1181
} 
#endif
# 1183 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1184
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1188
::exit(___);}
#if 0
# 1184
{ 
# 1185
uint4 tmp; 
# 1186
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1187
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 1188
} 
#endif
# 1190 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1191
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1195
::exit(___);}
#if 0
# 1191
{ 
# 1192
uint4 tmp; 
# 1193
__asm__ volatile("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1194
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1195
} 
#endif
# 1270 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1271
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1275
::exit(___);}
#if 0
# 1271
{ 
# 1272
float4 tmp; 
# 1273
__asm__ volatile("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1274
(*retVal) = ((float)(tmp.x)); 
# 1275
} 
#endif
# 1277 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1278
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1282
::exit(___);}
#if 0
# 1278
{ 
# 1279
float4 tmp; 
# 1280
__asm__ volatile("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1281
(*retVal) = make_float1(tmp.x); 
# 1282
} 
#endif
# 1284 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1285
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1289
::exit(___);}
#if 0
# 1285
{ 
# 1286
float4 tmp; 
# 1287
__asm__ volatile("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1288
(*retVal) = make_float2(tmp.x, tmp.y); 
# 1289
} 
#endif
# 1291 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3D(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1292
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1296
::exit(___);}
#if 0
# 1292
{ 
# 1293
float4 tmp; 
# 1294
__asm__ volatile("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1295
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1296
} 
#endif
# 1304 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 1305
__attribute((always_inline)) __attribute__((unused)) static inline T tex3D(cudaTextureObject_t texObject, float x, float y, float z) 
# 1306
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
# 1310
::exit(___);}
#if 0
# 1306
{ 
# 1307
T ret; 
# 1308
tex3D(&ret, texObject, x, y, z); 
# 1309
return ret; 
# 1310
} 
#endif
# 1318 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1328
::exit(___);}
#if 0
# 1319
{ 
# 1324
int4 tmp; 
# 1325
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1327
(*retVal) = ((char)(tmp.x)); 
# 1328
} 
#endif
# 1329 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1330
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1334
::exit(___);}
#if 0
# 1330
{ 
# 1331
int4 tmp; 
# 1332
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1333
(*retVal) = ((signed char)(tmp.x)); 
# 1334
} 
#endif
# 1336 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1337
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1341
::exit(___);}
#if 0
# 1337
{ 
# 1338
int4 tmp; 
# 1339
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1340
(*retVal) = make_char1(tmp.x); 
# 1341
} 
#endif
# 1343 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1344
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1348
::exit(___);}
#if 0
# 1344
{ 
# 1345
int4 tmp; 
# 1346
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1347
(*retVal) = make_char2(tmp.x, tmp.y); 
# 1348
} 
#endif
# 1350 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1351
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1355
::exit(___);}
#if 0
# 1351
{ 
# 1352
int4 tmp; 
# 1353
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1354
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1355
} 
#endif
# 1357 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1358
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1362
::exit(___);}
#if 0
# 1358
{ 
# 1359
uint4 tmp; 
# 1360
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1361
(*retVal) = ((unsigned char)(tmp.x)); 
# 1362
} 
#endif
# 1364 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1365
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1369
::exit(___);}
#if 0
# 1365
{ 
# 1366
uint4 tmp; 
# 1367
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1368
(*retVal) = make_uchar1(tmp.x); 
# 1369
} 
#endif
# 1371 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1372
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1376
::exit(___);}
#if 0
# 1372
{ 
# 1373
uint4 tmp; 
# 1374
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1375
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 1376
} 
#endif
# 1378 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1379
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1383
::exit(___);}
#if 0
# 1379
{ 
# 1380
uint4 tmp; 
# 1381
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1382
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1383
} 
#endif
# 1391 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1392
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1396
::exit(___);}
#if 0
# 1392
{ 
# 1393
int4 tmp; 
# 1394
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1395
(*retVal) = ((short)(tmp.x)); 
# 1396
} 
#endif
# 1398 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1399
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1403
::exit(___);}
#if 0
# 1399
{ 
# 1400
int4 tmp; 
# 1401
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1402
(*retVal) = make_short1(tmp.x); 
# 1403
} 
#endif
# 1405 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1406
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1410
::exit(___);}
#if 0
# 1406
{ 
# 1407
int4 tmp; 
# 1408
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1409
(*retVal) = make_short2(tmp.x, tmp.y); 
# 1410
} 
#endif
# 1412 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1413
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1417
::exit(___);}
#if 0
# 1413
{ 
# 1414
int4 tmp; 
# 1415
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1416
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1417
} 
#endif
# 1419 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1420
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1424
::exit(___);}
#if 0
# 1420
{ 
# 1421
uint4 tmp; 
# 1422
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1423
(*retVal) = ((unsigned short)(tmp.x)); 
# 1424
} 
#endif
# 1426 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1427
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1431
::exit(___);}
#if 0
# 1427
{ 
# 1428
uint4 tmp; 
# 1429
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1430
(*retVal) = make_ushort1(tmp.x); 
# 1431
} 
#endif
# 1433 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1438
::exit(___);}
#if 0
# 1434
{ 
# 1435
uint4 tmp; 
# 1436
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1437
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 1438
} 
#endif
# 1440 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1441
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1445
::exit(___);}
#if 0
# 1441
{ 
# 1442
uint4 tmp; 
# 1443
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1444
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1445
} 
#endif
# 1453 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1458
::exit(___);}
#if 0
# 1454
{ 
# 1455
int4 tmp; 
# 1456
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1457
(*retVal) = ((int)(tmp.x)); 
# 1458
} 
#endif
# 1460 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1465
::exit(___);}
#if 0
# 1461
{ 
# 1462
int4 tmp; 
# 1463
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1464
(*retVal) = make_int1(tmp.x); 
# 1465
} 
#endif
# 1467 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1468
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1472
::exit(___);}
#if 0
# 1468
{ 
# 1469
int4 tmp; 
# 1470
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1471
(*retVal) = make_int2(tmp.x, tmp.y); 
# 1472
} 
#endif
# 1474 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1475
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1479
::exit(___);}
#if 0
# 1475
{ 
# 1476
int4 tmp; 
# 1477
__asm__ volatile("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1478
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1479
} 
#endif
# 1481 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1482
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1486
::exit(___);}
#if 0
# 1482
{ 
# 1483
uint4 tmp; 
# 1484
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1485
(*retVal) = ((unsigned)(tmp.x)); 
# 1486
} 
#endif
# 1488 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1489
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1493
::exit(___);}
#if 0
# 1489
{ 
# 1490
uint4 tmp; 
# 1491
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1492
(*retVal) = make_uint1(tmp.x); 
# 1493
} 
#endif
# 1495 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1496
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1500
::exit(___);}
#if 0
# 1496
{ 
# 1497
uint4 tmp; 
# 1498
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1499
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 1500
} 
#endif
# 1502 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1503
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1507
::exit(___);}
#if 0
# 1503
{ 
# 1504
uint4 tmp; 
# 1505
__asm__ volatile("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1506
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1507
} 
#endif
# 1582 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1583
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1587
::exit(___);}
#if 0
# 1583
{ 
# 1584
float4 tmp; 
# 1585
__asm__ volatile("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1586
(*retVal) = ((float)(tmp.x)); 
# 1587
} 
#endif
# 1589 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1590
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1594
::exit(___);}
#if 0
# 1590
{ 
# 1591
float4 tmp; 
# 1592
__asm__ volatile("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1593
(*retVal) = make_float1(tmp.x); 
# 1594
} 
#endif
# 1596 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1597
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1601
::exit(___);}
#if 0
# 1597
{ 
# 1598
float4 tmp; 
# 1599
__asm__ volatile("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1600
(*retVal) = make_float2(tmp.x, tmp.y); 
# 1601
} 
#endif
# 1603 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
# 1604
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
# 1608
::exit(___);}
#if 0
# 1604
{ 
# 1605
float4 tmp; 
# 1606
__asm__ volatile("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x)); 
# 1607
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1608
} 
#endif
# 1616 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 1617
__attribute((always_inline)) __attribute__((unused)) static inline T tex1DLayered(cudaTextureObject_t texObject, float x, int layer) 
# 1618
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;
# 1622
::exit(___);}
#if 0
# 1618
{ 
# 1619
T ret; 
# 1620
tex1DLayered(&ret, texObject, x, layer); 
# 1621
return ret; 
# 1622
} 
#endif
# 1630 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1640
::exit(___);}
#if 0
# 1631
{ 
# 1636
int4 tmp; 
# 1637
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1639
(*retVal) = ((char)(tmp.x)); 
# 1640
} 
#endif
# 1641 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1642
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1646
::exit(___);}
#if 0
# 1642
{ 
# 1643
int4 tmp; 
# 1644
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1645
(*retVal) = ((signed char)(tmp.x)); 
# 1646
} 
#endif
# 1648 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1649
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1653
::exit(___);}
#if 0
# 1649
{ 
# 1650
int4 tmp; 
# 1651
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1652
(*retVal) = make_char1(tmp.x); 
# 1653
} 
#endif
# 1655 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1656
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1660
::exit(___);}
#if 0
# 1656
{ 
# 1657
int4 tmp; 
# 1658
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1659
(*retVal) = make_char2(tmp.x, tmp.y); 
# 1660
} 
#endif
# 1662 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1663
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1667
::exit(___);}
#if 0
# 1663
{ 
# 1664
int4 tmp; 
# 1665
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1666
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1667
} 
#endif
# 1669 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1670
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1674
::exit(___);}
#if 0
# 1670
{ 
# 1671
uint4 tmp; 
# 1672
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1673
(*retVal) = ((unsigned char)(tmp.x)); 
# 1674
} 
#endif
# 1676 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1677
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1681
::exit(___);}
#if 0
# 1677
{ 
# 1678
uint4 tmp; 
# 1679
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1680
(*retVal) = make_uchar1(tmp.x); 
# 1681
} 
#endif
# 1683 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1684
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1688
::exit(___);}
#if 0
# 1684
{ 
# 1685
uint4 tmp; 
# 1686
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1687
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 1688
} 
#endif
# 1690 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1691
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1695
::exit(___);}
#if 0
# 1691
{ 
# 1692
uint4 tmp; 
# 1693
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1694
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1695
} 
#endif
# 1703 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1704
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1708
::exit(___);}
#if 0
# 1704
{ 
# 1705
int4 tmp; 
# 1706
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1707
(*retVal) = ((short)(tmp.x)); 
# 1708
} 
#endif
# 1710 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1711
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1715
::exit(___);}
#if 0
# 1711
{ 
# 1712
int4 tmp; 
# 1713
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1714
(*retVal) = make_short1(tmp.x); 
# 1715
} 
#endif
# 1717 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1718
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1722
::exit(___);}
#if 0
# 1718
{ 
# 1719
int4 tmp; 
# 1720
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1721
(*retVal) = make_short2(tmp.x, tmp.y); 
# 1722
} 
#endif
# 1724 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1725
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1729
::exit(___);}
#if 0
# 1725
{ 
# 1726
int4 tmp; 
# 1727
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1728
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1729
} 
#endif
# 1731 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1732
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1736
::exit(___);}
#if 0
# 1732
{ 
# 1733
uint4 tmp; 
# 1734
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1735
(*retVal) = ((unsigned short)(tmp.x)); 
# 1736
} 
#endif
# 1738 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1739
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1743
::exit(___);}
#if 0
# 1739
{ 
# 1740
uint4 tmp; 
# 1741
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1742
(*retVal) = make_ushort1(tmp.x); 
# 1743
} 
#endif
# 1745 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1746
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1750
::exit(___);}
#if 0
# 1746
{ 
# 1747
uint4 tmp; 
# 1748
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1749
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 1750
} 
#endif
# 1752 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1753
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1757
::exit(___);}
#if 0
# 1753
{ 
# 1754
uint4 tmp; 
# 1755
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1756
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1757
} 
#endif
# 1765 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1766
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1770
::exit(___);}
#if 0
# 1766
{ 
# 1767
int4 tmp; 
# 1768
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1769
(*retVal) = ((int)(tmp.x)); 
# 1770
} 
#endif
# 1772 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1777
::exit(___);}
#if 0
# 1773
{ 
# 1774
int4 tmp; 
# 1775
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1776
(*retVal) = make_int1(tmp.x); 
# 1777
} 
#endif
# 1779 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1780
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1784
::exit(___);}
#if 0
# 1780
{ 
# 1781
int4 tmp; 
# 1782
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1783
(*retVal) = make_int2(tmp.x, tmp.y); 
# 1784
} 
#endif
# 1786 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1787
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1791
::exit(___);}
#if 0
# 1787
{ 
# 1788
int4 tmp; 
# 1789
__asm__ volatile("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1790
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1791
} 
#endif
# 1793 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1794
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1798
::exit(___);}
#if 0
# 1794
{ 
# 1795
uint4 tmp; 
# 1796
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1797
(*retVal) = ((unsigned)(tmp.x)); 
# 1798
} 
#endif
# 1800 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1801
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1805
::exit(___);}
#if 0
# 1801
{ 
# 1802
uint4 tmp; 
# 1803
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1804
(*retVal) = make_uint1(tmp.x); 
# 1805
} 
#endif
# 1807 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1808
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1812
::exit(___);}
#if 0
# 1808
{ 
# 1809
uint4 tmp; 
# 1810
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1811
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 1812
} 
#endif
# 1814 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1815
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1819
::exit(___);}
#if 0
# 1815
{ 
# 1816
uint4 tmp; 
# 1817
__asm__ volatile("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1818
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1819
} 
#endif
# 1894 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1895
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1899
::exit(___);}
#if 0
# 1895
{ 
# 1896
float4 tmp; 
# 1897
__asm__ volatile("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1898
(*retVal) = ((float)(tmp.x)); 
# 1899
} 
#endif
# 1901 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1902
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1906
::exit(___);}
#if 0
# 1902
{ 
# 1903
float4 tmp; 
# 1904
__asm__ volatile("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1905
(*retVal) = make_float1(tmp.x); 
# 1906
} 
#endif
# 1908 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1909
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1913
::exit(___);}
#if 0
# 1909
{ 
# 1910
float4 tmp; 
# 1911
__asm__ volatile("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1912
(*retVal) = make_float2(tmp.x, tmp.y); 
# 1913
} 
#endif
# 1915 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
# 1916
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
# 1920
::exit(___);}
#if 0
# 1916
{ 
# 1917
float4 tmp; 
# 1918
__asm__ volatile("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y)); 
# 1919
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1920
} 
#endif
# 1928 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 1929
__attribute((always_inline)) __attribute__((unused)) static inline T tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer) 
# 1930
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;
# 1934
::exit(___);}
#if 0
# 1930
{ 
# 1931
T ret; 
# 1932
tex2DLayered(&ret, texObject, x, y, layer); 
# 1933
return ret; 
# 1934
} 
#endif
# 1942 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1952
::exit(___);}
#if 0
# 1943
{ 
# 1948
int4 tmp; 
# 1949
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1951
(*retVal) = ((char)(tmp.x)); 
# 1952
} 
#endif
# 1953 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1954
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1958
::exit(___);}
#if 0
# 1954
{ 
# 1955
int4 tmp; 
# 1956
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1957
(*retVal) = ((signed char)(tmp.x)); 
# 1958
} 
#endif
# 1960 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1961
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1965
::exit(___);}
#if 0
# 1961
{ 
# 1962
int4 tmp; 
# 1963
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1964
(*retVal) = make_char1(tmp.x); 
# 1965
} 
#endif
# 1967 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1968
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1972
::exit(___);}
#if 0
# 1968
{ 
# 1969
int4 tmp; 
# 1970
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1971
(*retVal) = make_char2(tmp.x, tmp.y); 
# 1972
} 
#endif
# 1974 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1975
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1979
::exit(___);}
#if 0
# 1975
{ 
# 1976
int4 tmp; 
# 1977
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1978
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1979
} 
#endif
# 1981 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1982
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1986
::exit(___);}
#if 0
# 1982
{ 
# 1983
uint4 tmp; 
# 1984
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1985
(*retVal) = ((unsigned char)(tmp.x)); 
# 1986
} 
#endif
# 1988 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1989
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 1993
::exit(___);}
#if 0
# 1989
{ 
# 1990
uint4 tmp; 
# 1991
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1992
(*retVal) = make_uchar1(tmp.x); 
# 1993
} 
#endif
# 1995 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 1996
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2000
::exit(___);}
#if 0
# 1996
{ 
# 1997
uint4 tmp; 
# 1998
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 1999
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 2000
} 
#endif
# 2002 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2003
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2007
::exit(___);}
#if 0
# 2003
{ 
# 2004
uint4 tmp; 
# 2005
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2006
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2007
} 
#endif
# 2015 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2016
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2020
::exit(___);}
#if 0
# 2016
{ 
# 2017
int4 tmp; 
# 2018
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2019
(*retVal) = ((short)(tmp.x)); 
# 2020
} 
#endif
# 2022 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2023
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2027
::exit(___);}
#if 0
# 2023
{ 
# 2024
int4 tmp; 
# 2025
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2026
(*retVal) = make_short1(tmp.x); 
# 2027
} 
#endif
# 2029 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2030
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2034
::exit(___);}
#if 0
# 2030
{ 
# 2031
int4 tmp; 
# 2032
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2033
(*retVal) = make_short2(tmp.x, tmp.y); 
# 2034
} 
#endif
# 2036 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2037
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2041
::exit(___);}
#if 0
# 2037
{ 
# 2038
int4 tmp; 
# 2039
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2040
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2041
} 
#endif
# 2043 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2044
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2048
::exit(___);}
#if 0
# 2044
{ 
# 2045
uint4 tmp; 
# 2046
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2047
(*retVal) = ((unsigned short)(tmp.x)); 
# 2048
} 
#endif
# 2050 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2051
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2055
::exit(___);}
#if 0
# 2051
{ 
# 2052
uint4 tmp; 
# 2053
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2054
(*retVal) = make_ushort1(tmp.x); 
# 2055
} 
#endif
# 2057 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2058
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2062
::exit(___);}
#if 0
# 2058
{ 
# 2059
uint4 tmp; 
# 2060
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2061
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 2062
} 
#endif
# 2064 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2065
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2069
::exit(___);}
#if 0
# 2065
{ 
# 2066
uint4 tmp; 
# 2067
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2068
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2069
} 
#endif
# 2077 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2082
::exit(___);}
#if 0
# 2078
{ 
# 2079
int4 tmp; 
# 2080
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2081
(*retVal) = ((int)(tmp.x)); 
# 2082
} 
#endif
# 2084 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2089
::exit(___);}
#if 0
# 2085
{ 
# 2086
int4 tmp; 
# 2087
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2088
(*retVal) = make_int1(tmp.x); 
# 2089
} 
#endif
# 2091 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2092
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2096
::exit(___);}
#if 0
# 2092
{ 
# 2093
int4 tmp; 
# 2094
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2095
(*retVal) = make_int2(tmp.x, tmp.y); 
# 2096
} 
#endif
# 2098 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2099
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2103
::exit(___);}
#if 0
# 2099
{ 
# 2100
int4 tmp; 
# 2101
__asm__ volatile("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2102
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2103
} 
#endif
# 2105 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2106
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2110
::exit(___);}
#if 0
# 2106
{ 
# 2107
uint4 tmp; 
# 2108
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2109
(*retVal) = ((unsigned)(tmp.x)); 
# 2110
} 
#endif
# 2112 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2113
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2117
::exit(___);}
#if 0
# 2113
{ 
# 2114
uint4 tmp; 
# 2115
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2116
(*retVal) = make_uint1(tmp.x); 
# 2117
} 
#endif
# 2119 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2120
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2124
::exit(___);}
#if 0
# 2120
{ 
# 2121
uint4 tmp; 
# 2122
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2123
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 2124
} 
#endif
# 2126 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2127
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2131
::exit(___);}
#if 0
# 2127
{ 
# 2128
uint4 tmp; 
# 2129
__asm__ volatile("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2130
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2131
} 
#endif
# 2206 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2207
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2211
::exit(___);}
#if 0
# 2207
{ 
# 2208
float4 tmp; 
# 2209
__asm__ volatile("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2210
(*retVal) = ((float)(tmp.x)); 
# 2211
} 
#endif
# 2213 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2214
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2218
::exit(___);}
#if 0
# 2214
{ 
# 2215
float4 tmp; 
# 2216
__asm__ volatile("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2217
(*retVal) = make_float1(tmp.x); 
# 2218
} 
#endif
# 2220 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2221
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2225
::exit(___);}
#if 0
# 2221
{ 
# 2222
float4 tmp; 
# 2223
__asm__ volatile("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2224
(*retVal) = make_float2(tmp.x, tmp.y); 
# 2225
} 
#endif
# 2227 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemap(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
# 2228
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
# 2232
::exit(___);}
#if 0
# 2228
{ 
# 2229
float4 tmp; 
# 2230
__asm__ volatile("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z)); 
# 2231
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2232
} 
#endif
# 2240 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 2241
__attribute((always_inline)) __attribute__((unused)) static inline T texCubemap(cudaTextureObject_t texObject, float x, float y, float z) 
# 2242
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
# 2246
::exit(___);}
#if 0
# 2242
{ 
# 2243
T ret; 
# 2244
texCubemap(&ret, texObject, x, y, z); 
# 2245
return ret; 
# 2246
} 
#endif
# 2254 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2264
::exit(___);}
#if 0
# 2255
{ 
# 2260
int4 tmp; 
# 2261
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2263
(*retVal) = ((char)(tmp.x)); 
# 2264
} 
#endif
# 2265 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2266
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2270
::exit(___);}
#if 0
# 2266
{ 
# 2267
int4 tmp; 
# 2268
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2269
(*retVal) = ((signed char)(tmp.x)); 
# 2270
} 
#endif
# 2272 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2273
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2277
::exit(___);}
#if 0
# 2273
{ 
# 2274
int4 tmp; 
# 2275
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2276
(*retVal) = make_char1(tmp.x); 
# 2277
} 
#endif
# 2279 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2280
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2284
::exit(___);}
#if 0
# 2280
{ 
# 2281
int4 tmp; 
# 2282
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2283
(*retVal) = make_char2(tmp.x, tmp.y); 
# 2284
} 
#endif
# 2286 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2287
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2291
::exit(___);}
#if 0
# 2287
{ 
# 2288
int4 tmp; 
# 2289
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2290
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2291
} 
#endif
# 2293 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2294
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2298
::exit(___);}
#if 0
# 2294
{ 
# 2295
uint4 tmp; 
# 2296
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2297
(*retVal) = ((unsigned char)(tmp.x)); 
# 2298
} 
#endif
# 2300 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2301
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2305
::exit(___);}
#if 0
# 2301
{ 
# 2302
uint4 tmp; 
# 2303
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2304
(*retVal) = make_uchar1(tmp.x); 
# 2305
} 
#endif
# 2307 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2308
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2312
::exit(___);}
#if 0
# 2308
{ 
# 2309
uint4 tmp; 
# 2310
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2311
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 2312
} 
#endif
# 2314 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2315
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2319
::exit(___);}
#if 0
# 2315
{ 
# 2316
uint4 tmp; 
# 2317
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2318
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2319
} 
#endif
# 2327 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2328
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2332
::exit(___);}
#if 0
# 2328
{ 
# 2329
int4 tmp; 
# 2330
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2331
(*retVal) = ((short)(tmp.x)); 
# 2332
} 
#endif
# 2334 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2339
::exit(___);}
#if 0
# 2335
{ 
# 2336
int4 tmp; 
# 2337
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2338
(*retVal) = make_short1(tmp.x); 
# 2339
} 
#endif
# 2341 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2342
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2346
::exit(___);}
#if 0
# 2342
{ 
# 2343
int4 tmp; 
# 2344
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2345
(*retVal) = make_short2(tmp.x, tmp.y); 
# 2346
} 
#endif
# 2348 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2349
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2353
::exit(___);}
#if 0
# 2349
{ 
# 2350
int4 tmp; 
# 2351
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2352
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2353
} 
#endif
# 2355 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2356
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2360
::exit(___);}
#if 0
# 2356
{ 
# 2357
uint4 tmp; 
# 2358
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2359
(*retVal) = ((unsigned short)(tmp.x)); 
# 2360
} 
#endif
# 2362 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2363
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2367
::exit(___);}
#if 0
# 2363
{ 
# 2364
uint4 tmp; 
# 2365
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2366
(*retVal) = make_ushort1(tmp.x); 
# 2367
} 
#endif
# 2369 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2370
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2374
::exit(___);}
#if 0
# 2370
{ 
# 2371
uint4 tmp; 
# 2372
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2373
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 2374
} 
#endif
# 2376 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2377
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2381
::exit(___);}
#if 0
# 2377
{ 
# 2378
uint4 tmp; 
# 2379
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2380
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2381
} 
#endif
# 2389 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2390
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2394
::exit(___);}
#if 0
# 2390
{ 
# 2391
int4 tmp; 
# 2392
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2393
(*retVal) = ((int)(tmp.x)); 
# 2394
} 
#endif
# 2396 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2401
::exit(___);}
#if 0
# 2397
{ 
# 2398
int4 tmp; 
# 2399
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2400
(*retVal) = make_int1(tmp.x); 
# 2401
} 
#endif
# 2403 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2404
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2408
::exit(___);}
#if 0
# 2404
{ 
# 2405
int4 tmp; 
# 2406
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2407
(*retVal) = make_int2(tmp.x, tmp.y); 
# 2408
} 
#endif
# 2410 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2411
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2415
::exit(___);}
#if 0
# 2411
{ 
# 2412
int4 tmp; 
# 2413
__asm__ volatile("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2414
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2415
} 
#endif
# 2417 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2418
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2422
::exit(___);}
#if 0
# 2418
{ 
# 2419
uint4 tmp; 
# 2420
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2421
(*retVal) = ((unsigned)(tmp.x)); 
# 2422
} 
#endif
# 2424 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2425
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2429
::exit(___);}
#if 0
# 2425
{ 
# 2426
uint4 tmp; 
# 2427
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2428
(*retVal) = make_uint1(tmp.x); 
# 2429
} 
#endif
# 2431 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2432
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2436
::exit(___);}
#if 0
# 2432
{ 
# 2433
uint4 tmp; 
# 2434
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2435
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 2436
} 
#endif
# 2438 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2439
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2443
::exit(___);}
#if 0
# 2439
{ 
# 2440
uint4 tmp; 
# 2441
__asm__ volatile("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2442
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2443
} 
#endif
# 2518 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2519
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2523
::exit(___);}
#if 0
# 2519
{ 
# 2520
float4 tmp; 
# 2521
__asm__ volatile("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2522
(*retVal) = ((float)(tmp.x)); 
# 2523
} 
#endif
# 2525 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2526
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2530
::exit(___);}
#if 0
# 2526
{ 
# 2527
float4 tmp; 
# 2528
__asm__ volatile("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2529
(*retVal) = make_float1(tmp.x); 
# 2530
} 
#endif
# 2532 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2533
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2537
::exit(___);}
#if 0
# 2533
{ 
# 2534
float4 tmp; 
# 2535
__asm__ volatile("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2536
(*retVal) = make_float2(tmp.x, tmp.y); 
# 2537
} 
#endif
# 2539 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2540
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2544
::exit(___);}
#if 0
# 2540
{ 
# 2541
float4 tmp; 
# 2542
__asm__ volatile("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z)); 
# 2543
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2544
} 
#endif
# 2552 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 2553
__attribute((always_inline)) __attribute__((unused)) static inline T texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 2554
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 2558
::exit(___);}
#if 0
# 2554
{ 
# 2555
T ret; 
# 2556
texCubemapLayered(&ret, texObject, x, y, z, layer); 
# 2557
return ret; 
# 2558
} 
#endif
# 2566 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2567
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2582
::exit(___);}
#if 0
# 2567
{ 
# 2568
int4 tmp; 
# 2569
if (comp == 0) { 
# 2570
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2571
} else { 
# 2572
if (comp == 1) { 
# 2573
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2574
} else { 
# 2575
if (comp == 2) { 
# 2576
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2577
} else { 
# 2578
if (comp == 3) { 
# 2579
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2580
}  }  }  }  
# 2581
(*retVal) = ((char)(tmp.x)); 
# 2582
} 
#endif
# 2584 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2585
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2600
::exit(___);}
#if 0
# 2585
{ 
# 2586
int4 tmp; 
# 2587
if (comp == 0) { 
# 2588
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2589
} else { 
# 2590
if (comp == 1) { 
# 2591
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2592
} else { 
# 2593
if (comp == 2) { 
# 2594
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2595
} else { 
# 2596
if (comp == 3) { 
# 2597
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2598
}  }  }  }  
# 2599
(*retVal) = ((signed char)(tmp.x)); 
# 2600
} 
#endif
# 2602 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2618
::exit(___);}
#if 0
# 2603
{ 
# 2604
int4 tmp; 
# 2605
if (comp == 0) { 
# 2606
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2607
} else { 
# 2608
if (comp == 1) { 
# 2609
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2610
} else { 
# 2611
if (comp == 2) { 
# 2612
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2613
} else { 
# 2614
if (comp == 3) { 
# 2615
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2616
}  }  }  }  
# 2617
(*retVal) = make_char1(tmp.x); 
# 2618
} 
#endif
# 2620 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2621
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2636
::exit(___);}
#if 0
# 2621
{ 
# 2622
int4 tmp; 
# 2623
if (comp == 0) { 
# 2624
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2625
} else { 
# 2626
if (comp == 1) { 
# 2627
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2628
} else { 
# 2629
if (comp == 2) { 
# 2630
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2631
} else { 
# 2632
if (comp == 3) { 
# 2633
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2634
}  }  }  }  
# 2635
(*retVal) = make_char2(tmp.x, tmp.y); 
# 2636
} 
#endif
# 2638 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2639
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2654
::exit(___);}
#if 0
# 2639
{ 
# 2640
int4 tmp; 
# 2641
if (comp == 0) { 
# 2642
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2643
} else { 
# 2644
if (comp == 1) { 
# 2645
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2646
} else { 
# 2647
if (comp == 2) { 
# 2648
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2649
} else { 
# 2650
if (comp == 3) { 
# 2651
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2652
}  }  }  }  
# 2653
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2654
} 
#endif
# 2656 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2657
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2672
::exit(___);}
#if 0
# 2657
{ 
# 2658
uint4 tmp; 
# 2659
if (comp == 0) { 
# 2660
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2661
} else { 
# 2662
if (comp == 1) { 
# 2663
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2664
} else { 
# 2665
if (comp == 2) { 
# 2666
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2667
} else { 
# 2668
if (comp == 3) { 
# 2669
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2670
}  }  }  }  
# 2671
(*retVal) = ((unsigned char)(tmp.x)); 
# 2672
} 
#endif
# 2674 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2675
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2690
::exit(___);}
#if 0
# 2675
{ 
# 2676
uint4 tmp; 
# 2677
if (comp == 0) { 
# 2678
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2679
} else { 
# 2680
if (comp == 1) { 
# 2681
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2682
} else { 
# 2683
if (comp == 2) { 
# 2684
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2685
} else { 
# 2686
if (comp == 3) { 
# 2687
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2688
}  }  }  }  
# 2689
(*retVal) = make_uchar1(tmp.x); 
# 2690
} 
#endif
# 2692 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2693
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2708
::exit(___);}
#if 0
# 2693
{ 
# 2694
uint4 tmp; 
# 2695
if (comp == 0) { 
# 2696
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2697
} else { 
# 2698
if (comp == 1) { 
# 2699
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2700
} else { 
# 2701
if (comp == 2) { 
# 2702
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2703
} else { 
# 2704
if (comp == 3) { 
# 2705
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2706
}  }  }  }  
# 2707
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 2708
} 
#endif
# 2710 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2711
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2726
::exit(___);}
#if 0
# 2711
{ 
# 2712
uint4 tmp; 
# 2713
if (comp == 0) { 
# 2714
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2715
} else { 
# 2716
if (comp == 1) { 
# 2717
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2718
} else { 
# 2719
if (comp == 2) { 
# 2720
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2721
} else { 
# 2722
if (comp == 3) { 
# 2723
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2724
}  }  }  }  
# 2725
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2726
} 
#endif
# 2734 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2735
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2750
::exit(___);}
#if 0
# 2735
{ 
# 2736
int4 tmp; 
# 2737
if (comp == 0) { 
# 2738
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2739
} else { 
# 2740
if (comp == 1) { 
# 2741
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2742
} else { 
# 2743
if (comp == 2) { 
# 2744
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2745
} else { 
# 2746
if (comp == 3) { 
# 2747
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2748
}  }  }  }  
# 2749
(*retVal) = ((short)(tmp.x)); 
# 2750
} 
#endif
# 2752 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2753
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2768
::exit(___);}
#if 0
# 2753
{ 
# 2754
int4 tmp; 
# 2755
if (comp == 0) { 
# 2756
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2757
} else { 
# 2758
if (comp == 1) { 
# 2759
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2760
} else { 
# 2761
if (comp == 2) { 
# 2762
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2763
} else { 
# 2764
if (comp == 3) { 
# 2765
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2766
}  }  }  }  
# 2767
(*retVal) = make_short1(tmp.x); 
# 2768
} 
#endif
# 2770 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2771
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2786
::exit(___);}
#if 0
# 2771
{ 
# 2772
int4 tmp; 
# 2773
if (comp == 0) { 
# 2774
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2775
} else { 
# 2776
if (comp == 1) { 
# 2777
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2778
} else { 
# 2779
if (comp == 2) { 
# 2780
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2781
} else { 
# 2782
if (comp == 3) { 
# 2783
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2784
}  }  }  }  
# 2785
(*retVal) = make_short2(tmp.x, tmp.y); 
# 2786
} 
#endif
# 2788 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2804
::exit(___);}
#if 0
# 2789
{ 
# 2790
int4 tmp; 
# 2791
if (comp == 0) { 
# 2792
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2793
} else { 
# 2794
if (comp == 1) { 
# 2795
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2796
} else { 
# 2797
if (comp == 2) { 
# 2798
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2799
} else { 
# 2800
if (comp == 3) { 
# 2801
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2802
}  }  }  }  
# 2803
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2804
} 
#endif
# 2806 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2807
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2822
::exit(___);}
#if 0
# 2807
{ 
# 2808
uint4 tmp; 
# 2809
if (comp == 0) { 
# 2810
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2811
} else { 
# 2812
if (comp == 1) { 
# 2813
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2814
} else { 
# 2815
if (comp == 2) { 
# 2816
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2817
} else { 
# 2818
if (comp == 3) { 
# 2819
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2820
}  }  }  }  
# 2821
(*retVal) = ((unsigned short)(tmp.x)); 
# 2822
} 
#endif
# 2824 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2825
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2840
::exit(___);}
#if 0
# 2825
{ 
# 2826
uint4 tmp; 
# 2827
if (comp == 0) { 
# 2828
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2829
} else { 
# 2830
if (comp == 1) { 
# 2831
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2832
} else { 
# 2833
if (comp == 2) { 
# 2834
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2835
} else { 
# 2836
if (comp == 3) { 
# 2837
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2838
}  }  }  }  
# 2839
(*retVal) = make_ushort1(tmp.x); 
# 2840
} 
#endif
# 2842 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2843
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2858
::exit(___);}
#if 0
# 2843
{ 
# 2844
uint4 tmp; 
# 2845
if (comp == 0) { 
# 2846
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2847
} else { 
# 2848
if (comp == 1) { 
# 2849
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2850
} else { 
# 2851
if (comp == 2) { 
# 2852
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2853
} else { 
# 2854
if (comp == 3) { 
# 2855
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2856
}  }  }  }  
# 2857
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 2858
} 
#endif
# 2860 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2861
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2876
::exit(___);}
#if 0
# 2861
{ 
# 2862
uint4 tmp; 
# 2863
if (comp == 0) { 
# 2864
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2865
} else { 
# 2866
if (comp == 1) { 
# 2867
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2868
} else { 
# 2869
if (comp == 2) { 
# 2870
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2871
} else { 
# 2872
if (comp == 3) { 
# 2873
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2874
}  }  }  }  
# 2875
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2876
} 
#endif
# 2884 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2885
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2900
::exit(___);}
#if 0
# 2885
{ 
# 2886
int4 tmp; 
# 2887
if (comp == 0) { 
# 2888
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2889
} else { 
# 2890
if (comp == 1) { 
# 2891
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2892
} else { 
# 2893
if (comp == 2) { 
# 2894
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2895
} else { 
# 2896
if (comp == 3) { 
# 2897
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2898
}  }  }  }  
# 2899
(*retVal) = ((int)(tmp.x)); 
# 2900
} 
#endif
# 2902 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2903
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2918
::exit(___);}
#if 0
# 2903
{ 
# 2904
int4 tmp; 
# 2905
if (comp == 0) { 
# 2906
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2907
} else { 
# 2908
if (comp == 1) { 
# 2909
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2910
} else { 
# 2911
if (comp == 2) { 
# 2912
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2913
} else { 
# 2914
if (comp == 3) { 
# 2915
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2916
}  }  }  }  
# 2917
(*retVal) = make_int1(tmp.x); 
# 2918
} 
#endif
# 2920 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2921
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2936
::exit(___);}
#if 0
# 2921
{ 
# 2922
int4 tmp; 
# 2923
if (comp == 0) { 
# 2924
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2925
} else { 
# 2926
if (comp == 1) { 
# 2927
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2928
} else { 
# 2929
if (comp == 2) { 
# 2930
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2931
} else { 
# 2932
if (comp == 3) { 
# 2933
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2934
}  }  }  }  
# 2935
(*retVal) = make_int2(tmp.x, tmp.y); 
# 2936
} 
#endif
# 2938 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2939
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2954
::exit(___);}
#if 0
# 2939
{ 
# 2940
int4 tmp; 
# 2941
if (comp == 0) { 
# 2942
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2943
} else { 
# 2944
if (comp == 1) { 
# 2945
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2946
} else { 
# 2947
if (comp == 2) { 
# 2948
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2949
} else { 
# 2950
if (comp == 3) { 
# 2951
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2952
}  }  }  }  
# 2953
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2954
} 
#endif
# 2956 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2957
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2972
::exit(___);}
#if 0
# 2957
{ 
# 2958
uint4 tmp; 
# 2959
if (comp == 0) { 
# 2960
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2961
} else { 
# 2962
if (comp == 1) { 
# 2963
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2964
} else { 
# 2965
if (comp == 2) { 
# 2966
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2967
} else { 
# 2968
if (comp == 3) { 
# 2969
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2970
}  }  }  }  
# 2971
(*retVal) = ((unsigned)(tmp.x)); 
# 2972
} 
#endif
# 2974 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2975
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 2990
::exit(___);}
#if 0
# 2975
{ 
# 2976
uint4 tmp; 
# 2977
if (comp == 0) { 
# 2978
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2979
} else { 
# 2980
if (comp == 1) { 
# 2981
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2982
} else { 
# 2983
if (comp == 2) { 
# 2984
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2985
} else { 
# 2986
if (comp == 3) { 
# 2987
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2988
}  }  }  }  
# 2989
(*retVal) = make_uint1(tmp.x); 
# 2990
} 
#endif
# 2992 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 2993
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3008
::exit(___);}
#if 0
# 2993
{ 
# 2994
uint4 tmp; 
# 2995
if (comp == 0) { 
# 2996
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 2997
} else { 
# 2998
if (comp == 1) { 
# 2999
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3000
} else { 
# 3001
if (comp == 2) { 
# 3002
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3003
} else { 
# 3004
if (comp == 3) { 
# 3005
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3006
}  }  }  }  
# 3007
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 3008
} 
#endif
# 3010 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3011
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3026
::exit(___);}
#if 0
# 3011
{ 
# 3012
uint4 tmp; 
# 3013
if (comp == 0) { 
# 3014
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3015
} else { 
# 3016
if (comp == 1) { 
# 3017
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3018
} else { 
# 3019
if (comp == 2) { 
# 3020
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3021
} else { 
# 3022
if (comp == 3) { 
# 3023
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3024
}  }  }  }  
# 3025
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3026
} 
#endif
# 3034 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3035
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3050
::exit(___);}
#if 0
# 3035
{ 
# 3036
int4 tmp; 
# 3037
if (comp == 0) { 
# 3038
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3039
} else { 
# 3040
if (comp == 1) { 
# 3041
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3042
} else { 
# 3043
if (comp == 2) { 
# 3044
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3045
} else { 
# 3046
if (comp == 3) { 
# 3047
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3048
}  }  }  }  
# 3049
(*retVal) = ((long)(tmp.x)); 
# 3050
} 
#endif
# 3052 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3053
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3068
::exit(___);}
#if 0
# 3053
{ 
# 3054
int4 tmp; 
# 3055
if (comp == 0) { 
# 3056
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3057
} else { 
# 3058
if (comp == 1) { 
# 3059
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3060
} else { 
# 3061
if (comp == 2) { 
# 3062
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3063
} else { 
# 3064
if (comp == 3) { 
# 3065
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3066
}  }  }  }  
# 3067
(*retVal) = make_long1(tmp.x); 
# 3068
} 
#endif
# 3070 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3071
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3086
::exit(___);}
#if 0
# 3071
{ 
# 3072
int4 tmp; 
# 3073
if (comp == 0) { 
# 3074
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3075
} else { 
# 3076
if (comp == 1) { 
# 3077
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3078
} else { 
# 3079
if (comp == 2) { 
# 3080
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3081
} else { 
# 3082
if (comp == 3) { 
# 3083
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3084
}  }  }  }  
# 3085
(*retVal) = make_long2(tmp.x, tmp.y); 
# 3086
} 
#endif
# 3088 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3089
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3104
::exit(___);}
#if 0
# 3089
{ 
# 3090
int4 tmp; 
# 3091
if (comp == 0) { 
# 3092
__asm__ volatile("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3093
} else { 
# 3094
if (comp == 1) { 
# 3095
__asm__ volatile("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3096
} else { 
# 3097
if (comp == 2) { 
# 3098
__asm__ volatile("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3099
} else { 
# 3100
if (comp == 3) { 
# 3101
__asm__ volatile("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3102
}  }  }  }  
# 3103
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3104
} 
#endif
# 3106 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3107
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3122
::exit(___);}
#if 0
# 3107
{ 
# 3108
uint4 tmp; 
# 3109
if (comp == 0) { 
# 3110
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3111
} else { 
# 3112
if (comp == 1) { 
# 3113
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3114
} else { 
# 3115
if (comp == 2) { 
# 3116
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3117
} else { 
# 3118
if (comp == 3) { 
# 3119
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3120
}  }  }  }  
# 3121
(*retVal) = ((unsigned long)(tmp.x)); 
# 3122
} 
#endif
# 3124 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3125
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3140
::exit(___);}
#if 0
# 3125
{ 
# 3126
uint4 tmp; 
# 3127
if (comp == 0) { 
# 3128
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3129
} else { 
# 3130
if (comp == 1) { 
# 3131
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3132
} else { 
# 3133
if (comp == 2) { 
# 3134
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3135
} else { 
# 3136
if (comp == 3) { 
# 3137
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3138
}  }  }  }  
# 3139
(*retVal) = make_ulong1(tmp.x); 
# 3140
} 
#endif
# 3142 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3143
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3158
::exit(___);}
#if 0
# 3143
{ 
# 3144
uint4 tmp; 
# 3145
if (comp == 0) { 
# 3146
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3147
} else { 
# 3148
if (comp == 1) { 
# 3149
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3150
} else { 
# 3151
if (comp == 2) { 
# 3152
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3153
} else { 
# 3154
if (comp == 3) { 
# 3155
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3156
}  }  }  }  
# 3157
(*retVal) = make_ulong2(tmp.x, tmp.y); 
# 3158
} 
#endif
# 3160 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3161
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3176
::exit(___);}
#if 0
# 3161
{ 
# 3162
uint4 tmp; 
# 3163
if (comp == 0) { 
# 3164
__asm__ volatile("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3165
} else { 
# 3166
if (comp == 1) { 
# 3167
__asm__ volatile("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3168
} else { 
# 3169
if (comp == 2) { 
# 3170
__asm__ volatile("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3171
} else { 
# 3172
if (comp == 3) { 
# 3173
__asm__ volatile("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3174
}  }  }  }  
# 3175
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3176
} 
#endif
# 3184 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3185
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3200
::exit(___);}
#if 0
# 3185
{ 
# 3186
float4 tmp; 
# 3187
if (comp == 0) { 
# 3188
__asm__ volatile("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3189
} else { 
# 3190
if (comp == 1) { 
# 3191
__asm__ volatile("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3192
} else { 
# 3193
if (comp == 2) { 
# 3194
__asm__ volatile("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3195
} else { 
# 3196
if (comp == 3) { 
# 3197
__asm__ volatile("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3198
}  }  }  }  
# 3199
(*retVal) = ((float)(tmp.x)); 
# 3200
} 
#endif
# 3202 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3203
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3218
::exit(___);}
#if 0
# 3203
{ 
# 3204
float4 tmp; 
# 3205
if (comp == 0) { 
# 3206
__asm__ volatile("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3207
} else { 
# 3208
if (comp == 1) { 
# 3209
__asm__ volatile("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3210
} else { 
# 3211
if (comp == 2) { 
# 3212
__asm__ volatile("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3213
} else { 
# 3214
if (comp == 3) { 
# 3215
__asm__ volatile("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3216
}  }  }  }  
# 3217
(*retVal) = make_float1(tmp.x); 
# 3218
} 
#endif
# 3220 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3221
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3236
::exit(___);}
#if 0
# 3221
{ 
# 3222
float4 tmp; 
# 3223
if (comp == 0) { 
# 3224
__asm__ volatile("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3225
} else { 
# 3226
if (comp == 1) { 
# 3227
__asm__ volatile("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3228
} else { 
# 3229
if (comp == 2) { 
# 3230
__asm__ volatile("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3231
} else { 
# 3232
if (comp == 3) { 
# 3233
__asm__ volatile("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3234
}  }  }  }  
# 3235
(*retVal) = make_float2(tmp.x, tmp.y); 
# 3236
} 
#endif
# 3238 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2Dgather(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0) 
# 3239
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
# 3254
::exit(___);}
#if 0
# 3239
{ 
# 3240
float4 tmp; 
# 3241
if (comp == 0) { 
# 3242
__asm__ volatile("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3243
} else { 
# 3244
if (comp == 1) { 
# 3245
__asm__ volatile("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3246
} else { 
# 3247
if (comp == 2) { 
# 3248
__asm__ volatile("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3249
} else { 
# 3250
if (comp == 3) { 
# 3251
__asm__ volatile("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y)); 
# 3252
}  }  }  }  
# 3253
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3254
} 
#endif
# 3262 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 3263
__attribute((always_inline)) __attribute__((unused)) static inline T tex2Dgather(cudaTextureObject_t to, float x, float y, int comp = 0) 
# 3264
{int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;
# 3268
::exit(___);}
#if 0
# 3264
{ 
# 3265
T ret; 
# 3266
tex2Dgather(&ret, to, x, y, comp); 
# 3267
return ret; 
# 3268
} 
#endif
# 3276 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3277
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3286
::exit(___);}
#if 0
# 3277
{ 
# 3282
int4 tmp; 
# 3283
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3285
(*retVal) = ((char)(tmp.x)); 
# 3286
} 
#endif
# 3287 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3288
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3292
::exit(___);}
#if 0
# 3288
{ 
# 3289
int4 tmp; 
# 3290
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3291
(*retVal) = ((signed char)(tmp.x)); 
# 3292
} 
#endif
# 3294 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3295
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3299
::exit(___);}
#if 0
# 3295
{ 
# 3296
int4 tmp; 
# 3297
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3298
(*retVal) = make_char1(tmp.x); 
# 3299
} 
#endif
# 3301 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3302
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3306
::exit(___);}
#if 0
# 3302
{ 
# 3303
int4 tmp; 
# 3304
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3305
(*retVal) = make_char2(tmp.x, tmp.y); 
# 3306
} 
#endif
# 3308 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3309
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3313
::exit(___);}
#if 0
# 3309
{ 
# 3310
int4 tmp; 
# 3311
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3312
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3313
} 
#endif
# 3315 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3316
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3320
::exit(___);}
#if 0
# 3316
{ 
# 3317
uint4 tmp; 
# 3318
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3319
(*retVal) = ((unsigned char)(tmp.x)); 
# 3320
} 
#endif
# 3322 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3323
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3327
::exit(___);}
#if 0
# 3323
{ 
# 3324
uint4 tmp; 
# 3325
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3326
(*retVal) = make_uchar1(tmp.x); 
# 3327
} 
#endif
# 3329 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3330
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3334
::exit(___);}
#if 0
# 3330
{ 
# 3331
uint4 tmp; 
# 3332
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3333
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 3334
} 
#endif
# 3336 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3337
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3341
::exit(___);}
#if 0
# 3337
{ 
# 3338
uint4 tmp; 
# 3339
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3340
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3341
} 
#endif
# 3349 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3350
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3354
::exit(___);}
#if 0
# 3350
{ 
# 3351
int4 tmp; 
# 3352
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3353
(*retVal) = ((short)(tmp.x)); 
# 3354
} 
#endif
# 3356 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3357
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3361
::exit(___);}
#if 0
# 3357
{ 
# 3358
int4 tmp; 
# 3359
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3360
(*retVal) = make_short1(tmp.x); 
# 3361
} 
#endif
# 3363 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3364
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3368
::exit(___);}
#if 0
# 3364
{ 
# 3365
int4 tmp; 
# 3366
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3367
(*retVal) = make_short2(tmp.x, tmp.y); 
# 3368
} 
#endif
# 3370 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3371
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3375
::exit(___);}
#if 0
# 3371
{ 
# 3372
int4 tmp; 
# 3373
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3374
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3375
} 
#endif
# 3377 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3378
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3382
::exit(___);}
#if 0
# 3378
{ 
# 3379
uint4 tmp; 
# 3380
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3381
(*retVal) = ((unsigned short)(tmp.x)); 
# 3382
} 
#endif
# 3384 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3385
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3389
::exit(___);}
#if 0
# 3385
{ 
# 3386
uint4 tmp; 
# 3387
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3388
(*retVal) = make_ushort1(tmp.x); 
# 3389
} 
#endif
# 3391 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3392
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3396
::exit(___);}
#if 0
# 3392
{ 
# 3393
uint4 tmp; 
# 3394
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3395
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 3396
} 
#endif
# 3398 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3399
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3403
::exit(___);}
#if 0
# 3399
{ 
# 3400
uint4 tmp; 
# 3401
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3402
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3403
} 
#endif
# 3411 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3412
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3416
::exit(___);}
#if 0
# 3412
{ 
# 3413
int4 tmp; 
# 3414
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3415
(*retVal) = ((int)(tmp.x)); 
# 3416
} 
#endif
# 3418 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3419
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3423
::exit(___);}
#if 0
# 3419
{ 
# 3420
int4 tmp; 
# 3421
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3422
(*retVal) = make_int1(tmp.x); 
# 3423
} 
#endif
# 3425 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3426
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3430
::exit(___);}
#if 0
# 3426
{ 
# 3427
int4 tmp; 
# 3428
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3429
(*retVal) = make_int2(tmp.x, tmp.y); 
# 3430
} 
#endif
# 3432 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3433
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3437
::exit(___);}
#if 0
# 3433
{ 
# 3434
int4 tmp; 
# 3435
__asm__ volatile("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3436
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3437
} 
#endif
# 3439 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3440
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3444
::exit(___);}
#if 0
# 3440
{ 
# 3441
uint4 tmp; 
# 3442
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3443
(*retVal) = ((unsigned)(tmp.x)); 
# 3444
} 
#endif
# 3446 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3447
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3451
::exit(___);}
#if 0
# 3447
{ 
# 3448
uint4 tmp; 
# 3449
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3450
(*retVal) = make_uint1(tmp.x); 
# 3451
} 
#endif
# 3453 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3458
::exit(___);}
#if 0
# 3454
{ 
# 3455
uint4 tmp; 
# 3456
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3457
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 3458
} 
#endif
# 3460 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3465
::exit(___);}
#if 0
# 3461
{ 
# 3462
uint4 tmp; 
# 3463
__asm__ volatile("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3464
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3465
} 
#endif
# 3540 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3541
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3545
::exit(___);}
#if 0
# 3541
{ 
# 3542
float4 tmp; 
# 3543
__asm__ volatile("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3544
(*retVal) = ((float)(tmp.x)); 
# 3545
} 
#endif
# 3547 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3548
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3552
::exit(___);}
#if 0
# 3548
{ 
# 3549
float4 tmp; 
# 3550
__asm__ volatile("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3551
(*retVal) = make_float1(tmp.x); 
# 3552
} 
#endif
# 3554 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3555
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3559
::exit(___);}
#if 0
# 3555
{ 
# 3556
float4 tmp; 
# 3557
__asm__ volatile("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3558
(*retVal) = make_float2(tmp.x, tmp.y); 
# 3559
} 
#endif
# 3561 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float level) 
# 3562
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
# 3566
::exit(___);}
#if 0
# 3562
{ 
# 3563
float4 tmp; 
# 3564
__asm__ volatile("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (level)); 
# 3565
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3566
} 
#endif
# 3574 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 3575
__attribute((always_inline)) __attribute__((unused)) static inline T tex1DLod(cudaTextureObject_t texObject, float x, float level) 
# 3576
{int volatile ___ = 1;(void)texObject;(void)x;(void)level;
# 3580
::exit(___);}
#if 0
# 3576
{ 
# 3577
T ret; 
# 3578
tex1DLod(&ret, texObject, x, level); 
# 3579
return ret; 
# 3580
} 
#endif
# 3588 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3589
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3598
::exit(___);}
#if 0
# 3589
{ 
# 3594
int4 tmp; 
# 3595
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3597
(*retVal) = ((char)(tmp.x)); 
# 3598
} 
#endif
# 3599 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3600
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3604
::exit(___);}
#if 0
# 3600
{ 
# 3601
int4 tmp; 
# 3602
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3603
(*retVal) = ((signed char)(tmp.x)); 
# 3604
} 
#endif
# 3606 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3607
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3611
::exit(___);}
#if 0
# 3607
{ 
# 3608
int4 tmp; 
# 3609
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3610
(*retVal) = make_char1(tmp.x); 
# 3611
} 
#endif
# 3613 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3614
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3618
::exit(___);}
#if 0
# 3614
{ 
# 3615
int4 tmp; 
# 3616
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3617
(*retVal) = make_char2(tmp.x, tmp.y); 
# 3618
} 
#endif
# 3620 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3621
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3625
::exit(___);}
#if 0
# 3621
{ 
# 3622
int4 tmp; 
# 3623
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3624
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3625
} 
#endif
# 3627 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3628
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3632
::exit(___);}
#if 0
# 3628
{ 
# 3629
uint4 tmp; 
# 3630
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3631
(*retVal) = ((unsigned char)(tmp.x)); 
# 3632
} 
#endif
# 3634 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3635
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3639
::exit(___);}
#if 0
# 3635
{ 
# 3636
uint4 tmp; 
# 3637
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3638
(*retVal) = make_uchar1(tmp.x); 
# 3639
} 
#endif
# 3641 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3642
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3646
::exit(___);}
#if 0
# 3642
{ 
# 3643
uint4 tmp; 
# 3644
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3645
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 3646
} 
#endif
# 3648 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3649
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3653
::exit(___);}
#if 0
# 3649
{ 
# 3650
uint4 tmp; 
# 3651
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3652
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3653
} 
#endif
# 3661 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3662
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3666
::exit(___);}
#if 0
# 3662
{ 
# 3663
int4 tmp; 
# 3664
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3665
(*retVal) = ((short)(tmp.x)); 
# 3666
} 
#endif
# 3668 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3669
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3673
::exit(___);}
#if 0
# 3669
{ 
# 3670
int4 tmp; 
# 3671
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3672
(*retVal) = make_short1(tmp.x); 
# 3673
} 
#endif
# 3675 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3676
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3680
::exit(___);}
#if 0
# 3676
{ 
# 3677
int4 tmp; 
# 3678
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3679
(*retVal) = make_short2(tmp.x, tmp.y); 
# 3680
} 
#endif
# 3682 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3683
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3687
::exit(___);}
#if 0
# 3683
{ 
# 3684
int4 tmp; 
# 3685
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3686
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3687
} 
#endif
# 3689 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3690
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3694
::exit(___);}
#if 0
# 3690
{ 
# 3691
uint4 tmp; 
# 3692
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3693
(*retVal) = ((unsigned short)(tmp.x)); 
# 3694
} 
#endif
# 3696 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3697
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3701
::exit(___);}
#if 0
# 3697
{ 
# 3698
uint4 tmp; 
# 3699
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3700
(*retVal) = make_ushort1(tmp.x); 
# 3701
} 
#endif
# 3703 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3704
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3708
::exit(___);}
#if 0
# 3704
{ 
# 3705
uint4 tmp; 
# 3706
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3707
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 3708
} 
#endif
# 3710 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3711
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3715
::exit(___);}
#if 0
# 3711
{ 
# 3712
uint4 tmp; 
# 3713
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3714
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3715
} 
#endif
# 3723 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3724
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3728
::exit(___);}
#if 0
# 3724
{ 
# 3725
int4 tmp; 
# 3726
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3727
(*retVal) = ((int)(tmp.x)); 
# 3728
} 
#endif
# 3730 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3731
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3735
::exit(___);}
#if 0
# 3731
{ 
# 3732
int4 tmp; 
# 3733
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3734
(*retVal) = make_int1(tmp.x); 
# 3735
} 
#endif
# 3737 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3738
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3742
::exit(___);}
#if 0
# 3738
{ 
# 3739
int4 tmp; 
# 3740
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3741
(*retVal) = make_int2(tmp.x, tmp.y); 
# 3742
} 
#endif
# 3744 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3745
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3749
::exit(___);}
#if 0
# 3745
{ 
# 3746
int4 tmp; 
# 3747
__asm__ volatile("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3748
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3749
} 
#endif
# 3751 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3752
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3756
::exit(___);}
#if 0
# 3752
{ 
# 3753
uint4 tmp; 
# 3754
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3755
(*retVal) = ((unsigned)(tmp.x)); 
# 3756
} 
#endif
# 3758 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3759
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3763
::exit(___);}
#if 0
# 3759
{ 
# 3760
uint4 tmp; 
# 3761
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3762
(*retVal) = make_uint1(tmp.x); 
# 3763
} 
#endif
# 3765 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3766
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3770
::exit(___);}
#if 0
# 3766
{ 
# 3767
uint4 tmp; 
# 3768
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3769
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 3770
} 
#endif
# 3772 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3777
::exit(___);}
#if 0
# 3773
{ 
# 3774
uint4 tmp; 
# 3775
__asm__ volatile("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3776
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3777
} 
#endif
# 3852 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3853
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3857
::exit(___);}
#if 0
# 3853
{ 
# 3854
float4 tmp; 
# 3855
__asm__ volatile("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3856
(*retVal) = ((float)(tmp.x)); 
# 3857
} 
#endif
# 3859 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3860
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3864
::exit(___);}
#if 0
# 3860
{ 
# 3861
float4 tmp; 
# 3862
__asm__ volatile("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3863
(*retVal) = make_float1(tmp.x); 
# 3864
} 
#endif
# 3866 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3867
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3871
::exit(___);}
#if 0
# 3867
{ 
# 3868
float4 tmp; 
# 3869
__asm__ volatile("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3870
(*retVal) = make_float2(tmp.x, tmp.y); 
# 3871
} 
#endif
# 3873 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
# 3874
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
# 3878
::exit(___);}
#if 0
# 3874
{ 
# 3875
float4 tmp; 
# 3876
__asm__ volatile("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (level)); 
# 3877
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3878
} 
#endif
# 3886 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 3887
__attribute((always_inline)) __attribute__((unused)) static inline T tex2DLod(cudaTextureObject_t texObject, float x, float y, float level) 
# 3888
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;
# 3892
::exit(___);}
#if 0
# 3888
{ 
# 3889
T ret; 
# 3890
tex2DLod(&ret, texObject, x, y, level); 
# 3891
return ret; 
# 3892
} 
#endif
# 3900 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3901
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3910
::exit(___);}
#if 0
# 3901
{ 
# 3906
int4 tmp; 
# 3907
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3909
(*retVal) = ((char)(tmp.x)); 
# 3910
} 
#endif
# 3911 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3912
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3916
::exit(___);}
#if 0
# 3912
{ 
# 3913
int4 tmp; 
# 3914
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3915
(*retVal) = ((signed char)(tmp.x)); 
# 3916
} 
#endif
# 3918 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3919
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3923
::exit(___);}
#if 0
# 3919
{ 
# 3920
int4 tmp; 
# 3921
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3922
(*retVal) = make_char1(tmp.x); 
# 3923
} 
#endif
# 3925 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3926
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3930
::exit(___);}
#if 0
# 3926
{ 
# 3927
int4 tmp; 
# 3928
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3929
(*retVal) = make_char2(tmp.x, tmp.y); 
# 3930
} 
#endif
# 3932 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3933
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3937
::exit(___);}
#if 0
# 3933
{ 
# 3934
int4 tmp; 
# 3935
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3936
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3937
} 
#endif
# 3939 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3940
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3944
::exit(___);}
#if 0
# 3940
{ 
# 3941
uint4 tmp; 
# 3942
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3943
(*retVal) = ((unsigned char)(tmp.x)); 
# 3944
} 
#endif
# 3946 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3947
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3951
::exit(___);}
#if 0
# 3947
{ 
# 3948
uint4 tmp; 
# 3949
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3950
(*retVal) = make_uchar1(tmp.x); 
# 3951
} 
#endif
# 3953 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3954
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3958
::exit(___);}
#if 0
# 3954
{ 
# 3955
uint4 tmp; 
# 3956
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3957
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 3958
} 
#endif
# 3960 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3961
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3965
::exit(___);}
#if 0
# 3961
{ 
# 3962
uint4 tmp; 
# 3963
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3964
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3965
} 
#endif
# 3973 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3974
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3978
::exit(___);}
#if 0
# 3974
{ 
# 3975
int4 tmp; 
# 3976
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3977
(*retVal) = ((short)(tmp.x)); 
# 3978
} 
#endif
# 3980 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3981
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3985
::exit(___);}
#if 0
# 3981
{ 
# 3982
int4 tmp; 
# 3983
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3984
(*retVal) = make_short1(tmp.x); 
# 3985
} 
#endif
# 3987 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3988
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3992
::exit(___);}
#if 0
# 3988
{ 
# 3989
int4 tmp; 
# 3990
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3991
(*retVal) = make_short2(tmp.x, tmp.y); 
# 3992
} 
#endif
# 3994 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 3995
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 3999
::exit(___);}
#if 0
# 3995
{ 
# 3996
int4 tmp; 
# 3997
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 3998
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3999
} 
#endif
# 4001 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4002
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4006
::exit(___);}
#if 0
# 4002
{ 
# 4003
uint4 tmp; 
# 4004
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4005
(*retVal) = ((unsigned short)(tmp.x)); 
# 4006
} 
#endif
# 4008 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4009
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4013
::exit(___);}
#if 0
# 4009
{ 
# 4010
uint4 tmp; 
# 4011
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4012
(*retVal) = make_ushort1(tmp.x); 
# 4013
} 
#endif
# 4015 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4016
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4020
::exit(___);}
#if 0
# 4016
{ 
# 4017
uint4 tmp; 
# 4018
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4019
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 4020
} 
#endif
# 4022 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4023
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4027
::exit(___);}
#if 0
# 4023
{ 
# 4024
uint4 tmp; 
# 4025
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4026
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4027
} 
#endif
# 4035 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4036
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4040
::exit(___);}
#if 0
# 4036
{ 
# 4037
int4 tmp; 
# 4038
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4039
(*retVal) = ((int)(tmp.x)); 
# 4040
} 
#endif
# 4042 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4043
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4047
::exit(___);}
#if 0
# 4043
{ 
# 4044
int4 tmp; 
# 4045
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4046
(*retVal) = make_int1(tmp.x); 
# 4047
} 
#endif
# 4049 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4050
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4054
::exit(___);}
#if 0
# 4050
{ 
# 4051
int4 tmp; 
# 4052
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4053
(*retVal) = make_int2(tmp.x, tmp.y); 
# 4054
} 
#endif
# 4056 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4057
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4061
::exit(___);}
#if 0
# 4057
{ 
# 4058
int4 tmp; 
# 4059
__asm__ volatile("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4060
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4061
} 
#endif
# 4063 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4064
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4068
::exit(___);}
#if 0
# 4064
{ 
# 4065
uint4 tmp; 
# 4066
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4067
(*retVal) = ((unsigned)(tmp.x)); 
# 4068
} 
#endif
# 4070 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4071
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4075
::exit(___);}
#if 0
# 4071
{ 
# 4072
uint4 tmp; 
# 4073
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4074
(*retVal) = make_uint1(tmp.x); 
# 4075
} 
#endif
# 4077 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4082
::exit(___);}
#if 0
# 4078
{ 
# 4079
uint4 tmp; 
# 4080
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4081
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 4082
} 
#endif
# 4084 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4089
::exit(___);}
#if 0
# 4085
{ 
# 4086
uint4 tmp; 
# 4087
__asm__ volatile("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4088
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4089
} 
#endif
# 4164 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4165
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4169
::exit(___);}
#if 0
# 4165
{ 
# 4166
float4 tmp; 
# 4167
__asm__ volatile("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4168
(*retVal) = ((float)(tmp.x)); 
# 4169
} 
#endif
# 4171 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4172
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4176
::exit(___);}
#if 0
# 4172
{ 
# 4173
float4 tmp; 
# 4174
__asm__ volatile("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4175
(*retVal) = make_float1(tmp.x); 
# 4176
} 
#endif
# 4178 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4179
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4183
::exit(___);}
#if 0
# 4179
{ 
# 4180
float4 tmp; 
# 4181
__asm__ volatile("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4182
(*retVal) = make_float2(tmp.x, tmp.y); 
# 4183
} 
#endif
# 4185 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4186
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4190
::exit(___);}
#if 0
# 4186
{ 
# 4187
float4 tmp; 
# 4188
__asm__ volatile("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4189
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4190
} 
#endif
# 4198 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 4199
__attribute((always_inline)) __attribute__((unused)) static inline T tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4200
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4204
::exit(___);}
#if 0
# 4200
{ 
# 4201
T ret; 
# 4202
tex3DLod(&ret, texObject, x, y, z, level); 
# 4203
return ret; 
# 4204
} 
#endif
# 4212 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4213
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4222
::exit(___);}
#if 0
# 4213
{ 
# 4218
int4 tmp; 
# 4219
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4221
(*retVal) = ((char)(tmp.x)); 
# 4222
} 
#endif
# 4223 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4224
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4228
::exit(___);}
#if 0
# 4224
{ 
# 4225
int4 tmp; 
# 4226
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4227
(*retVal) = ((signed char)(tmp.x)); 
# 4228
} 
#endif
# 4230 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4231
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4235
::exit(___);}
#if 0
# 4231
{ 
# 4232
int4 tmp; 
# 4233
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4234
(*retVal) = make_char1(tmp.x); 
# 4235
} 
#endif
# 4237 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4238
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4242
::exit(___);}
#if 0
# 4238
{ 
# 4239
int4 tmp; 
# 4240
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4241
(*retVal) = make_char2(tmp.x, tmp.y); 
# 4242
} 
#endif
# 4244 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4245
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4249
::exit(___);}
#if 0
# 4245
{ 
# 4246
int4 tmp; 
# 4247
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4248
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4249
} 
#endif
# 4251 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4252
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4256
::exit(___);}
#if 0
# 4252
{ 
# 4253
uint4 tmp; 
# 4254
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4255
(*retVal) = ((unsigned char)(tmp.x)); 
# 4256
} 
#endif
# 4258 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4259
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4263
::exit(___);}
#if 0
# 4259
{ 
# 4260
uint4 tmp; 
# 4261
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4262
(*retVal) = make_uchar1(tmp.x); 
# 4263
} 
#endif
# 4265 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4266
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4270
::exit(___);}
#if 0
# 4266
{ 
# 4267
uint4 tmp; 
# 4268
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4269
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 4270
} 
#endif
# 4272 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4273
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4277
::exit(___);}
#if 0
# 4273
{ 
# 4274
uint4 tmp; 
# 4275
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4276
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4277
} 
#endif
# 4285 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4286
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4290
::exit(___);}
#if 0
# 4286
{ 
# 4287
int4 tmp; 
# 4288
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4289
(*retVal) = ((short)(tmp.x)); 
# 4290
} 
#endif
# 4292 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4293
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4297
::exit(___);}
#if 0
# 4293
{ 
# 4294
int4 tmp; 
# 4295
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4296
(*retVal) = make_short1(tmp.x); 
# 4297
} 
#endif
# 4299 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4300
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4304
::exit(___);}
#if 0
# 4300
{ 
# 4301
int4 tmp; 
# 4302
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4303
(*retVal) = make_short2(tmp.x, tmp.y); 
# 4304
} 
#endif
# 4306 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4307
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4311
::exit(___);}
#if 0
# 4307
{ 
# 4308
int4 tmp; 
# 4309
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4310
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4311
} 
#endif
# 4313 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4314
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4318
::exit(___);}
#if 0
# 4314
{ 
# 4315
uint4 tmp; 
# 4316
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4317
(*retVal) = ((unsigned short)(tmp.x)); 
# 4318
} 
#endif
# 4320 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4321
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4325
::exit(___);}
#if 0
# 4321
{ 
# 4322
uint4 tmp; 
# 4323
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4324
(*retVal) = make_ushort1(tmp.x); 
# 4325
} 
#endif
# 4327 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4328
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4332
::exit(___);}
#if 0
# 4328
{ 
# 4329
uint4 tmp; 
# 4330
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4331
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 4332
} 
#endif
# 4334 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4339
::exit(___);}
#if 0
# 4335
{ 
# 4336
uint4 tmp; 
# 4337
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4338
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4339
} 
#endif
# 4347 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4348
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4352
::exit(___);}
#if 0
# 4348
{ 
# 4349
int4 tmp; 
# 4350
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4351
(*retVal) = ((int)(tmp.x)); 
# 4352
} 
#endif
# 4354 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4355
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4359
::exit(___);}
#if 0
# 4355
{ 
# 4356
int4 tmp; 
# 4357
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4358
(*retVal) = make_int1(tmp.x); 
# 4359
} 
#endif
# 4361 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4362
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4366
::exit(___);}
#if 0
# 4362
{ 
# 4363
int4 tmp; 
# 4364
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4365
(*retVal) = make_int2(tmp.x, tmp.y); 
# 4366
} 
#endif
# 4368 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4369
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4373
::exit(___);}
#if 0
# 4369
{ 
# 4370
int4 tmp; 
# 4371
__asm__ volatile("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4372
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4373
} 
#endif
# 4375 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4376
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4380
::exit(___);}
#if 0
# 4376
{ 
# 4377
uint4 tmp; 
# 4378
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4379
(*retVal) = ((unsigned)(tmp.x)); 
# 4380
} 
#endif
# 4382 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4383
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4387
::exit(___);}
#if 0
# 4383
{ 
# 4384
uint4 tmp; 
# 4385
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4386
(*retVal) = make_uint1(tmp.x); 
# 4387
} 
#endif
# 4389 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4390
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4394
::exit(___);}
#if 0
# 4390
{ 
# 4391
uint4 tmp; 
# 4392
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4393
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 4394
} 
#endif
# 4396 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4401
::exit(___);}
#if 0
# 4397
{ 
# 4398
uint4 tmp; 
# 4399
__asm__ volatile("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4400
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4401
} 
#endif
# 4476 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4477
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4481
::exit(___);}
#if 0
# 4477
{ 
# 4478
float4 tmp; 
# 4479
__asm__ volatile("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4480
(*retVal) = ((float)(tmp.x)); 
# 4481
} 
#endif
# 4483 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4484
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4488
::exit(___);}
#if 0
# 4484
{ 
# 4485
float4 tmp; 
# 4486
__asm__ volatile("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4487
(*retVal) = make_float1(tmp.x); 
# 4488
} 
#endif
# 4490 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4491
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4495
::exit(___);}
#if 0
# 4491
{ 
# 4492
float4 tmp; 
# 4493
__asm__ volatile("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4494
(*retVal) = make_float2(tmp.x, tmp.y); 
# 4495
} 
#endif
# 4497 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
# 4498
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
# 4502
::exit(___);}
#if 0
# 4498
{ 
# 4499
float4 tmp; 
# 4500
__asm__ volatile("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (level)); 
# 4501
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4502
} 
#endif
# 4510 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 4511
__attribute((always_inline)) __attribute__((unused)) static inline T tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level) 
# 4512
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;
# 4516
::exit(___);}
#if 0
# 4512
{ 
# 4513
T ret; 
# 4514
tex1DLayeredLod(&ret, texObject, x, layer, level); 
# 4515
return ret; 
# 4516
} 
#endif
# 4524 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4534
::exit(___);}
#if 0
# 4525
{ 
# 4530
int4 tmp; 
# 4531
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4533
(*retVal) = ((char)(tmp.x)); 
# 4534
} 
#endif
# 4535 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4536
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4540
::exit(___);}
#if 0
# 4536
{ 
# 4537
int4 tmp; 
# 4538
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4539
(*retVal) = ((signed char)(tmp.x)); 
# 4540
} 
#endif
# 4542 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4543
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4547
::exit(___);}
#if 0
# 4543
{ 
# 4544
int4 tmp; 
# 4545
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4546
(*retVal) = make_char1(tmp.x); 
# 4547
} 
#endif
# 4549 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4550
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4554
::exit(___);}
#if 0
# 4550
{ 
# 4551
int4 tmp; 
# 4552
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4553
(*retVal) = make_char2(tmp.x, tmp.y); 
# 4554
} 
#endif
# 4556 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4557
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4561
::exit(___);}
#if 0
# 4557
{ 
# 4558
int4 tmp; 
# 4559
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4560
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4561
} 
#endif
# 4563 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4564
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4568
::exit(___);}
#if 0
# 4564
{ 
# 4565
uint4 tmp; 
# 4566
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4567
(*retVal) = ((unsigned char)(tmp.x)); 
# 4568
} 
#endif
# 4570 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4571
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4575
::exit(___);}
#if 0
# 4571
{ 
# 4572
uint4 tmp; 
# 4573
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4574
(*retVal) = make_uchar1(tmp.x); 
# 4575
} 
#endif
# 4577 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4578
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4582
::exit(___);}
#if 0
# 4578
{ 
# 4579
uint4 tmp; 
# 4580
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4581
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 4582
} 
#endif
# 4584 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4585
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4589
::exit(___);}
#if 0
# 4585
{ 
# 4586
uint4 tmp; 
# 4587
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4588
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4589
} 
#endif
# 4597 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4598
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4602
::exit(___);}
#if 0
# 4598
{ 
# 4599
int4 tmp; 
# 4600
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4601
(*retVal) = ((short)(tmp.x)); 
# 4602
} 
#endif
# 4604 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4605
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4609
::exit(___);}
#if 0
# 4605
{ 
# 4606
int4 tmp; 
# 4607
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4608
(*retVal) = make_short1(tmp.x); 
# 4609
} 
#endif
# 4611 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4612
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4616
::exit(___);}
#if 0
# 4612
{ 
# 4613
int4 tmp; 
# 4614
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4615
(*retVal) = make_short2(tmp.x, tmp.y); 
# 4616
} 
#endif
# 4618 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4619
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4623
::exit(___);}
#if 0
# 4619
{ 
# 4620
int4 tmp; 
# 4621
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4622
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4623
} 
#endif
# 4625 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4626
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4630
::exit(___);}
#if 0
# 4626
{ 
# 4627
uint4 tmp; 
# 4628
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4629
(*retVal) = ((unsigned short)(tmp.x)); 
# 4630
} 
#endif
# 4632 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4633
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4637
::exit(___);}
#if 0
# 4633
{ 
# 4634
uint4 tmp; 
# 4635
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4636
(*retVal) = make_ushort1(tmp.x); 
# 4637
} 
#endif
# 4639 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4640
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4644
::exit(___);}
#if 0
# 4640
{ 
# 4641
uint4 tmp; 
# 4642
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4643
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 4644
} 
#endif
# 4646 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4647
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4651
::exit(___);}
#if 0
# 4647
{ 
# 4648
uint4 tmp; 
# 4649
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4650
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4651
} 
#endif
# 4659 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4660
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4664
::exit(___);}
#if 0
# 4660
{ 
# 4661
int4 tmp; 
# 4662
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4663
(*retVal) = ((int)(tmp.x)); 
# 4664
} 
#endif
# 4666 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4667
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4671
::exit(___);}
#if 0
# 4667
{ 
# 4668
int4 tmp; 
# 4669
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4670
(*retVal) = make_int1(tmp.x); 
# 4671
} 
#endif
# 4673 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4674
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4678
::exit(___);}
#if 0
# 4674
{ 
# 4675
int4 tmp; 
# 4676
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4677
(*retVal) = make_int2(tmp.x, tmp.y); 
# 4678
} 
#endif
# 4680 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4681
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4685
::exit(___);}
#if 0
# 4681
{ 
# 4682
int4 tmp; 
# 4683
__asm__ volatile("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4684
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4685
} 
#endif
# 4687 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4688
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4692
::exit(___);}
#if 0
# 4688
{ 
# 4689
uint4 tmp; 
# 4690
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4691
(*retVal) = ((unsigned)(tmp.x)); 
# 4692
} 
#endif
# 4694 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4695
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4699
::exit(___);}
#if 0
# 4695
{ 
# 4696
uint4 tmp; 
# 4697
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4698
(*retVal) = make_uint1(tmp.x); 
# 4699
} 
#endif
# 4701 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4702
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4706
::exit(___);}
#if 0
# 4702
{ 
# 4703
uint4 tmp; 
# 4704
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4705
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 4706
} 
#endif
# 4708 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4709
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4713
::exit(___);}
#if 0
# 4709
{ 
# 4710
uint4 tmp; 
# 4711
__asm__ volatile("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4712
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4713
} 
#endif
# 4788 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4793
::exit(___);}
#if 0
# 4789
{ 
# 4790
float4 tmp; 
# 4791
__asm__ volatile("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4792
(*retVal) = ((float)(tmp.x)); 
# 4793
} 
#endif
# 4795 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4796
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4800
::exit(___);}
#if 0
# 4796
{ 
# 4797
float4 tmp; 
# 4798
__asm__ volatile("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4799
(*retVal) = make_float1(tmp.x); 
# 4800
} 
#endif
# 4802 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4803
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4807
::exit(___);}
#if 0
# 4803
{ 
# 4804
float4 tmp; 
# 4805
__asm__ volatile("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4806
(*retVal) = make_float2(tmp.x, tmp.y); 
# 4807
} 
#endif
# 4809 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4810
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4814
::exit(___);}
#if 0
# 4810
{ 
# 4811
float4 tmp; 
# 4812
__asm__ volatile("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (level)); 
# 4813
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4814
} 
#endif
# 4822 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 4823
__attribute((always_inline)) __attribute__((unused)) static inline T tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 4824
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 4828
::exit(___);}
#if 0
# 4824
{ 
# 4825
T ret; 
# 4826
tex2DLayeredLod(&ret, texObject, x, y, layer, level); 
# 4827
return ret; 
# 4828
} 
#endif
# 4836 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4846
::exit(___);}
#if 0
# 4837
{ 
# 4842
int4 tmp; 
# 4843
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4845
(*retVal) = ((char)(tmp.x)); 
# 4846
} 
#endif
# 4847 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4848
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4852
::exit(___);}
#if 0
# 4848
{ 
# 4849
int4 tmp; 
# 4850
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4851
(*retVal) = ((signed char)(tmp.x)); 
# 4852
} 
#endif
# 4854 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4855
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4859
::exit(___);}
#if 0
# 4855
{ 
# 4856
int4 tmp; 
# 4857
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4858
(*retVal) = make_char1(tmp.x); 
# 4859
} 
#endif
# 4861 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4862
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4866
::exit(___);}
#if 0
# 4862
{ 
# 4863
int4 tmp; 
# 4864
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4865
(*retVal) = make_char2(tmp.x, tmp.y); 
# 4866
} 
#endif
# 4868 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4869
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4873
::exit(___);}
#if 0
# 4869
{ 
# 4870
int4 tmp; 
# 4871
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4872
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4873
} 
#endif
# 4875 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4876
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4880
::exit(___);}
#if 0
# 4876
{ 
# 4877
uint4 tmp; 
# 4878
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4879
(*retVal) = ((unsigned char)(tmp.x)); 
# 4880
} 
#endif
# 4882 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4883
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4887
::exit(___);}
#if 0
# 4883
{ 
# 4884
uint4 tmp; 
# 4885
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4886
(*retVal) = make_uchar1(tmp.x); 
# 4887
} 
#endif
# 4889 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4890
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4894
::exit(___);}
#if 0
# 4890
{ 
# 4891
uint4 tmp; 
# 4892
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4893
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 4894
} 
#endif
# 4896 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4897
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4901
::exit(___);}
#if 0
# 4897
{ 
# 4898
uint4 tmp; 
# 4899
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4900
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4901
} 
#endif
# 4909 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4910
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4914
::exit(___);}
#if 0
# 4910
{ 
# 4911
int4 tmp; 
# 4912
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4913
(*retVal) = ((short)(tmp.x)); 
# 4914
} 
#endif
# 4916 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4917
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4921
::exit(___);}
#if 0
# 4917
{ 
# 4918
int4 tmp; 
# 4919
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4920
(*retVal) = make_short1(tmp.x); 
# 4921
} 
#endif
# 4923 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4924
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4928
::exit(___);}
#if 0
# 4924
{ 
# 4925
int4 tmp; 
# 4926
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4927
(*retVal) = make_short2(tmp.x, tmp.y); 
# 4928
} 
#endif
# 4930 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4931
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4935
::exit(___);}
#if 0
# 4931
{ 
# 4932
int4 tmp; 
# 4933
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4934
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4935
} 
#endif
# 4937 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4938
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4942
::exit(___);}
#if 0
# 4938
{ 
# 4939
uint4 tmp; 
# 4940
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4941
(*retVal) = ((unsigned short)(tmp.x)); 
# 4942
} 
#endif
# 4944 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4945
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4949
::exit(___);}
#if 0
# 4945
{ 
# 4946
uint4 tmp; 
# 4947
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4948
(*retVal) = make_ushort1(tmp.x); 
# 4949
} 
#endif
# 4951 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4952
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4956
::exit(___);}
#if 0
# 4952
{ 
# 4953
uint4 tmp; 
# 4954
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4955
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 4956
} 
#endif
# 4958 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4959
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4963
::exit(___);}
#if 0
# 4959
{ 
# 4960
uint4 tmp; 
# 4961
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4962
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4963
} 
#endif
# 4971 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4972
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4976
::exit(___);}
#if 0
# 4972
{ 
# 4973
int4 tmp; 
# 4974
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4975
(*retVal) = ((int)(tmp.x)); 
# 4976
} 
#endif
# 4978 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4979
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4983
::exit(___);}
#if 0
# 4979
{ 
# 4980
int4 tmp; 
# 4981
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4982
(*retVal) = make_int1(tmp.x); 
# 4983
} 
#endif
# 4985 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4986
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4990
::exit(___);}
#if 0
# 4986
{ 
# 4987
int4 tmp; 
# 4988
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4989
(*retVal) = make_int2(tmp.x, tmp.y); 
# 4990
} 
#endif
# 4992 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 4993
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 4997
::exit(___);}
#if 0
# 4993
{ 
# 4994
int4 tmp; 
# 4995
__asm__ volatile("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 4996
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 4997
} 
#endif
# 4999 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 5000
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 5004
::exit(___);}
#if 0
# 5000
{ 
# 5001
uint4 tmp; 
# 5002
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5003
(*retVal) = ((unsigned)(tmp.x)); 
# 5004
} 
#endif
# 5006 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 5007
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 5011
::exit(___);}
#if 0
# 5007
{ 
# 5008
uint4 tmp; 
# 5009
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5010
(*retVal) = make_uint1(tmp.x); 
# 5011
} 
#endif
# 5013 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 5014
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 5018
::exit(___);}
#if 0
# 5014
{ 
# 5015
uint4 tmp; 
# 5016
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5017
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 5018
} 
#endif
# 5020 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 5021
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 5025
::exit(___);}
#if 0
# 5021
{ 
# 5022
uint4 tmp; 
# 5023
__asm__ volatile("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5024
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5025
} 
#endif
# 5100 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 5101
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 5105
::exit(___);}
#if 0
# 5101
{ 
# 5102
float4 tmp; 
# 5103
__asm__ volatile("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5104
(*retVal) = ((float)(tmp.x)); 
# 5105
} 
#endif
# 5107 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 5108
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 5112
::exit(___);}
#if 0
# 5108
{ 
# 5109
float4 tmp; 
# 5110
__asm__ volatile("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5111
(*retVal) = make_float1(tmp.x); 
# 5112
} 
#endif
# 5114 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 5115
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 5119
::exit(___);}
#if 0
# 5115
{ 
# 5116
float4 tmp; 
# 5117
__asm__ volatile("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5118
(*retVal) = make_float2(tmp.x, tmp.y); 
# 5119
} 
#endif
# 5121 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 5122
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 5126
::exit(___);}
#if 0
# 5122
{ 
# 5123
float4 tmp; 
# 5124
__asm__ volatile("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5125
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5126
} 
#endif
# 5134 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 5135
__attribute((always_inline)) __attribute__((unused)) static inline T texCubemapLod(cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 5136
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 5140
::exit(___);}
#if 0
# 5136
{ 
# 5137
T ret; 
# 5138
texCubemapLod(&ret, texObject, x, y, z, level); 
# 5139
return ret; 
# 5140
} 
#endif
# 5148 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5158
::exit(___);}
#if 0
# 5149
{ 
# 5154
int4 tmp; 
# 5155
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5157
(*retVal) = ((char)(tmp.x)); 
# 5158
} 
#endif
# 5159 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5160
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5164
::exit(___);}
#if 0
# 5160
{ 
# 5161
int4 tmp; 
# 5162
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5163
(*retVal) = ((signed char)(tmp.x)); 
# 5164
} 
#endif
# 5166 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5167
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5171
::exit(___);}
#if 0
# 5167
{ 
# 5168
int4 tmp; 
# 5169
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5170
(*retVal) = make_char1(tmp.x); 
# 5171
} 
#endif
# 5173 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5174
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5178
::exit(___);}
#if 0
# 5174
{ 
# 5175
int4 tmp; 
# 5176
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5177
(*retVal) = make_char2(tmp.x, tmp.y); 
# 5178
} 
#endif
# 5180 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5181
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5185
::exit(___);}
#if 0
# 5181
{ 
# 5182
int4 tmp; 
# 5183
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5184
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5185
} 
#endif
# 5187 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5188
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5192
::exit(___);}
#if 0
# 5188
{ 
# 5189
uint4 tmp; 
# 5190
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5191
(*retVal) = ((unsigned char)(tmp.x)); 
# 5192
} 
#endif
# 5194 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5195
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5199
::exit(___);}
#if 0
# 5195
{ 
# 5196
uint4 tmp; 
# 5197
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5198
(*retVal) = make_uchar1(tmp.x); 
# 5199
} 
#endif
# 5201 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5202
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5206
::exit(___);}
#if 0
# 5202
{ 
# 5203
uint4 tmp; 
# 5204
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5205
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 5206
} 
#endif
# 5208 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5209
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5213
::exit(___);}
#if 0
# 5209
{ 
# 5210
uint4 tmp; 
# 5211
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5212
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5213
} 
#endif
# 5221 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5222
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5226
::exit(___);}
#if 0
# 5222
{ 
# 5223
int4 tmp; 
# 5224
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5225
(*retVal) = ((short)(tmp.x)); 
# 5226
} 
#endif
# 5228 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5229
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5233
::exit(___);}
#if 0
# 5229
{ 
# 5230
int4 tmp; 
# 5231
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5232
(*retVal) = make_short1(tmp.x); 
# 5233
} 
#endif
# 5235 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5236
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5240
::exit(___);}
#if 0
# 5236
{ 
# 5237
int4 tmp; 
# 5238
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5239
(*retVal) = make_short2(tmp.x, tmp.y); 
# 5240
} 
#endif
# 5242 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5243
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5247
::exit(___);}
#if 0
# 5243
{ 
# 5244
int4 tmp; 
# 5245
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5246
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5247
} 
#endif
# 5249 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5250
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5254
::exit(___);}
#if 0
# 5250
{ 
# 5251
uint4 tmp; 
# 5252
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5253
(*retVal) = ((unsigned short)(tmp.x)); 
# 5254
} 
#endif
# 5256 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5257
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5261
::exit(___);}
#if 0
# 5257
{ 
# 5258
uint4 tmp; 
# 5259
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5260
(*retVal) = make_ushort1(tmp.x); 
# 5261
} 
#endif
# 5263 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5264
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5268
::exit(___);}
#if 0
# 5264
{ 
# 5265
uint4 tmp; 
# 5266
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5267
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 5268
} 
#endif
# 5270 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5271
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5275
::exit(___);}
#if 0
# 5271
{ 
# 5272
uint4 tmp; 
# 5273
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5274
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5275
} 
#endif
# 5283 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5284
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5288
::exit(___);}
#if 0
# 5284
{ 
# 5285
int4 tmp; 
# 5286
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5287
(*retVal) = ((int)(tmp.x)); 
# 5288
} 
#endif
# 5290 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5291
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5295
::exit(___);}
#if 0
# 5291
{ 
# 5292
int4 tmp; 
# 5293
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5294
(*retVal) = make_int1(tmp.x); 
# 5295
} 
#endif
# 5297 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5298
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5302
::exit(___);}
#if 0
# 5298
{ 
# 5299
int4 tmp; 
# 5300
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5301
(*retVal) = make_int2(tmp.x, tmp.y); 
# 5302
} 
#endif
# 5304 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5305
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5309
::exit(___);}
#if 0
# 5305
{ 
# 5306
int4 tmp; 
# 5307
__asm__ volatile("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5308
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5309
} 
#endif
# 5311 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5312
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5316
::exit(___);}
#if 0
# 5312
{ 
# 5313
uint4 tmp; 
# 5314
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5315
(*retVal) = ((unsigned)(tmp.x)); 
# 5316
} 
#endif
# 5318 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5323
::exit(___);}
#if 0
# 5319
{ 
# 5320
uint4 tmp; 
# 5321
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5322
(*retVal) = make_uint1(tmp.x); 
# 5323
} 
#endif
# 5325 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5326
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5330
::exit(___);}
#if 0
# 5326
{ 
# 5327
uint4 tmp; 
# 5328
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5329
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 5330
} 
#endif
# 5332 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5333
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5337
::exit(___);}
#if 0
# 5333
{ 
# 5334
uint4 tmp; 
# 5335
__asm__ volatile("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5336
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5337
} 
#endif
# 5412 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5413
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5417
::exit(___);}
#if 0
# 5413
{ 
# 5414
float4 tmp; 
# 5415
__asm__ volatile("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5416
(*retVal) = ((float)(tmp.x)); 
# 5417
} 
#endif
# 5419 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5420
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5424
::exit(___);}
#if 0
# 5420
{ 
# 5421
float4 tmp; 
# 5422
__asm__ volatile("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5423
(*retVal) = make_float1(tmp.x); 
# 5424
} 
#endif
# 5426 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5427
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5431
::exit(___);}
#if 0
# 5427
{ 
# 5428
float4 tmp; 
# 5429
__asm__ volatile("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5430
(*retVal) = make_float2(tmp.x, tmp.y); 
# 5431
} 
#endif
# 5433 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void texCubemapLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5438
::exit(___);}
#if 0
# 5434
{ 
# 5435
float4 tmp; 
# 5436
__asm__ volatile("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (z), "f" (level)); 
# 5437
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5438
} 
#endif
# 5446 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 5447
__attribute((always_inline)) __attribute__((unused)) static inline T texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 5448
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 5452
::exit(___);}
#if 0
# 5448
{ 
# 5449
T ret; 
# 5450
texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level); 
# 5451
return ret; 
# 5452
} 
#endif
# 5460 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5470
::exit(___);}
#if 0
# 5461
{ 
# 5466
int4 tmp; 
# 5467
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5469
(*retVal) = ((char)(tmp.x)); 
# 5470
} 
#endif
# 5471 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5472
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5476
::exit(___);}
#if 0
# 5472
{ 
# 5473
int4 tmp; 
# 5474
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5475
(*retVal) = ((signed char)(tmp.x)); 
# 5476
} 
#endif
# 5478 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5479
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5483
::exit(___);}
#if 0
# 5479
{ 
# 5480
int4 tmp; 
# 5481
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5482
(*retVal) = make_char1(tmp.x); 
# 5483
} 
#endif
# 5485 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5486
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5490
::exit(___);}
#if 0
# 5486
{ 
# 5487
int4 tmp; 
# 5488
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5489
(*retVal) = make_char2(tmp.x, tmp.y); 
# 5490
} 
#endif
# 5492 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5493
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5497
::exit(___);}
#if 0
# 5493
{ 
# 5494
int4 tmp; 
# 5495
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5496
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5497
} 
#endif
# 5499 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5500
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5504
::exit(___);}
#if 0
# 5500
{ 
# 5501
uint4 tmp; 
# 5502
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5503
(*retVal) = ((unsigned char)(tmp.x)); 
# 5504
} 
#endif
# 5506 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5507
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5511
::exit(___);}
#if 0
# 5507
{ 
# 5508
uint4 tmp; 
# 5509
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5510
(*retVal) = make_uchar1(tmp.x); 
# 5511
} 
#endif
# 5513 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5514
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5518
::exit(___);}
#if 0
# 5514
{ 
# 5515
uint4 tmp; 
# 5516
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5517
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 5518
} 
#endif
# 5520 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5521
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5525
::exit(___);}
#if 0
# 5521
{ 
# 5522
uint4 tmp; 
# 5523
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5524
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5525
} 
#endif
# 5533 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5534
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5538
::exit(___);}
#if 0
# 5534
{ 
# 5535
int4 tmp; 
# 5536
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5537
(*retVal) = ((short)(tmp.x)); 
# 5538
} 
#endif
# 5540 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5541
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5545
::exit(___);}
#if 0
# 5541
{ 
# 5542
int4 tmp; 
# 5543
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5544
(*retVal) = make_short1(tmp.x); 
# 5545
} 
#endif
# 5547 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5548
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5552
::exit(___);}
#if 0
# 5548
{ 
# 5549
int4 tmp; 
# 5550
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5551
(*retVal) = make_short2(tmp.x, tmp.y); 
# 5552
} 
#endif
# 5554 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5555
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5559
::exit(___);}
#if 0
# 5555
{ 
# 5556
int4 tmp; 
# 5557
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5558
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5559
} 
#endif
# 5561 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5562
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5566
::exit(___);}
#if 0
# 5562
{ 
# 5563
uint4 tmp; 
# 5564
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5565
(*retVal) = ((unsigned short)(tmp.x)); 
# 5566
} 
#endif
# 5568 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5569
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5573
::exit(___);}
#if 0
# 5569
{ 
# 5570
uint4 tmp; 
# 5571
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5572
(*retVal) = make_ushort1(tmp.x); 
# 5573
} 
#endif
# 5575 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5576
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5580
::exit(___);}
#if 0
# 5576
{ 
# 5577
uint4 tmp; 
# 5578
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5579
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 5580
} 
#endif
# 5582 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5583
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5587
::exit(___);}
#if 0
# 5583
{ 
# 5584
uint4 tmp; 
# 5585
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5586
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5587
} 
#endif
# 5595 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5596
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5600
::exit(___);}
#if 0
# 5596
{ 
# 5597
int4 tmp; 
# 5598
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5599
(*retVal) = ((int)(tmp.x)); 
# 5600
} 
#endif
# 5602 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5607
::exit(___);}
#if 0
# 5603
{ 
# 5604
int4 tmp; 
# 5605
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5606
(*retVal) = make_int1(tmp.x); 
# 5607
} 
#endif
# 5609 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5610
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5614
::exit(___);}
#if 0
# 5610
{ 
# 5611
int4 tmp; 
# 5612
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5613
(*retVal) = make_int2(tmp.x, tmp.y); 
# 5614
} 
#endif
# 5616 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5617
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5621
::exit(___);}
#if 0
# 5617
{ 
# 5618
int4 tmp; 
# 5619
__asm__ volatile("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5620
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5621
} 
#endif
# 5623 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5624
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5628
::exit(___);}
#if 0
# 5624
{ 
# 5625
uint4 tmp; 
# 5626
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5627
(*retVal) = ((unsigned)(tmp.x)); 
# 5628
} 
#endif
# 5630 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5635
::exit(___);}
#if 0
# 5631
{ 
# 5632
uint4 tmp; 
# 5633
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5634
(*retVal) = make_uint1(tmp.x); 
# 5635
} 
#endif
# 5637 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5638
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5642
::exit(___);}
#if 0
# 5638
{ 
# 5639
uint4 tmp; 
# 5640
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5641
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 5642
} 
#endif
# 5644 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5645
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5649
::exit(___);}
#if 0
# 5645
{ 
# 5646
uint4 tmp; 
# 5647
__asm__ volatile("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5648
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5649
} 
#endif
# 5724 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5725
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5729
::exit(___);}
#if 0
# 5725
{ 
# 5726
float4 tmp; 
# 5727
__asm__ volatile("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5728
(*retVal) = ((float)(tmp.x)); 
# 5729
} 
#endif
# 5731 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5732
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5736
::exit(___);}
#if 0
# 5732
{ 
# 5733
float4 tmp; 
# 5734
__asm__ volatile("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5735
(*retVal) = make_float1(tmp.x); 
# 5736
} 
#endif
# 5738 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5739
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5743
::exit(___);}
#if 0
# 5739
{ 
# 5740
float4 tmp; 
# 5741
__asm__ volatile("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5742
(*retVal) = make_float2(tmp.x, tmp.y); 
# 5743
} 
#endif
# 5745 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5746
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5750
::exit(___);}
#if 0
# 5746
{ 
# 5747
float4 tmp; 
# 5748
__asm__ volatile("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 5749
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5750
} 
#endif
# 5758 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 5759
__attribute((always_inline)) __attribute__((unused)) static inline T tex1DGrad(cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 5760
{int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 5764
::exit(___);}
#if 0
# 5760
{ 
# 5761
T ret; 
# 5762
tex1DGrad(&ret, texObject, x, dPdx, dPdy); 
# 5763
return ret; 
# 5764
} 
#endif
# 5772 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5782
::exit(___);}
#if 0
# 5773
{ 
# 5778
int4 tmp; 
# 5779
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5781
(*retVal) = ((char)(tmp.x)); 
# 5782
} 
#endif
# 5783 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5784
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5788
::exit(___);}
#if 0
# 5784
{ 
# 5785
int4 tmp; 
# 5786
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5787
(*retVal) = ((signed char)(tmp.x)); 
# 5788
} 
#endif
# 5790 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5791
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5795
::exit(___);}
#if 0
# 5791
{ 
# 5792
int4 tmp; 
# 5793
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5794
(*retVal) = make_char1(tmp.x); 
# 5795
} 
#endif
# 5797 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5798
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5802
::exit(___);}
#if 0
# 5798
{ 
# 5799
int4 tmp; 
# 5800
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5801
(*retVal) = make_char2(tmp.x, tmp.y); 
# 5802
} 
#endif
# 5804 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5805
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5809
::exit(___);}
#if 0
# 5805
{ 
# 5806
int4 tmp; 
# 5807
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5808
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5809
} 
#endif
# 5811 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5812
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5816
::exit(___);}
#if 0
# 5812
{ 
# 5813
uint4 tmp; 
# 5814
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5815
(*retVal) = ((unsigned char)(tmp.x)); 
# 5816
} 
#endif
# 5818 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5819
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5823
::exit(___);}
#if 0
# 5819
{ 
# 5820
uint4 tmp; 
# 5821
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5822
(*retVal) = make_uchar1(tmp.x); 
# 5823
} 
#endif
# 5825 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5826
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5830
::exit(___);}
#if 0
# 5826
{ 
# 5827
uint4 tmp; 
# 5828
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5829
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 5830
} 
#endif
# 5832 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5833
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5837
::exit(___);}
#if 0
# 5833
{ 
# 5834
uint4 tmp; 
# 5835
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5836
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5837
} 
#endif
# 5845 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5846
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5850
::exit(___);}
#if 0
# 5846
{ 
# 5847
int4 tmp; 
# 5848
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5849
(*retVal) = ((short)(tmp.x)); 
# 5850
} 
#endif
# 5852 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5853
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5857
::exit(___);}
#if 0
# 5853
{ 
# 5854
int4 tmp; 
# 5855
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5856
(*retVal) = make_short1(tmp.x); 
# 5857
} 
#endif
# 5859 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5860
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5864
::exit(___);}
#if 0
# 5860
{ 
# 5861
int4 tmp; 
# 5862
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5863
(*retVal) = make_short2(tmp.x, tmp.y); 
# 5864
} 
#endif
# 5866 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5867
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5871
::exit(___);}
#if 0
# 5867
{ 
# 5868
int4 tmp; 
# 5869
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5870
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5871
} 
#endif
# 5873 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5874
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5878
::exit(___);}
#if 0
# 5874
{ 
# 5875
uint4 tmp; 
# 5876
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5877
(*retVal) = ((unsigned short)(tmp.x)); 
# 5878
} 
#endif
# 5880 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5881
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5885
::exit(___);}
#if 0
# 5881
{ 
# 5882
uint4 tmp; 
# 5883
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5884
(*retVal) = make_ushort1(tmp.x); 
# 5885
} 
#endif
# 5887 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5888
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5892
::exit(___);}
#if 0
# 5888
{ 
# 5889
uint4 tmp; 
# 5890
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5891
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 5892
} 
#endif
# 5894 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5895
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5899
::exit(___);}
#if 0
# 5895
{ 
# 5896
uint4 tmp; 
# 5897
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5898
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5899
} 
#endif
# 5907 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5908
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5912
::exit(___);}
#if 0
# 5908
{ 
# 5909
int4 tmp; 
# 5910
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5911
(*retVal) = ((int)(tmp.x)); 
# 5912
} 
#endif
# 5914 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5915
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5919
::exit(___);}
#if 0
# 5915
{ 
# 5916
int4 tmp; 
# 5917
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5918
(*retVal) = make_int1(tmp.x); 
# 5919
} 
#endif
# 5921 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5922
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5926
::exit(___);}
#if 0
# 5922
{ 
# 5923
int4 tmp; 
# 5924
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5925
(*retVal) = make_int2(tmp.x, tmp.y); 
# 5926
} 
#endif
# 5928 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5929
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5933
::exit(___);}
#if 0
# 5929
{ 
# 5930
int4 tmp; 
# 5931
__asm__ volatile("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5932
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5933
} 
#endif
# 5935 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5936
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5940
::exit(___);}
#if 0
# 5936
{ 
# 5937
uint4 tmp; 
# 5938
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5939
(*retVal) = ((unsigned)(tmp.x)); 
# 5940
} 
#endif
# 5942 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5947
::exit(___);}
#if 0
# 5943
{ 
# 5944
uint4 tmp; 
# 5945
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5946
(*retVal) = make_uint1(tmp.x); 
# 5947
} 
#endif
# 5949 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5950
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5954
::exit(___);}
#if 0
# 5950
{ 
# 5951
uint4 tmp; 
# 5952
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5953
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 5954
} 
#endif
# 5956 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 5957
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 5961
::exit(___);}
#if 0
# 5957
{ 
# 5958
uint4 tmp; 
# 5959
__asm__ volatile("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 5960
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 5961
} 
#endif
# 6036 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 6037
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 6041
::exit(___);}
#if 0
# 6037
{ 
# 6038
float4 tmp; 
# 6039
__asm__ volatile("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6040
(*retVal) = ((float)(tmp.x)); 
# 6041
} 
#endif
# 6043 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 6044
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 6048
::exit(___);}
#if 0
# 6044
{ 
# 6045
float4 tmp; 
# 6046
__asm__ volatile("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6047
(*retVal) = make_float1(tmp.x); 
# 6048
} 
#endif
# 6050 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 6051
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 6055
::exit(___);}
#if 0
# 6051
{ 
# 6052
float4 tmp; 
# 6053
__asm__ volatile("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6054
(*retVal) = make_float2(tmp.x, tmp.y); 
# 6055
} 
#endif
# 6057 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 6058
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 6062
::exit(___);}
#if 0
# 6058
{ 
# 6059
float4 tmp; 
# 6060
__asm__ volatile("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6061
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6062
} 
#endif
# 6070 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 6071
__attribute((always_inline)) __attribute__((unused)) static inline T tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 6072
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 6076
::exit(___);}
#if 0
# 6072
{ 
# 6073
T ret; 
# 6074
tex2DGrad(&ret, texObject, x, y, dPdx, dPdy); 
# 6075
return ret; 
# 6076
} 
#endif
# 6084 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6094
::exit(___);}
#if 0
# 6085
{ 
# 6090
int4 tmp; 
# 6091
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6093
(*retVal) = ((char)(tmp.x)); 
# 6094
} 
#endif
# 6095 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6096
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6100
::exit(___);}
#if 0
# 6096
{ 
# 6097
int4 tmp; 
# 6098
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6099
(*retVal) = ((signed char)(tmp.x)); 
# 6100
} 
#endif
# 6102 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6103
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6107
::exit(___);}
#if 0
# 6103
{ 
# 6104
int4 tmp; 
# 6105
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6106
(*retVal) = make_char1(tmp.x); 
# 6107
} 
#endif
# 6109 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6110
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6114
::exit(___);}
#if 0
# 6110
{ 
# 6111
int4 tmp; 
# 6112
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6113
(*retVal) = make_char2(tmp.x, tmp.y); 
# 6114
} 
#endif
# 6116 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6117
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6121
::exit(___);}
#if 0
# 6117
{ 
# 6118
int4 tmp; 
# 6119
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6120
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6121
} 
#endif
# 6123 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6124
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6128
::exit(___);}
#if 0
# 6124
{ 
# 6125
uint4 tmp; 
# 6126
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6127
(*retVal) = ((unsigned char)(tmp.x)); 
# 6128
} 
#endif
# 6130 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6131
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6135
::exit(___);}
#if 0
# 6131
{ 
# 6132
uint4 tmp; 
# 6133
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6134
(*retVal) = make_uchar1(tmp.x); 
# 6135
} 
#endif
# 6137 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6138
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6142
::exit(___);}
#if 0
# 6138
{ 
# 6139
uint4 tmp; 
# 6140
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6141
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 6142
} 
#endif
# 6144 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6145
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6149
::exit(___);}
#if 0
# 6145
{ 
# 6146
uint4 tmp; 
# 6147
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6148
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6149
} 
#endif
# 6157 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6158
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6162
::exit(___);}
#if 0
# 6158
{ 
# 6159
int4 tmp; 
# 6160
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6161
(*retVal) = ((short)(tmp.x)); 
# 6162
} 
#endif
# 6164 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6165
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6169
::exit(___);}
#if 0
# 6165
{ 
# 6166
int4 tmp; 
# 6167
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6168
(*retVal) = make_short1(tmp.x); 
# 6169
} 
#endif
# 6171 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6172
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6176
::exit(___);}
#if 0
# 6172
{ 
# 6173
int4 tmp; 
# 6174
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6175
(*retVal) = make_short2(tmp.x, tmp.y); 
# 6176
} 
#endif
# 6178 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6179
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6183
::exit(___);}
#if 0
# 6179
{ 
# 6180
int4 tmp; 
# 6181
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6182
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6183
} 
#endif
# 6185 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6186
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6190
::exit(___);}
#if 0
# 6186
{ 
# 6187
uint4 tmp; 
# 6188
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6189
(*retVal) = ((unsigned short)(tmp.x)); 
# 6190
} 
#endif
# 6192 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6193
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6197
::exit(___);}
#if 0
# 6193
{ 
# 6194
uint4 tmp; 
# 6195
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6196
(*retVal) = make_ushort1(tmp.x); 
# 6197
} 
#endif
# 6199 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6200
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6204
::exit(___);}
#if 0
# 6200
{ 
# 6201
uint4 tmp; 
# 6202
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6203
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 6204
} 
#endif
# 6206 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6207
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6211
::exit(___);}
#if 0
# 6207
{ 
# 6208
uint4 tmp; 
# 6209
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6210
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6211
} 
#endif
# 6219 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6220
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6224
::exit(___);}
#if 0
# 6220
{ 
# 6221
int4 tmp; 
# 6222
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6223
(*retVal) = ((int)(tmp.x)); 
# 6224
} 
#endif
# 6226 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6227
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6231
::exit(___);}
#if 0
# 6227
{ 
# 6228
int4 tmp; 
# 6229
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6230
(*retVal) = make_int1(tmp.x); 
# 6231
} 
#endif
# 6233 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6238
::exit(___);}
#if 0
# 6234
{ 
# 6235
int4 tmp; 
# 6236
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6237
(*retVal) = make_int2(tmp.x, tmp.y); 
# 6238
} 
#endif
# 6240 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6241
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6245
::exit(___);}
#if 0
# 6241
{ 
# 6242
int4 tmp; 
# 6243
__asm__ volatile("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6244
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6245
} 
#endif
# 6247 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6248
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6252
::exit(___);}
#if 0
# 6248
{ 
# 6249
uint4 tmp; 
# 6250
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6251
(*retVal) = ((unsigned)(tmp.x)); 
# 6252
} 
#endif
# 6254 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6259
::exit(___);}
#if 0
# 6255
{ 
# 6256
uint4 tmp; 
# 6257
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6258
(*retVal) = make_uint1(tmp.x); 
# 6259
} 
#endif
# 6261 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6262
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6266
::exit(___);}
#if 0
# 6262
{ 
# 6263
uint4 tmp; 
# 6264
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6265
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 6266
} 
#endif
# 6268 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6269
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6273
::exit(___);}
#if 0
# 6269
{ 
# 6270
uint4 tmp; 
# 6271
__asm__ volatile("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6272
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6273
} 
#endif
# 6348 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6349
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6353
::exit(___);}
#if 0
# 6349
{ 
# 6350
float4 tmp; 
# 6351
__asm__ volatile("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6352
(*retVal) = ((float)(tmp.x)); 
# 6353
} 
#endif
# 6355 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6356
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6360
::exit(___);}
#if 0
# 6356
{ 
# 6357
float4 tmp; 
# 6358
__asm__ volatile("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6359
(*retVal) = make_float1(tmp.x); 
# 6360
} 
#endif
# 6362 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6363
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6367
::exit(___);}
#if 0
# 6363
{ 
# 6364
float4 tmp; 
# 6365
__asm__ volatile("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6366
(*retVal) = make_float2(tmp.x, tmp.y); 
# 6367
} 
#endif
# 6369 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex3DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6370
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6374
::exit(___);}
#if 0
# 6370
{ 
# 6371
float4 tmp; 
# 6372
__asm__ volatile("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "f" (x), "f" (y), "f" (z), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdx.z), "f" (dPdy.x), "f" (dPdy.y), "f" (dPdy.z)); 
# 6373
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6374
} 
#endif
# 6382 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 6383
__attribute((always_inline)) __attribute__((unused)) static inline T tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 6384
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 6388
::exit(___);}
#if 0
# 6384
{ 
# 6385
T ret; 
# 6386
tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy); 
# 6387
return ret; 
# 6388
} 
#endif
# 6396 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6406
::exit(___);}
#if 0
# 6397
{ 
# 6402
int4 tmp; 
# 6403
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6405
(*retVal) = ((char)(tmp.x)); 
# 6406
} 
#endif
# 6407 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6408
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6412
::exit(___);}
#if 0
# 6408
{ 
# 6409
int4 tmp; 
# 6410
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6411
(*retVal) = ((signed char)(tmp.x)); 
# 6412
} 
#endif
# 6414 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6415
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6419
::exit(___);}
#if 0
# 6415
{ 
# 6416
int4 tmp; 
# 6417
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6418
(*retVal) = make_char1(tmp.x); 
# 6419
} 
#endif
# 6421 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6422
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6426
::exit(___);}
#if 0
# 6422
{ 
# 6423
int4 tmp; 
# 6424
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6425
(*retVal) = make_char2(tmp.x, tmp.y); 
# 6426
} 
#endif
# 6428 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6429
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6433
::exit(___);}
#if 0
# 6429
{ 
# 6430
int4 tmp; 
# 6431
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6432
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6433
} 
#endif
# 6435 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6436
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6440
::exit(___);}
#if 0
# 6436
{ 
# 6437
uint4 tmp; 
# 6438
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6439
(*retVal) = ((unsigned char)(tmp.x)); 
# 6440
} 
#endif
# 6442 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6443
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6447
::exit(___);}
#if 0
# 6443
{ 
# 6444
uint4 tmp; 
# 6445
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6446
(*retVal) = make_uchar1(tmp.x); 
# 6447
} 
#endif
# 6449 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6450
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6454
::exit(___);}
#if 0
# 6450
{ 
# 6451
uint4 tmp; 
# 6452
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6453
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 6454
} 
#endif
# 6456 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6457
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6461
::exit(___);}
#if 0
# 6457
{ 
# 6458
uint4 tmp; 
# 6459
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6460
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6461
} 
#endif
# 6469 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6470
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6474
::exit(___);}
#if 0
# 6470
{ 
# 6471
int4 tmp; 
# 6472
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6473
(*retVal) = ((short)(tmp.x)); 
# 6474
} 
#endif
# 6476 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6477
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6481
::exit(___);}
#if 0
# 6477
{ 
# 6478
int4 tmp; 
# 6479
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6480
(*retVal) = make_short1(tmp.x); 
# 6481
} 
#endif
# 6483 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6484
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6488
::exit(___);}
#if 0
# 6484
{ 
# 6485
int4 tmp; 
# 6486
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6487
(*retVal) = make_short2(tmp.x, tmp.y); 
# 6488
} 
#endif
# 6490 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6491
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6495
::exit(___);}
#if 0
# 6491
{ 
# 6492
int4 tmp; 
# 6493
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6494
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6495
} 
#endif
# 6497 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6498
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6502
::exit(___);}
#if 0
# 6498
{ 
# 6499
uint4 tmp; 
# 6500
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6501
(*retVal) = ((unsigned short)(tmp.x)); 
# 6502
} 
#endif
# 6504 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6505
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6509
::exit(___);}
#if 0
# 6505
{ 
# 6506
uint4 tmp; 
# 6507
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6508
(*retVal) = make_ushort1(tmp.x); 
# 6509
} 
#endif
# 6511 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6512
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6516
::exit(___);}
#if 0
# 6512
{ 
# 6513
uint4 tmp; 
# 6514
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6515
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 6516
} 
#endif
# 6518 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6519
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6523
::exit(___);}
#if 0
# 6519
{ 
# 6520
uint4 tmp; 
# 6521
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6522
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6523
} 
#endif
# 6531 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6536
::exit(___);}
#if 0
# 6532
{ 
# 6533
int4 tmp; 
# 6534
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6535
(*retVal) = ((int)(tmp.x)); 
# 6536
} 
#endif
# 6538 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6539
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6543
::exit(___);}
#if 0
# 6539
{ 
# 6540
int4 tmp; 
# 6541
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6542
(*retVal) = make_int1(tmp.x); 
# 6543
} 
#endif
# 6545 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6546
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6550
::exit(___);}
#if 0
# 6546
{ 
# 6547
int4 tmp; 
# 6548
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6549
(*retVal) = make_int2(tmp.x, tmp.y); 
# 6550
} 
#endif
# 6552 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6553
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6557
::exit(___);}
#if 0
# 6553
{ 
# 6554
int4 tmp; 
# 6555
__asm__ volatile("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6556
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6557
} 
#endif
# 6559 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6560
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6564
::exit(___);}
#if 0
# 6560
{ 
# 6561
uint4 tmp; 
# 6562
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6563
(*retVal) = ((unsigned)(tmp.x)); 
# 6564
} 
#endif
# 6566 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6567
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6571
::exit(___);}
#if 0
# 6567
{ 
# 6568
uint4 tmp; 
# 6569
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6570
(*retVal) = make_uint1(tmp.x); 
# 6571
} 
#endif
# 6573 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6574
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6578
::exit(___);}
#if 0
# 6574
{ 
# 6575
uint4 tmp; 
# 6576
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6577
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 6578
} 
#endif
# 6580 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6581
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6585
::exit(___);}
#if 0
# 6581
{ 
# 6582
uint4 tmp; 
# 6583
__asm__ volatile("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6584
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6585
} 
#endif
# 6660 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6661
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6665
::exit(___);}
#if 0
# 6661
{ 
# 6662
float4 tmp; 
# 6663
__asm__ volatile("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6664
(*retVal) = ((float)(tmp.x)); 
# 6665
} 
#endif
# 6667 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6668
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6672
::exit(___);}
#if 0
# 6668
{ 
# 6669
float4 tmp; 
# 6670
__asm__ volatile("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6671
(*retVal) = make_float1(tmp.x); 
# 6672
} 
#endif
# 6674 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6675
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6679
::exit(___);}
#if 0
# 6675
{ 
# 6676
float4 tmp; 
# 6677
__asm__ volatile("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6678
(*retVal) = make_float2(tmp.x, tmp.y); 
# 6679
} 
#endif
# 6681 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex1DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6682
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6686
::exit(___);}
#if 0
# 6682
{ 
# 6683
float4 tmp; 
# 6684
__asm__ volatile("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (dPdx), "f" (dPdy)); 
# 6685
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6686
} 
#endif
# 6694 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 6695
__attribute((always_inline)) __attribute__((unused)) static inline T tex1DLayeredGrad(cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 6696
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 6700
::exit(___);}
#if 0
# 6696
{ 
# 6697
T ret; 
# 6698
tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy); 
# 6699
return ret; 
# 6700
} 
#endif
# 6708 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6709
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6718
::exit(___);}
#if 0
# 6709
{ 
# 6714
int4 tmp; 
# 6715
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6717
(*retVal) = ((char)(tmp.x)); 
# 6718
} 
#endif
# 6719 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6720
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6724
::exit(___);}
#if 0
# 6720
{ 
# 6721
int4 tmp; 
# 6722
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6723
(*retVal) = ((signed char)(tmp.x)); 
# 6724
} 
#endif
# 6726 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6727
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6731
::exit(___);}
#if 0
# 6727
{ 
# 6728
int4 tmp; 
# 6729
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6730
(*retVal) = make_char1(tmp.x); 
# 6731
} 
#endif
# 6733 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6734
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6738
::exit(___);}
#if 0
# 6734
{ 
# 6735
int4 tmp; 
# 6736
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6737
(*retVal) = make_char2(tmp.x, tmp.y); 
# 6738
} 
#endif
# 6740 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6741
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6745
::exit(___);}
#if 0
# 6741
{ 
# 6742
int4 tmp; 
# 6743
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6744
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6745
} 
#endif
# 6747 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6748
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6752
::exit(___);}
#if 0
# 6748
{ 
# 6749
uint4 tmp; 
# 6750
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6751
(*retVal) = ((unsigned char)(tmp.x)); 
# 6752
} 
#endif
# 6754 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6755
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6759
::exit(___);}
#if 0
# 6755
{ 
# 6756
uint4 tmp; 
# 6757
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6758
(*retVal) = make_uchar1(tmp.x); 
# 6759
} 
#endif
# 6761 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6762
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6766
::exit(___);}
#if 0
# 6762
{ 
# 6763
uint4 tmp; 
# 6764
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6765
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 6766
} 
#endif
# 6768 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6769
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6773
::exit(___);}
#if 0
# 6769
{ 
# 6770
uint4 tmp; 
# 6771
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6772
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6773
} 
#endif
# 6781 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6782
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6786
::exit(___);}
#if 0
# 6782
{ 
# 6783
int4 tmp; 
# 6784
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6785
(*retVal) = ((short)(tmp.x)); 
# 6786
} 
#endif
# 6788 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6789
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6793
::exit(___);}
#if 0
# 6789
{ 
# 6790
int4 tmp; 
# 6791
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6792
(*retVal) = make_short1(tmp.x); 
# 6793
} 
#endif
# 6795 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6796
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6800
::exit(___);}
#if 0
# 6796
{ 
# 6797
int4 tmp; 
# 6798
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6799
(*retVal) = make_short2(tmp.x, tmp.y); 
# 6800
} 
#endif
# 6802 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6803
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6807
::exit(___);}
#if 0
# 6803
{ 
# 6804
int4 tmp; 
# 6805
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6806
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6807
} 
#endif
# 6809 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6810
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6814
::exit(___);}
#if 0
# 6810
{ 
# 6811
uint4 tmp; 
# 6812
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6813
(*retVal) = ((unsigned short)(tmp.x)); 
# 6814
} 
#endif
# 6816 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6817
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6821
::exit(___);}
#if 0
# 6817
{ 
# 6818
uint4 tmp; 
# 6819
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6820
(*retVal) = make_ushort1(tmp.x); 
# 6821
} 
#endif
# 6823 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6824
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6828
::exit(___);}
#if 0
# 6824
{ 
# 6825
uint4 tmp; 
# 6826
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6827
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 6828
} 
#endif
# 6830 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6831
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6835
::exit(___);}
#if 0
# 6831
{ 
# 6832
uint4 tmp; 
# 6833
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6834
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6835
} 
#endif
# 6843 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6844
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6848
::exit(___);}
#if 0
# 6844
{ 
# 6845
int4 tmp; 
# 6846
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6847
(*retVal) = ((int)(tmp.x)); 
# 6848
} 
#endif
# 6850 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6851
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6855
::exit(___);}
#if 0
# 6851
{ 
# 6852
int4 tmp; 
# 6853
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6854
(*retVal) = make_int1(tmp.x); 
# 6855
} 
#endif
# 6857 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6858
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6862
::exit(___);}
#if 0
# 6858
{ 
# 6859
int4 tmp; 
# 6860
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6861
(*retVal) = make_int2(tmp.x, tmp.y); 
# 6862
} 
#endif
# 6864 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6865
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6869
::exit(___);}
#if 0
# 6865
{ 
# 6866
int4 tmp; 
# 6867
__asm__ volatile("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6868
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6869
} 
#endif
# 6871 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6872
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6876
::exit(___);}
#if 0
# 6872
{ 
# 6873
uint4 tmp; 
# 6874
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6875
(*retVal) = ((unsigned)(tmp.x)); 
# 6876
} 
#endif
# 6878 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6879
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6883
::exit(___);}
#if 0
# 6879
{ 
# 6880
uint4 tmp; 
# 6881
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6882
(*retVal) = make_uint1(tmp.x); 
# 6883
} 
#endif
# 6885 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6886
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6890
::exit(___);}
#if 0
# 6886
{ 
# 6887
uint4 tmp; 
# 6888
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6889
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 6890
} 
#endif
# 6892 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6893
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6897
::exit(___);}
#if 0
# 6893
{ 
# 6894
uint4 tmp; 
# 6895
__asm__ volatile("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6896
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6897
} 
#endif
# 6972 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6973
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6977
::exit(___);}
#if 0
# 6973
{ 
# 6974
float4 tmp; 
# 6975
__asm__ volatile("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6976
(*retVal) = ((float)(tmp.x)); 
# 6977
} 
#endif
# 6979 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6980
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6984
::exit(___);}
#if 0
# 6980
{ 
# 6981
float4 tmp; 
# 6982
__asm__ volatile("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6983
(*retVal) = make_float1(tmp.x); 
# 6984
} 
#endif
# 6986 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6987
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6991
::exit(___);}
#if 0
# 6987
{ 
# 6988
float4 tmp; 
# 6989
__asm__ volatile("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6990
(*retVal) = make_float2(tmp.x, tmp.y); 
# 6991
} 
#endif
# 6993 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void tex2DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 6994
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 6998
::exit(___);}
#if 0
# 6994
{ 
# 6995
float4 tmp; 
# 6996
__asm__ volatile("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (texObject), "r" (layer), "f" (x), "f" (y), "f" (dPdx.x), "f" (dPdx.y), "f" (dPdy.x), "f" (dPdy.y)); 
# 6997
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 6998
} 
#endif
# 7006 "/usr/local/cuda/bin/..//include/texture_indirect_functions.h"
template< class T> 
# 7007
__attribute((always_inline)) __attribute__((unused)) static inline T tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 7008
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 7012
::exit(___);}
#if 0
# 7008
{ 
# 7009
T ret; 
# 7010
tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy); 
# 7011
return ret; 
# 7012
} 
#endif
# 70 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 71
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 83
::exit(___);}
#if 0
# 71
{ 
# 72
int tmp; 
# 73
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 74
__asm__ volatile("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 75
} else { 
# 76
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 77
__asm__ volatile("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 78
} else { 
# 79
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 80
__asm__ volatile("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 81
}  }  }  
# 82
(*retVal) = ((char)tmp); 
# 83
} 
#endif
# 85 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 86
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 98
::exit(___);}
#if 0
# 86
{ 
# 87
int tmp; 
# 88
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 89
__asm__ volatile("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 90
} else { 
# 91
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 92
__asm__ volatile("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 93
} else { 
# 94
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 95
__asm__ volatile("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 96
}  }  }  
# 97
(*retVal) = ((signed char)tmp); 
# 98
} 
#endif
# 100 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 101
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 113
::exit(___);}
#if 0
# 101
{ 
# 102
int1 tmp; 
# 103
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 104
__asm__ volatile("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 105
} else { 
# 106
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 107
__asm__ volatile("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 108
} else { 
# 109
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 110
__asm__ volatile("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 111
}  }  }  
# 112
(*retVal) = make_char1(tmp.x); 
# 113
} 
#endif
# 115 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 116
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 128
::exit(___);}
#if 0
# 116
{ 
# 117
unsigned tmp; 
# 118
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 119
__asm__ volatile("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 120
} else { 
# 121
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 122
__asm__ volatile("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 123
} else { 
# 124
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 125
__asm__ volatile("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 126
}  }  }  
# 127
(*retVal) = ((unsigned char)tmp); 
# 128
} 
#endif
# 130 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 131
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 143
::exit(___);}
#if 0
# 131
{ 
# 132
uint1 tmp; 
# 133
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 134
__asm__ volatile("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 135
} else { 
# 136
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 137
__asm__ volatile("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 138
} else { 
# 139
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 140
__asm__ volatile("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 141
}  }  }  
# 142
(*retVal) = make_uchar1(tmp.x); 
# 143
} 
#endif
# 145 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 146
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 158
::exit(___);}
#if 0
# 146
{ 
# 147
short tmp; 
# 148
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 149
__asm__ volatile("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h" (tmp) : "l" (surfObject), "r" (x)); 
# 150
} else { 
# 151
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 152
__asm__ volatile("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h" (tmp) : "l" (surfObject), "r" (x)); 
# 153
} else { 
# 154
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 155
__asm__ volatile("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h" (tmp) : "l" (surfObject), "r" (x)); 
# 156
}  }  }  
# 157
(*retVal) = ((short)tmp); 
# 158
} 
#endif
# 160 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 161
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 173
::exit(___);}
#if 0
# 161
{ 
# 162
short1 tmp; 
# 163
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 164
__asm__ volatile("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x)); 
# 165
} else { 
# 166
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 167
__asm__ volatile("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x)); 
# 168
} else { 
# 169
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 170
__asm__ volatile("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x)); 
# 171
}  }  }  
# 172
(*retVal) = make_short1(tmp.x); 
# 173
} 
#endif
# 175 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 176
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 188
::exit(___);}
#if 0
# 176
{ 
# 177
unsigned short tmp; 
# 178
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 179
__asm__ volatile("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h" (tmp) : "l" (surfObject), "r" (x)); 
# 180
} else { 
# 181
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 182
__asm__ volatile("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h" (tmp) : "l" (surfObject), "r" (x)); 
# 183
} else { 
# 184
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 185
__asm__ volatile("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h" (tmp) : "l" (surfObject), "r" (x)); 
# 186
}  }  }  
# 187
(*retVal) = ((unsigned short)tmp); 
# 188
} 
#endif
# 190 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 191
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 203
::exit(___);}
#if 0
# 191
{ 
# 192
ushort1 tmp; 
# 193
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 194
__asm__ volatile("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x)); 
# 195
} else { 
# 196
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 197
__asm__ volatile("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x)); 
# 198
} else { 
# 199
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 200
__asm__ volatile("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x)); 
# 201
}  }  }  
# 202
(*retVal) = make_ushort1(tmp.x); 
# 203
} 
#endif
# 205 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 206
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 218
::exit(___);}
#if 0
# 206
{ 
# 207
int tmp; 
# 208
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 209
__asm__ volatile("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 210
} else { 
# 211
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 212
__asm__ volatile("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 213
} else { 
# 214
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 215
__asm__ volatile("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 216
}  }  }  
# 217
(*retVal) = ((int)tmp); 
# 218
} 
#endif
# 220 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 221
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 233
::exit(___);}
#if 0
# 221
{ 
# 222
int1 tmp; 
# 223
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 224
__asm__ volatile("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 225
} else { 
# 226
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 227
__asm__ volatile("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 228
} else { 
# 229
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 230
__asm__ volatile("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 231
}  }  }  
# 232
(*retVal) = make_int1(tmp.x); 
# 233
} 
#endif
# 235 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 236
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 248
::exit(___);}
#if 0
# 236
{ 
# 237
unsigned tmp; 
# 238
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 239
__asm__ volatile("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 240
} else { 
# 241
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 242
__asm__ volatile("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 243
} else { 
# 244
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 245
__asm__ volatile("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r" (tmp) : "l" (surfObject), "r" (x)); 
# 246
}  }  }  
# 247
(*retVal) = ((unsigned)tmp); 
# 248
} 
#endif
# 250 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 251
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 263
::exit(___);}
#if 0
# 251
{ 
# 252
uint1 tmp; 
# 253
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 254
__asm__ volatile("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 255
} else { 
# 256
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 257
__asm__ volatile("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 258
} else { 
# 259
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 260
__asm__ volatile("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x)); 
# 261
}  }  }  
# 262
(*retVal) = make_uint1(tmp.x); 
# 263
} 
#endif
# 265 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 266
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 278
::exit(___);}
#if 0
# 266
{ 
# 267
long long tmp; 
# 268
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 269
__asm__ volatile("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l" (tmp) : "l" (surfObject), "r" (x)); 
# 270
} else { 
# 271
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 272
__asm__ volatile("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l" (tmp) : "l" (surfObject), "r" (x)); 
# 273
} else { 
# 274
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 275
__asm__ volatile("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l" (tmp) : "l" (surfObject), "r" (x)); 
# 276
}  }  }  
# 277
(*retVal) = ((long long)tmp); 
# 278
} 
#endif
# 280 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 281
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 293
::exit(___);}
#if 0
# 281
{ 
# 282
longlong1 tmp; 
# 283
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 284
__asm__ volatile("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x)); 
# 285
} else { 
# 286
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 287
__asm__ volatile("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x)); 
# 288
} else { 
# 289
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 290
__asm__ volatile("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x)); 
# 291
}  }  }  
# 292
(*retVal) = make_longlong1(tmp.x); 
# 293
} 
#endif
# 295 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 296
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 308
::exit(___);}
#if 0
# 296
{ 
# 297
unsigned long long tmp; 
# 298
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 299
__asm__ volatile("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l" (tmp) : "l" (surfObject), "r" (x)); 
# 300
} else { 
# 301
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 302
__asm__ volatile("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l" (tmp) : "l" (surfObject), "r" (x)); 
# 303
} else { 
# 304
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 305
__asm__ volatile("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l" (tmp) : "l" (surfObject), "r" (x)); 
# 306
}  }  }  
# 307
(*retVal) = ((unsigned long long)tmp); 
# 308
} 
#endif
# 310 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 311
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 323
::exit(___);}
#if 0
# 311
{ 
# 312
ulonglong1 tmp; 
# 313
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 314
__asm__ volatile("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x)); 
# 315
} else { 
# 316
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 317
__asm__ volatile("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x)); 
# 318
} else { 
# 319
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 320
__asm__ volatile("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x)); 
# 321
}  }  }  
# 322
(*retVal) = make_ulonglong1(tmp.x); 
# 323
} 
#endif
# 325 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 326
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 338
::exit(___);}
#if 0
# 326
{ 
# 327
float tmp; 
# 328
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 329
__asm__ volatile("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=f" (tmp) : "l" (surfObject), "r" (x)); 
# 330
} else { 
# 331
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 332
__asm__ volatile("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=f" (tmp) : "l" (surfObject), "r" (x)); 
# 333
} else { 
# 334
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 335
__asm__ volatile("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=f" (tmp) : "l" (surfObject), "r" (x)); 
# 336
}  }  }  
# 337
(*retVal) = ((float)tmp); 
# 338
} 
#endif
# 340 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 341
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 353
::exit(___);}
#if 0
# 341
{ 
# 342
float1 tmp; 
# 343
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 344
__asm__ volatile("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=f" (tmp.x) : "l" (surfObject), "r" (x)); 
# 345
} else { 
# 346
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 347
__asm__ volatile("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=f" (tmp.x) : "l" (surfObject), "r" (x)); 
# 348
} else { 
# 349
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 350
__asm__ volatile("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=f" (tmp.x) : "l" (surfObject), "r" (x)); 
# 351
}  }  }  
# 352
(*retVal) = make_float1(tmp.x); 
# 353
} 
#endif
# 361 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 362
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 374
::exit(___);}
#if 0
# 362
{ 
# 363
int2 tmp; 
# 364
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 365
__asm__ volatile("suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 366
} else { 
# 367
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 368
__asm__ volatile("suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 369
} else { 
# 370
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 371
__asm__ volatile("suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 372
}  }  }  
# 373
(*retVal) = make_char2(tmp.x, tmp.y); 
# 374
} 
#endif
# 376 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 377
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 389
::exit(___);}
#if 0
# 377
{ 
# 378
uint2 tmp; 
# 379
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 380
__asm__ volatile("suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 381
} else { 
# 382
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 383
__asm__ volatile("suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 384
} else { 
# 385
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 386
__asm__ volatile("suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 387
}  }  }  
# 388
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 389
} 
#endif
# 391 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 392
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 404
::exit(___);}
#if 0
# 392
{ 
# 393
short2 tmp; 
# 394
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 395
__asm__ volatile("suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x)); 
# 396
} else { 
# 397
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 398
__asm__ volatile("suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x)); 
# 399
} else { 
# 400
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 401
__asm__ volatile("suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x)); 
# 402
}  }  }  
# 403
(*retVal) = make_short2(tmp.x, tmp.y); 
# 404
} 
#endif
# 406 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 407
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 419
::exit(___);}
#if 0
# 407
{ 
# 408
ushort2 tmp; 
# 409
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 410
__asm__ volatile("suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x)); 
# 411
} else { 
# 412
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 413
__asm__ volatile("suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x)); 
# 414
} else { 
# 415
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 416
__asm__ volatile("suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x)); 
# 417
}  }  }  
# 418
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 419
} 
#endif
# 421 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 422
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 434
::exit(___);}
#if 0
# 422
{ 
# 423
int2 tmp; 
# 424
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 425
__asm__ volatile("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 426
} else { 
# 427
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 428
__asm__ volatile("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 429
} else { 
# 430
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 431
__asm__ volatile("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 432
}  }  }  
# 433
(*retVal) = make_int2(tmp.x, tmp.y); 
# 434
} 
#endif
# 436 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 437
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 449
::exit(___);}
#if 0
# 437
{ 
# 438
uint2 tmp; 
# 439
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 440
__asm__ volatile("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 441
} else { 
# 442
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 443
__asm__ volatile("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 444
} else { 
# 445
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 446
__asm__ volatile("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x)); 
# 447
}  }  }  
# 448
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 449
} 
#endif
# 451 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 452
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 464
::exit(___);}
#if 0
# 452
{ 
# 453
longlong2 tmp; 
# 454
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 455
__asm__ volatile("suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x)); 
# 456
} else { 
# 457
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 458
__asm__ volatile("suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x)); 
# 459
} else { 
# 460
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 461
__asm__ volatile("suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x)); 
# 462
}  }  }  
# 463
(*retVal) = make_longlong2(tmp.x, tmp.y); 
# 464
} 
#endif
# 466 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 467
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 479
::exit(___);}
#if 0
# 467
{ 
# 468
ulonglong2 tmp; 
# 469
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 470
__asm__ volatile("suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x)); 
# 471
} else { 
# 472
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 473
__asm__ volatile("suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x)); 
# 474
} else { 
# 475
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 476
__asm__ volatile("suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x)); 
# 477
}  }  }  
# 478
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
# 479
} 
#endif
# 481 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 482
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 494
::exit(___);}
#if 0
# 482
{ 
# 483
float2 tmp; 
# 484
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 485
__asm__ volatile("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (x)); 
# 486
} else { 
# 487
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 488
__asm__ volatile("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (x)); 
# 489
} else { 
# 490
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 491
__asm__ volatile("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (x)); 
# 492
}  }  }  
# 493
(*retVal) = make_float2(tmp.x, tmp.y); 
# 494
} 
#endif
# 502 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 503
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 515
::exit(___);}
#if 0
# 503
{ 
# 504
int4 tmp; 
# 505
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 506
__asm__ volatile("suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 507
} else { 
# 508
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 509
__asm__ volatile("suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 510
} else { 
# 511
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 512
__asm__ volatile("suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 513
}  }  }  
# 514
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 515
} 
#endif
# 517 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 518
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 530
::exit(___);}
#if 0
# 518
{ 
# 519
uint4 tmp; 
# 520
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 521
__asm__ volatile("suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 522
} else { 
# 523
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 524
__asm__ volatile("suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 525
} else { 
# 526
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 527
__asm__ volatile("suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 528
}  }  }  
# 529
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 530
} 
#endif
# 532 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 533
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 545
::exit(___);}
#if 0
# 533
{ 
# 534
short4 tmp; 
# 535
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 536
__asm__ volatile("suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x)); 
# 537
} else { 
# 538
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 539
__asm__ volatile("suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x)); 
# 540
} else { 
# 541
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 542
__asm__ volatile("suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x)); 
# 543
}  }  }  
# 544
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 545
} 
#endif
# 547 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 548
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 560
::exit(___);}
#if 0
# 548
{ 
# 549
ushort4 tmp; 
# 550
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 551
__asm__ volatile("suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x)); 
# 552
} else { 
# 553
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 554
__asm__ volatile("suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x)); 
# 555
} else { 
# 556
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 557
__asm__ volatile("suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x)); 
# 558
}  }  }  
# 559
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 560
} 
#endif
# 562 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 563
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 575
::exit(___);}
#if 0
# 563
{ 
# 564
int4 tmp; 
# 565
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 566
__asm__ volatile("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 567
} else { 
# 568
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 569
__asm__ volatile("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 570
} else { 
# 571
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 572
__asm__ volatile("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 573
}  }  }  
# 574
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 575
} 
#endif
# 577 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 578
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 590
::exit(___);}
#if 0
# 578
{ 
# 579
uint4 tmp; 
# 580
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 581
__asm__ volatile("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 582
} else { 
# 583
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 584
__asm__ volatile("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 585
} else { 
# 586
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 587
__asm__ volatile("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x)); 
# 588
}  }  }  
# 589
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 590
} 
#endif
# 592 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 593
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
# 605
::exit(___);}
#if 0
# 593
{ 
# 594
float4 tmp; 
# 595
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 596
__asm__ volatile("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (x)); 
# 597
} else { 
# 598
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 599
__asm__ volatile("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (x)); 
# 600
} else { 
# 601
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 602
__asm__ volatile("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (x)); 
# 603
}  }  }  
# 604
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 605
} 
#endif
# 613 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
template< class T> 
# 614
__attribute((always_inline)) __attribute__((unused)) static inline T surf1Dread(cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 615
{int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;
# 619
::exit(___);}
#if 0
# 615
{ 
# 616
T ret; 
# 617
surf1Dread(&ret, surfObject, x, boundaryMode); 
# 618
return ret; 
# 619
} 
#endif
# 627 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 628
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 640
::exit(___);}
#if 0
# 628
{ 
# 629
int tmp; 
# 630
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 631
__asm__ volatile("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 632
} else { 
# 633
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 634
__asm__ volatile("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 635
} else { 
# 636
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 637
__asm__ volatile("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 638
}  }  }  
# 639
(*retVal) = ((char)tmp); 
# 640
} 
#endif
# 642 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 643
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 655
::exit(___);}
#if 0
# 643
{ 
# 644
int tmp; 
# 645
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 646
__asm__ volatile("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 647
} else { 
# 648
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 649
__asm__ volatile("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 650
} else { 
# 651
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 652
__asm__ volatile("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 653
}  }  }  
# 654
(*retVal) = ((signed char)tmp); 
# 655
} 
#endif
# 657 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 658
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 670
::exit(___);}
#if 0
# 658
{ 
# 659
int1 tmp; 
# 660
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 661
__asm__ volatile("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 662
} else { 
# 663
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 664
__asm__ volatile("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 665
} else { 
# 666
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 667
__asm__ volatile("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 668
}  }  }  
# 669
(*retVal) = make_char1(tmp.x); 
# 670
} 
#endif
# 672 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 673
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 685
::exit(___);}
#if 0
# 673
{ 
# 674
unsigned tmp; 
# 675
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 676
__asm__ volatile("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 677
} else { 
# 678
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 679
__asm__ volatile("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 680
} else { 
# 681
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 682
__asm__ volatile("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 683
}  }  }  
# 684
(*retVal) = ((unsigned char)tmp); 
# 685
} 
#endif
# 687 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 688
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 700
::exit(___);}
#if 0
# 688
{ 
# 689
uint1 tmp; 
# 690
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 691
__asm__ volatile("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 692
} else { 
# 693
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 694
__asm__ volatile("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 695
} else { 
# 696
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 697
__asm__ volatile("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 698
}  }  }  
# 699
(*retVal) = make_uchar1(tmp.x); 
# 700
} 
#endif
# 702 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 703
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 715
::exit(___);}
#if 0
# 703
{ 
# 704
short tmp; 
# 705
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 706
__asm__ volatile("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 707
} else { 
# 708
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 709
__asm__ volatile("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 710
} else { 
# 711
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 712
__asm__ volatile("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 713
}  }  }  
# 714
(*retVal) = ((short)tmp); 
# 715
} 
#endif
# 717 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 718
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 730
::exit(___);}
#if 0
# 718
{ 
# 719
short1 tmp; 
# 720
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 721
__asm__ volatile("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 722
} else { 
# 723
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 724
__asm__ volatile("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 725
} else { 
# 726
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 727
__asm__ volatile("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 728
}  }  }  
# 729
(*retVal) = make_short1(tmp.x); 
# 730
} 
#endif
# 732 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 733
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 745
::exit(___);}
#if 0
# 733
{ 
# 734
unsigned short tmp; 
# 735
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 736
__asm__ volatile("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 737
} else { 
# 738
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 739
__asm__ volatile("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 740
} else { 
# 741
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 742
__asm__ volatile("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 743
}  }  }  
# 744
(*retVal) = ((unsigned short)tmp); 
# 745
} 
#endif
# 747 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 748
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 760
::exit(___);}
#if 0
# 748
{ 
# 749
ushort1 tmp; 
# 750
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 751
__asm__ volatile("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 752
} else { 
# 753
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 754
__asm__ volatile("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 755
} else { 
# 756
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 757
__asm__ volatile("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 758
}  }  }  
# 759
(*retVal) = make_ushort1(tmp.x); 
# 760
} 
#endif
# 762 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 763
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 775
::exit(___);}
#if 0
# 763
{ 
# 764
int tmp; 
# 765
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 766
__asm__ volatile("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 767
} else { 
# 768
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 769
__asm__ volatile("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 770
} else { 
# 771
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 772
__asm__ volatile("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 773
}  }  }  
# 774
(*retVal) = ((int)tmp); 
# 775
} 
#endif
# 777 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 778
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 790
::exit(___);}
#if 0
# 778
{ 
# 779
int1 tmp; 
# 780
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 781
__asm__ volatile("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 782
} else { 
# 783
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 784
__asm__ volatile("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 785
} else { 
# 786
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 787
__asm__ volatile("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 788
}  }  }  
# 789
(*retVal) = make_int1(tmp.x); 
# 790
} 
#endif
# 792 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 793
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 805
::exit(___);}
#if 0
# 793
{ 
# 794
unsigned tmp; 
# 795
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 796
__asm__ volatile("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 797
} else { 
# 798
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 799
__asm__ volatile("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 800
} else { 
# 801
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 802
__asm__ volatile("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 803
}  }  }  
# 804
(*retVal) = ((unsigned)tmp); 
# 805
} 
#endif
# 807 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 808
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 820
::exit(___);}
#if 0
# 808
{ 
# 809
uint1 tmp; 
# 810
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 811
__asm__ volatile("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 812
} else { 
# 813
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 814
__asm__ volatile("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 815
} else { 
# 816
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 817
__asm__ volatile("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 818
}  }  }  
# 819
(*retVal) = make_uint1(tmp.x); 
# 820
} 
#endif
# 822 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 823
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 835
::exit(___);}
#if 0
# 823
{ 
# 824
long long tmp; 
# 825
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 826
__asm__ volatile("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 827
} else { 
# 828
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 829
__asm__ volatile("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 830
} else { 
# 831
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 832
__asm__ volatile("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 833
}  }  }  
# 834
(*retVal) = ((long long)tmp); 
# 835
} 
#endif
# 837 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 838
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 850
::exit(___);}
#if 0
# 838
{ 
# 839
longlong1 tmp; 
# 840
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 841
__asm__ volatile("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 842
} else { 
# 843
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 844
__asm__ volatile("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 845
} else { 
# 846
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 847
__asm__ volatile("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 848
}  }  }  
# 849
(*retVal) = make_longlong1(tmp.x); 
# 850
} 
#endif
# 852 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 853
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 865
::exit(___);}
#if 0
# 853
{ 
# 854
unsigned long long tmp; 
# 855
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 856
__asm__ volatile("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 857
} else { 
# 858
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 859
__asm__ volatile("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 860
} else { 
# 861
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 862
__asm__ volatile("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 863
}  }  }  
# 864
(*retVal) = ((unsigned long long)tmp); 
# 865
} 
#endif
# 867 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 868
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 880
::exit(___);}
#if 0
# 868
{ 
# 869
ulonglong1 tmp; 
# 870
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 871
__asm__ volatile("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 872
} else { 
# 873
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 874
__asm__ volatile("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 875
} else { 
# 876
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 877
__asm__ volatile("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 878
}  }  }  
# 879
(*retVal) = make_ulonglong1(tmp.x); 
# 880
} 
#endif
# 882 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 883
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 895
::exit(___);}
#if 0
# 883
{ 
# 884
float tmp; 
# 885
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 886
__asm__ volatile("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 887
} else { 
# 888
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 889
__asm__ volatile("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 890
} else { 
# 891
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 892
__asm__ volatile("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f" (tmp) : "l" (surfObject), "r" (x), "r" (y)); 
# 893
}  }  }  
# 894
(*retVal) = ((float)tmp); 
# 895
} 
#endif
# 897 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 898
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 910
::exit(___);}
#if 0
# 898
{ 
# 899
float1 tmp; 
# 900
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 901
__asm__ volatile("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 902
} else { 
# 903
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 904
__asm__ volatile("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 905
} else { 
# 906
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 907
__asm__ volatile("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f" (tmp.x) : "l" (surfObject), "r" (x), "r" (y)); 
# 908
}  }  }  
# 909
(*retVal) = make_float1(tmp.x); 
# 910
} 
#endif
# 918 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 919
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 931
::exit(___);}
#if 0
# 919
{ 
# 920
int2 tmp; 
# 921
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 922
__asm__ volatile("suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 923
} else { 
# 924
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 925
__asm__ volatile("suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 926
} else { 
# 927
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 928
__asm__ volatile("suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 929
}  }  }  
# 930
(*retVal) = make_char2(tmp.x, tmp.y); 
# 931
} 
#endif
# 933 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 934
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 946
::exit(___);}
#if 0
# 934
{ 
# 935
uint2 tmp; 
# 936
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 937
__asm__ volatile("suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 938
} else { 
# 939
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 940
__asm__ volatile("suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 941
} else { 
# 942
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 943
__asm__ volatile("suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 944
}  }  }  
# 945
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 946
} 
#endif
# 948 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 949
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 961
::exit(___);}
#if 0
# 949
{ 
# 950
short2 tmp; 
# 951
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 952
__asm__ volatile("suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 953
} else { 
# 954
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 955
__asm__ volatile("suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 956
} else { 
# 957
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 958
__asm__ volatile("suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 959
}  }  }  
# 960
(*retVal) = make_short2(tmp.x, tmp.y); 
# 961
} 
#endif
# 963 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 964
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 976
::exit(___);}
#if 0
# 964
{ 
# 965
ushort2 tmp; 
# 966
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 967
__asm__ volatile("suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 968
} else { 
# 969
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 970
__asm__ volatile("suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 971
} else { 
# 972
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 973
__asm__ volatile("suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 974
}  }  }  
# 975
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 976
} 
#endif
# 978 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 979
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 991
::exit(___);}
#if 0
# 979
{ 
# 980
int2 tmp; 
# 981
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 982
__asm__ volatile("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 983
} else { 
# 984
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 985
__asm__ volatile("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 986
} else { 
# 987
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 988
__asm__ volatile("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 989
}  }  }  
# 990
(*retVal) = make_int2(tmp.x, tmp.y); 
# 991
} 
#endif
# 993 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 994
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1006
::exit(___);}
#if 0
# 994
{ 
# 995
uint2 tmp; 
# 996
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 997
__asm__ volatile("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 998
} else { 
# 999
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1000
__asm__ volatile("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 1001
} else { 
# 1002
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1003
__asm__ volatile("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 1004
}  }  }  
# 1005
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 1006
} 
#endif
# 1008 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1009
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1021
::exit(___);}
#if 0
# 1009
{ 
# 1010
longlong2 tmp; 
# 1011
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1012
__asm__ volatile("suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 1013
} else { 
# 1014
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1015
__asm__ volatile("suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 1016
} else { 
# 1017
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1018
__asm__ volatile("suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 1019
}  }  }  
# 1020
(*retVal) = make_longlong2(tmp.x, tmp.y); 
# 1021
} 
#endif
# 1023 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1024
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1036
::exit(___);}
#if 0
# 1024
{ 
# 1025
ulonglong2 tmp; 
# 1026
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1027
__asm__ volatile("suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 1028
} else { 
# 1029
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1030
__asm__ volatile("suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 1031
} else { 
# 1032
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1033
__asm__ volatile("suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 1034
}  }  }  
# 1035
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
# 1036
} 
#endif
# 1038 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1039
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1051
::exit(___);}
#if 0
# 1039
{ 
# 1040
float2 tmp; 
# 1041
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1042
__asm__ volatile("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 1043
} else { 
# 1044
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1045
__asm__ volatile("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 1046
} else { 
# 1047
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1048
__asm__ volatile("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (x), "r" (y)); 
# 1049
}  }  }  
# 1050
(*retVal) = make_float2(tmp.x, tmp.y); 
# 1051
} 
#endif
# 1059 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1060
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1072
::exit(___);}
#if 0
# 1060
{ 
# 1061
int4 tmp; 
# 1062
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1063
__asm__ volatile("suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1064
} else { 
# 1065
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1066
__asm__ volatile("suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1067
} else { 
# 1068
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1069
__asm__ volatile("suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1070
}  }  }  
# 1071
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1072
} 
#endif
# 1074 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1075
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1087
::exit(___);}
#if 0
# 1075
{ 
# 1076
uint4 tmp; 
# 1077
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1078
__asm__ volatile("suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1079
} else { 
# 1080
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1081
__asm__ volatile("suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1082
} else { 
# 1083
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1084
__asm__ volatile("suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1085
}  }  }  
# 1086
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1087
} 
#endif
# 1089 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1090
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1102
::exit(___);}
#if 0
# 1090
{ 
# 1091
short4 tmp; 
# 1092
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1093
__asm__ volatile("suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1094
} else { 
# 1095
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1096
__asm__ volatile("suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1097
} else { 
# 1098
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1099
__asm__ volatile("suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1100
}  }  }  
# 1101
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1102
} 
#endif
# 1104 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1105
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1117
::exit(___);}
#if 0
# 1105
{ 
# 1106
ushort4 tmp; 
# 1107
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1108
__asm__ volatile("suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1109
} else { 
# 1110
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1111
__asm__ volatile("suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1112
} else { 
# 1113
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1114
__asm__ volatile("suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1115
}  }  }  
# 1116
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1117
} 
#endif
# 1119 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1120
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1132
::exit(___);}
#if 0
# 1120
{ 
# 1121
int4 tmp; 
# 1122
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1123
__asm__ volatile("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1124
} else { 
# 1125
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1126
__asm__ volatile("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1127
} else { 
# 1128
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1129
__asm__ volatile("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1130
}  }  }  
# 1131
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1132
} 
#endif
# 1134 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1135
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1147
::exit(___);}
#if 0
# 1135
{ 
# 1136
uint4 tmp; 
# 1137
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1138
__asm__ volatile("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1139
} else { 
# 1140
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1141
__asm__ volatile("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1142
} else { 
# 1143
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1144
__asm__ volatile("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1145
}  }  }  
# 1146
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1147
} 
#endif
# 1149 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1150
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1162
::exit(___);}
#if 0
# 1150
{ 
# 1151
float4 tmp; 
# 1152
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1153
__asm__ volatile("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1154
} else { 
# 1155
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1156
__asm__ volatile("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1157
} else { 
# 1158
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1159
__asm__ volatile("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (x), "r" (y)); 
# 1160
}  }  }  
# 1161
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1162
} 
#endif
# 1170 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
template< class T> 
# 1171
__attribute((always_inline)) __attribute__((unused)) static inline T surf2Dread(cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1172
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 1176
::exit(___);}
#if 0
# 1172
{ 
# 1173
T ret; 
# 1174
surf2Dread(&ret, surfObject, x, y, boundaryMode); 
# 1175
return ret; 
# 1176
} 
#endif
# 1184 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1185
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1197
::exit(___);}
#if 0
# 1185
{ 
# 1186
int tmp; 
# 1187
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1188
__asm__ volatile("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1189
} else { 
# 1190
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1191
__asm__ volatile("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1192
} else { 
# 1193
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1194
__asm__ volatile("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1195
}  }  }  
# 1196
(*retVal) = ((char)tmp); 
# 1197
} 
#endif
# 1199 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1200
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1212
::exit(___);}
#if 0
# 1200
{ 
# 1201
int tmp; 
# 1202
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1203
__asm__ volatile("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1204
} else { 
# 1205
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1206
__asm__ volatile("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1207
} else { 
# 1208
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1209
__asm__ volatile("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1210
}  }  }  
# 1211
(*retVal) = ((signed char)tmp); 
# 1212
} 
#endif
# 1214 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1215
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1227
::exit(___);}
#if 0
# 1215
{ 
# 1216
int1 tmp; 
# 1217
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1218
__asm__ volatile("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1219
} else { 
# 1220
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1221
__asm__ volatile("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1222
} else { 
# 1223
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1224
__asm__ volatile("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1225
}  }  }  
# 1226
(*retVal) = make_char1(tmp.x); 
# 1227
} 
#endif
# 1229 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1230
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1242
::exit(___);}
#if 0
# 1230
{ 
# 1231
unsigned tmp; 
# 1232
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1233
__asm__ volatile("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1234
} else { 
# 1235
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1236
__asm__ volatile("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1237
} else { 
# 1238
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1239
__asm__ volatile("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1240
}  }  }  
# 1241
(*retVal) = ((unsigned char)tmp); 
# 1242
} 
#endif
# 1244 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1245
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1257
::exit(___);}
#if 0
# 1245
{ 
# 1246
uint1 tmp; 
# 1247
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1248
__asm__ volatile("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1249
} else { 
# 1250
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1251
__asm__ volatile("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1252
} else { 
# 1253
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1254
__asm__ volatile("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1255
}  }  }  
# 1256
(*retVal) = make_uchar1(tmp.x); 
# 1257
} 
#endif
# 1259 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1260
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1272
::exit(___);}
#if 0
# 1260
{ 
# 1261
short tmp; 
# 1262
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1263
__asm__ volatile("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1264
} else { 
# 1265
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1266
__asm__ volatile("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1267
} else { 
# 1268
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1269
__asm__ volatile("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1270
}  }  }  
# 1271
(*retVal) = ((short)tmp); 
# 1272
} 
#endif
# 1274 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1275
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1287
::exit(___);}
#if 0
# 1275
{ 
# 1276
short1 tmp; 
# 1277
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1278
__asm__ volatile("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1279
} else { 
# 1280
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1281
__asm__ volatile("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1282
} else { 
# 1283
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1284
__asm__ volatile("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1285
}  }  }  
# 1286
(*retVal) = make_short1(tmp.x); 
# 1287
} 
#endif
# 1289 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1290
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1302
::exit(___);}
#if 0
# 1290
{ 
# 1291
unsigned short tmp; 
# 1292
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1293
__asm__ volatile("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1294
} else { 
# 1295
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1296
__asm__ volatile("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1297
} else { 
# 1298
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1299
__asm__ volatile("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1300
}  }  }  
# 1301
(*retVal) = ((unsigned short)tmp); 
# 1302
} 
#endif
# 1304 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1305
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1317
::exit(___);}
#if 0
# 1305
{ 
# 1306
ushort1 tmp; 
# 1307
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1308
__asm__ volatile("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1309
} else { 
# 1310
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1311
__asm__ volatile("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1312
} else { 
# 1313
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1314
__asm__ volatile("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1315
}  }  }  
# 1316
(*retVal) = make_ushort1(tmp.x); 
# 1317
} 
#endif
# 1319 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1320
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1332
::exit(___);}
#if 0
# 1320
{ 
# 1321
int tmp; 
# 1322
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1323
__asm__ volatile("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1324
} else { 
# 1325
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1326
__asm__ volatile("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1327
} else { 
# 1328
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1329
__asm__ volatile("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1330
}  }  }  
# 1331
(*retVal) = ((int)tmp); 
# 1332
} 
#endif
# 1334 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1335
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1347
::exit(___);}
#if 0
# 1335
{ 
# 1336
int1 tmp; 
# 1337
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1338
__asm__ volatile("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1339
} else { 
# 1340
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1341
__asm__ volatile("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1342
} else { 
# 1343
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1344
__asm__ volatile("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1345
}  }  }  
# 1346
(*retVal) = make_int1(tmp.x); 
# 1347
} 
#endif
# 1349 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1350
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1362
::exit(___);}
#if 0
# 1350
{ 
# 1351
unsigned tmp; 
# 1352
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1353
__asm__ volatile("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1354
} else { 
# 1355
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1356
__asm__ volatile("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1357
} else { 
# 1358
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1359
__asm__ volatile("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1360
}  }  }  
# 1361
(*retVal) = ((unsigned)tmp); 
# 1362
} 
#endif
# 1364 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1365
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1377
::exit(___);}
#if 0
# 1365
{ 
# 1366
uint1 tmp; 
# 1367
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1368
__asm__ volatile("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1369
} else { 
# 1370
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1371
__asm__ volatile("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1372
} else { 
# 1373
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1374
__asm__ volatile("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1375
}  }  }  
# 1376
(*retVal) = make_uint1(tmp.x); 
# 1377
} 
#endif
# 1379 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1380
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1392
::exit(___);}
#if 0
# 1380
{ 
# 1381
long long tmp; 
# 1382
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1383
__asm__ volatile("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1384
} else { 
# 1385
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1386
__asm__ volatile("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1387
} else { 
# 1388
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1389
__asm__ volatile("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1390
}  }  }  
# 1391
(*retVal) = ((long long)tmp); 
# 1392
} 
#endif
# 1394 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1395
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1407
::exit(___);}
#if 0
# 1395
{ 
# 1396
longlong1 tmp; 
# 1397
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1398
__asm__ volatile("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1399
} else { 
# 1400
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1401
__asm__ volatile("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1402
} else { 
# 1403
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1404
__asm__ volatile("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1405
}  }  }  
# 1406
(*retVal) = make_longlong1(tmp.x); 
# 1407
} 
#endif
# 1409 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1410
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1422
::exit(___);}
#if 0
# 1410
{ 
# 1411
unsigned long long tmp; 
# 1412
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1413
__asm__ volatile("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1414
} else { 
# 1415
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1416
__asm__ volatile("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1417
} else { 
# 1418
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1419
__asm__ volatile("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1420
}  }  }  
# 1421
(*retVal) = ((unsigned long long)tmp); 
# 1422
} 
#endif
# 1424 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1425
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1437
::exit(___);}
#if 0
# 1425
{ 
# 1426
ulonglong1 tmp; 
# 1427
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1428
__asm__ volatile("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1429
} else { 
# 1430
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1431
__asm__ volatile("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1432
} else { 
# 1433
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1434
__asm__ volatile("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1435
}  }  }  
# 1436
(*retVal) = make_ulonglong1(tmp.x); 
# 1437
} 
#endif
# 1439 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1440
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1452
::exit(___);}
#if 0
# 1440
{ 
# 1441
float tmp; 
# 1442
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1443
__asm__ volatile("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1444
} else { 
# 1445
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1446
__asm__ volatile("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1447
} else { 
# 1448
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1449
__asm__ volatile("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1450
}  }  }  
# 1451
(*retVal) = ((float)tmp); 
# 1452
} 
#endif
# 1454 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1455
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1467
::exit(___);}
#if 0
# 1455
{ 
# 1456
float1 tmp; 
# 1457
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1458
__asm__ volatile("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1459
} else { 
# 1460
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1461
__asm__ volatile("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1462
} else { 
# 1463
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1464
__asm__ volatile("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1465
}  }  }  
# 1466
(*retVal) = make_float1(tmp.x); 
# 1467
} 
#endif
# 1475 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1476
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1488
::exit(___);}
#if 0
# 1476
{ 
# 1477
int2 tmp; 
# 1478
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1479
__asm__ volatile("suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1480
} else { 
# 1481
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1482
__asm__ volatile("suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1483
} else { 
# 1484
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1485
__asm__ volatile("suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1486
}  }  }  
# 1487
(*retVal) = make_char2(tmp.x, tmp.y); 
# 1488
} 
#endif
# 1490 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1491
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1503
::exit(___);}
#if 0
# 1491
{ 
# 1492
uint2 tmp; 
# 1493
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1494
__asm__ volatile("suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1495
} else { 
# 1496
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1497
__asm__ volatile("suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1498
} else { 
# 1499
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1500
__asm__ volatile("suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1501
}  }  }  
# 1502
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 1503
} 
#endif
# 1505 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1506
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1518
::exit(___);}
#if 0
# 1506
{ 
# 1507
short2 tmp; 
# 1508
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1509
__asm__ volatile("suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1510
} else { 
# 1511
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1512
__asm__ volatile("suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1513
} else { 
# 1514
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1515
__asm__ volatile("suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1516
}  }  }  
# 1517
(*retVal) = make_short2(tmp.x, tmp.y); 
# 1518
} 
#endif
# 1520 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1521
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1533
::exit(___);}
#if 0
# 1521
{ 
# 1522
ushort2 tmp; 
# 1523
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1524
__asm__ volatile("suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1525
} else { 
# 1526
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1527
__asm__ volatile("suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1528
} else { 
# 1529
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1530
__asm__ volatile("suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1531
}  }  }  
# 1532
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 1533
} 
#endif
# 1535 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1536
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1548
::exit(___);}
#if 0
# 1536
{ 
# 1537
int2 tmp; 
# 1538
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1539
__asm__ volatile("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1540
} else { 
# 1541
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1542
__asm__ volatile("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1543
} else { 
# 1544
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1545
__asm__ volatile("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1546
}  }  }  
# 1547
(*retVal) = make_int2(tmp.x, tmp.y); 
# 1548
} 
#endif
# 1550 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1551
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1563
::exit(___);}
#if 0
# 1551
{ 
# 1552
uint2 tmp; 
# 1553
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1554
__asm__ volatile("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1555
} else { 
# 1556
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1557
__asm__ volatile("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1558
} else { 
# 1559
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1560
__asm__ volatile("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1561
}  }  }  
# 1562
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 1563
} 
#endif
# 1565 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1566
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1578
::exit(___);}
#if 0
# 1566
{ 
# 1567
longlong2 tmp; 
# 1568
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1569
__asm__ volatile("suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1570
} else { 
# 1571
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1572
__asm__ volatile("suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1573
} else { 
# 1574
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1575
__asm__ volatile("suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1576
}  }  }  
# 1577
(*retVal) = make_longlong2(tmp.x, tmp.y); 
# 1578
} 
#endif
# 1580 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1581
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1593
::exit(___);}
#if 0
# 1581
{ 
# 1582
ulonglong2 tmp; 
# 1583
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1584
__asm__ volatile("suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1585
} else { 
# 1586
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1587
__asm__ volatile("suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1588
} else { 
# 1589
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1590
__asm__ volatile("suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1591
}  }  }  
# 1592
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
# 1593
} 
#endif
# 1595 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1596
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1608
::exit(___);}
#if 0
# 1596
{ 
# 1597
float2 tmp; 
# 1598
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1599
__asm__ volatile("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1600
} else { 
# 1601
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1602
__asm__ volatile("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1603
} else { 
# 1604
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1605
__asm__ volatile("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1606
}  }  }  
# 1607
(*retVal) = make_float2(tmp.x, tmp.y); 
# 1608
} 
#endif
# 1616 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1617
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1629
::exit(___);}
#if 0
# 1617
{ 
# 1618
int4 tmp; 
# 1619
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1620
__asm__ volatile("suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1621
} else { 
# 1622
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1623
__asm__ volatile("suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1624
} else { 
# 1625
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1626
__asm__ volatile("suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1627
}  }  }  
# 1628
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1629
} 
#endif
# 1631 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1632
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1644
::exit(___);}
#if 0
# 1632
{ 
# 1633
uint4 tmp; 
# 1634
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1635
__asm__ volatile("suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1636
} else { 
# 1637
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1638
__asm__ volatile("suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1639
} else { 
# 1640
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1641
__asm__ volatile("suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1642
}  }  }  
# 1643
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1644
} 
#endif
# 1646 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1647
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1659
::exit(___);}
#if 0
# 1647
{ 
# 1648
short4 tmp; 
# 1649
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1650
__asm__ volatile("suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1651
} else { 
# 1652
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1653
__asm__ volatile("suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1654
} else { 
# 1655
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1656
__asm__ volatile("suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1657
}  }  }  
# 1658
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1659
} 
#endif
# 1661 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1662
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1674
::exit(___);}
#if 0
# 1662
{ 
# 1663
ushort4 tmp; 
# 1664
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1665
__asm__ volatile("suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1666
} else { 
# 1667
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1668
__asm__ volatile("suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1669
} else { 
# 1670
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1671
__asm__ volatile("suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1672
}  }  }  
# 1673
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1674
} 
#endif
# 1676 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1677
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1689
::exit(___);}
#if 0
# 1677
{ 
# 1678
int4 tmp; 
# 1679
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1680
__asm__ volatile("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1681
} else { 
# 1682
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1683
__asm__ volatile("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1684
} else { 
# 1685
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1686
__asm__ volatile("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1687
}  }  }  
# 1688
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1689
} 
#endif
# 1691 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1692
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1704
::exit(___);}
#if 0
# 1692
{ 
# 1693
uint4 tmp; 
# 1694
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1695
__asm__ volatile("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1696
} else { 
# 1697
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1698
__asm__ volatile("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1699
} else { 
# 1700
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1701
__asm__ volatile("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1702
}  }  }  
# 1703
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1704
} 
#endif
# 1706 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1707
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1719
::exit(___);}
#if 0
# 1707
{ 
# 1708
float4 tmp; 
# 1709
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1710
__asm__ volatile("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1711
} else { 
# 1712
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1713
__asm__ volatile("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1714
} else { 
# 1715
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1716
__asm__ volatile("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (x), "r" (y), "r" (z)); 
# 1717
}  }  }  
# 1718
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 1719
} 
#endif
# 1727 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
template< class T> 
# 1728
__attribute((always_inline)) __attribute__((unused)) static inline T surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1729
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 1733
::exit(___);}
#if 0
# 1729
{ 
# 1730
T ret; 
# 1731
surf3Dread(&ret, surfObject, x, y, z, boundaryMode); 
# 1732
return ret; 
# 1733
} 
#endif
# 1741 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1742
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1754
::exit(___);}
#if 0
# 1742
{ 
# 1743
int tmp; 
# 1744
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1745
__asm__ volatile("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1746
} else { 
# 1747
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1748
__asm__ volatile("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1749
} else { 
# 1750
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1751
__asm__ volatile("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1752
}  }  }  
# 1753
(*retVal) = ((char)tmp); 
# 1754
} 
#endif
# 1756 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1757
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1769
::exit(___);}
#if 0
# 1757
{ 
# 1758
int tmp; 
# 1759
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1760
__asm__ volatile("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1761
} else { 
# 1762
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1763
__asm__ volatile("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1764
} else { 
# 1765
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1766
__asm__ volatile("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1767
}  }  }  
# 1768
(*retVal) = ((signed char)tmp); 
# 1769
} 
#endif
# 1771 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1772
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1784
::exit(___);}
#if 0
# 1772
{ 
# 1773
int1 tmp; 
# 1774
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1775
__asm__ volatile("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1776
} else { 
# 1777
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1778
__asm__ volatile("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1779
} else { 
# 1780
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1781
__asm__ volatile("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1782
}  }  }  
# 1783
(*retVal) = make_char1(tmp.x); 
# 1784
} 
#endif
# 1786 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1787
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1799
::exit(___);}
#if 0
# 1787
{ 
# 1788
unsigned tmp; 
# 1789
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1790
__asm__ volatile("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1791
} else { 
# 1792
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1793
__asm__ volatile("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1794
} else { 
# 1795
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1796
__asm__ volatile("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1797
}  }  }  
# 1798
(*retVal) = ((unsigned char)tmp); 
# 1799
} 
#endif
# 1801 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1802
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1814
::exit(___);}
#if 0
# 1802
{ 
# 1803
uint1 tmp; 
# 1804
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1805
__asm__ volatile("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1806
} else { 
# 1807
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1808
__asm__ volatile("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1809
} else { 
# 1810
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1811
__asm__ volatile("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1812
}  }  }  
# 1813
(*retVal) = make_uchar1(tmp.x); 
# 1814
} 
#endif
# 1816 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1817
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1829
::exit(___);}
#if 0
# 1817
{ 
# 1818
short tmp; 
# 1819
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1820
__asm__ volatile("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1821
} else { 
# 1822
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1823
__asm__ volatile("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1824
} else { 
# 1825
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1826
__asm__ volatile("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1827
}  }  }  
# 1828
(*retVal) = ((short)tmp); 
# 1829
} 
#endif
# 1831 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1832
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1844
::exit(___);}
#if 0
# 1832
{ 
# 1833
short1 tmp; 
# 1834
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1835
__asm__ volatile("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1836
} else { 
# 1837
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1838
__asm__ volatile("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1839
} else { 
# 1840
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1841
__asm__ volatile("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1842
}  }  }  
# 1843
(*retVal) = make_short1(tmp.x); 
# 1844
} 
#endif
# 1846 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1847
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1859
::exit(___);}
#if 0
# 1847
{ 
# 1848
unsigned short tmp; 
# 1849
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1850
__asm__ volatile("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1851
} else { 
# 1852
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1853
__asm__ volatile("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1854
} else { 
# 1855
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1856
__asm__ volatile("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1857
}  }  }  
# 1858
(*retVal) = ((unsigned short)tmp); 
# 1859
} 
#endif
# 1861 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1862
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1874
::exit(___);}
#if 0
# 1862
{ 
# 1863
ushort1 tmp; 
# 1864
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1865
__asm__ volatile("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1866
} else { 
# 1867
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1868
__asm__ volatile("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1869
} else { 
# 1870
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1871
__asm__ volatile("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1872
}  }  }  
# 1873
(*retVal) = make_ushort1(tmp.x); 
# 1874
} 
#endif
# 1876 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1877
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1889
::exit(___);}
#if 0
# 1877
{ 
# 1878
int tmp; 
# 1879
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1880
__asm__ volatile("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1881
} else { 
# 1882
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1883
__asm__ volatile("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1884
} else { 
# 1885
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1886
__asm__ volatile("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1887
}  }  }  
# 1888
(*retVal) = ((int)tmp); 
# 1889
} 
#endif
# 1891 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1892
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1904
::exit(___);}
#if 0
# 1892
{ 
# 1893
int1 tmp; 
# 1894
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1895
__asm__ volatile("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1896
} else { 
# 1897
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1898
__asm__ volatile("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1899
} else { 
# 1900
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1901
__asm__ volatile("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1902
}  }  }  
# 1903
(*retVal) = make_int1(tmp.x); 
# 1904
} 
#endif
# 1906 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1907
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1919
::exit(___);}
#if 0
# 1907
{ 
# 1908
unsigned tmp; 
# 1909
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1910
__asm__ volatile("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1911
} else { 
# 1912
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1913
__asm__ volatile("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1914
} else { 
# 1915
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1916
__asm__ volatile("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1917
}  }  }  
# 1918
(*retVal) = ((unsigned)tmp); 
# 1919
} 
#endif
# 1921 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1922
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1934
::exit(___);}
#if 0
# 1922
{ 
# 1923
uint1 tmp; 
# 1924
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1925
__asm__ volatile("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1926
} else { 
# 1927
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1928
__asm__ volatile("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1929
} else { 
# 1930
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1931
__asm__ volatile("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1932
}  }  }  
# 1933
(*retVal) = make_uint1(tmp.x); 
# 1934
} 
#endif
# 1936 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1937
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1949
::exit(___);}
#if 0
# 1937
{ 
# 1938
long long tmp; 
# 1939
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1940
__asm__ volatile("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1941
} else { 
# 1942
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1943
__asm__ volatile("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1944
} else { 
# 1945
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1946
__asm__ volatile("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1947
}  }  }  
# 1948
(*retVal) = ((long long)tmp); 
# 1949
} 
#endif
# 1951 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1952
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1964
::exit(___);}
#if 0
# 1952
{ 
# 1953
longlong1 tmp; 
# 1954
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1955
__asm__ volatile("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1956
} else { 
# 1957
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1958
__asm__ volatile("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1959
} else { 
# 1960
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1961
__asm__ volatile("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1962
}  }  }  
# 1963
(*retVal) = make_longlong1(tmp.x); 
# 1964
} 
#endif
# 1966 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1967
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1979
::exit(___);}
#if 0
# 1967
{ 
# 1968
unsigned long long tmp; 
# 1969
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1970
__asm__ volatile("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1971
} else { 
# 1972
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1973
__asm__ volatile("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1974
} else { 
# 1975
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1976
__asm__ volatile("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1977
}  }  }  
# 1978
(*retVal) = ((unsigned long long)tmp); 
# 1979
} 
#endif
# 1981 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1982
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 1994
::exit(___);}
#if 0
# 1982
{ 
# 1983
ulonglong1 tmp; 
# 1984
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 1985
__asm__ volatile("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1986
} else { 
# 1987
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 1988
__asm__ volatile("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1989
} else { 
# 1990
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 1991
__asm__ volatile("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 1992
}  }  }  
# 1993
(*retVal) = make_ulonglong1(tmp.x); 
# 1994
} 
#endif
# 1996 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 1997
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2009
::exit(___);}
#if 0
# 1997
{ 
# 1998
float tmp; 
# 1999
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2000
__asm__ volatile("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2001
} else { 
# 2002
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2003
__asm__ volatile("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2004
} else { 
# 2005
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2006
__asm__ volatile("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f" (tmp) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2007
}  }  }  
# 2008
(*retVal) = ((float)tmp); 
# 2009
} 
#endif
# 2011 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2012
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2024
::exit(___);}
#if 0
# 2012
{ 
# 2013
float1 tmp; 
# 2014
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2015
__asm__ volatile("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2016
} else { 
# 2017
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2018
__asm__ volatile("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2019
} else { 
# 2020
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2021
__asm__ volatile("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2022
}  }  }  
# 2023
(*retVal) = make_float1(tmp.x); 
# 2024
} 
#endif
# 2032 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2033
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2045
::exit(___);}
#if 0
# 2033
{ 
# 2034
int2 tmp; 
# 2035
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2036
__asm__ volatile("suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2037
} else { 
# 2038
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2039
__asm__ volatile("suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2040
} else { 
# 2041
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2042
__asm__ volatile("suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2043
}  }  }  
# 2044
(*retVal) = make_char2(tmp.x, tmp.y); 
# 2045
} 
#endif
# 2047 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2048
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2060
::exit(___);}
#if 0
# 2048
{ 
# 2049
uint2 tmp; 
# 2050
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2051
__asm__ volatile("suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2052
} else { 
# 2053
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2054
__asm__ volatile("suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2055
} else { 
# 2056
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2057
__asm__ volatile("suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2058
}  }  }  
# 2059
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 2060
} 
#endif
# 2062 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2063
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2075
::exit(___);}
#if 0
# 2063
{ 
# 2064
short2 tmp; 
# 2065
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2066
__asm__ volatile("suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2067
} else { 
# 2068
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2069
__asm__ volatile("suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2070
} else { 
# 2071
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2072
__asm__ volatile("suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2073
}  }  }  
# 2074
(*retVal) = make_short2(tmp.x, tmp.y); 
# 2075
} 
#endif
# 2077 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2078
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2090
::exit(___);}
#if 0
# 2078
{ 
# 2079
ushort2 tmp; 
# 2080
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2081
__asm__ volatile("suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2082
} else { 
# 2083
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2084
__asm__ volatile("suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2085
} else { 
# 2086
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2087
__asm__ volatile("suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2088
}  }  }  
# 2089
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 2090
} 
#endif
# 2092 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2093
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2105
::exit(___);}
#if 0
# 2093
{ 
# 2094
int2 tmp; 
# 2095
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2096
__asm__ volatile("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2097
} else { 
# 2098
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2099
__asm__ volatile("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2100
} else { 
# 2101
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2102
__asm__ volatile("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2103
}  }  }  
# 2104
(*retVal) = make_int2(tmp.x, tmp.y); 
# 2105
} 
#endif
# 2107 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2108
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2120
::exit(___);}
#if 0
# 2108
{ 
# 2109
uint2 tmp; 
# 2110
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2111
__asm__ volatile("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2112
} else { 
# 2113
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2114
__asm__ volatile("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2115
} else { 
# 2116
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2117
__asm__ volatile("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2118
}  }  }  
# 2119
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 2120
} 
#endif
# 2122 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2123
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2135
::exit(___);}
#if 0
# 2123
{ 
# 2124
longlong2 tmp; 
# 2125
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2126
__asm__ volatile("suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2127
} else { 
# 2128
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2129
__asm__ volatile("suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2130
} else { 
# 2131
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2132
__asm__ volatile("suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2133
}  }  }  
# 2134
(*retVal) = make_longlong2(tmp.x, tmp.y); 
# 2135
} 
#endif
# 2137 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2138
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2150
::exit(___);}
#if 0
# 2138
{ 
# 2139
ulonglong2 tmp; 
# 2140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2141
__asm__ volatile("suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2142
} else { 
# 2143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2144
__asm__ volatile("suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2145
} else { 
# 2146
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2147
__asm__ volatile("suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2148
}  }  }  
# 2149
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
# 2150
} 
#endif
# 2152 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2153
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2165
::exit(___);}
#if 0
# 2153
{ 
# 2154
float2 tmp; 
# 2155
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2156
__asm__ volatile("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2157
} else { 
# 2158
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2159
__asm__ volatile("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2160
} else { 
# 2161
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2162
__asm__ volatile("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2163
}  }  }  
# 2164
(*retVal) = make_float2(tmp.x, tmp.y); 
# 2165
} 
#endif
# 2173 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2174
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2186
::exit(___);}
#if 0
# 2174
{ 
# 2175
int4 tmp; 
# 2176
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2177
__asm__ volatile("suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2178
} else { 
# 2179
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2180
__asm__ volatile("suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2181
} else { 
# 2182
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2183
__asm__ volatile("suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2184
}  }  }  
# 2185
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2186
} 
#endif
# 2188 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2189
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2201
::exit(___);}
#if 0
# 2189
{ 
# 2190
uint4 tmp; 
# 2191
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2192
__asm__ volatile("suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2193
} else { 
# 2194
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2195
__asm__ volatile("suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2196
} else { 
# 2197
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2198
__asm__ volatile("suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2199
}  }  }  
# 2200
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2201
} 
#endif
# 2203 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2204
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2216
::exit(___);}
#if 0
# 2204
{ 
# 2205
short4 tmp; 
# 2206
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2207
__asm__ volatile("suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2208
} else { 
# 2209
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2210
__asm__ volatile("suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2211
} else { 
# 2212
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2213
__asm__ volatile("suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2214
}  }  }  
# 2215
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2216
} 
#endif
# 2218 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2219
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2231
::exit(___);}
#if 0
# 2219
{ 
# 2220
ushort4 tmp; 
# 2221
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2222
__asm__ volatile("suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2223
} else { 
# 2224
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2225
__asm__ volatile("suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2226
} else { 
# 2227
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2228
__asm__ volatile("suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2229
}  }  }  
# 2230
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2231
} 
#endif
# 2233 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2234
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2246
::exit(___);}
#if 0
# 2234
{ 
# 2235
int4 tmp; 
# 2236
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2237
__asm__ volatile("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2238
} else { 
# 2239
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2240
__asm__ volatile("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2241
} else { 
# 2242
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2243
__asm__ volatile("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2244
}  }  }  
# 2245
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2246
} 
#endif
# 2248 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2249
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2261
::exit(___);}
#if 0
# 2249
{ 
# 2250
uint4 tmp; 
# 2251
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2252
__asm__ volatile("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2253
} else { 
# 2254
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2255
__asm__ volatile("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2256
} else { 
# 2257
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2258
__asm__ volatile("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2259
}  }  }  
# 2260
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2261
} 
#endif
# 2263 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2264
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2276
::exit(___);}
#if 0
# 2264
{ 
# 2265
float4 tmp; 
# 2266
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2267
__asm__ volatile("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2268
} else { 
# 2269
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2270
__asm__ volatile("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2271
} else { 
# 2272
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2273
__asm__ volatile("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x)); 
# 2274
}  }  }  
# 2275
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2276
} 
#endif
# 2284 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
template< class T> 
# 2285
__attribute((always_inline)) __attribute__((unused)) static inline T surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2286
{int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 2290
::exit(___);}
#if 0
# 2286
{ 
# 2287
T ret; 
# 2288
surf1DLayeredread(&ret, surfObject, x, layer, boundaryMode); 
# 2289
return ret; 
# 2290
} 
#endif
# 2298 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2299
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2311
::exit(___);}
#if 0
# 2299
{ 
# 2300
int tmp; 
# 2301
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2302
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2303
} else { 
# 2304
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2305
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2306
} else { 
# 2307
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2308
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2309
}  }  }  
# 2310
(*retVal) = ((char)tmp); 
# 2311
} 
#endif
# 2313 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2314
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2326
::exit(___);}
#if 0
# 2314
{ 
# 2315
int tmp; 
# 2316
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2317
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2318
} else { 
# 2319
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2320
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2321
} else { 
# 2322
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2323
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2324
}  }  }  
# 2325
(*retVal) = ((signed char)tmp); 
# 2326
} 
#endif
# 2328 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2329
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2341
::exit(___);}
#if 0
# 2329
{ 
# 2330
int1 tmp; 
# 2331
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2332
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2333
} else { 
# 2334
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2335
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2336
} else { 
# 2337
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2338
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2339
}  }  }  
# 2340
(*retVal) = make_char1(tmp.x); 
# 2341
} 
#endif
# 2343 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2344
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2356
::exit(___);}
#if 0
# 2344
{ 
# 2345
unsigned tmp; 
# 2346
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2347
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2348
} else { 
# 2349
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2350
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2351
} else { 
# 2352
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2353
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2354
}  }  }  
# 2355
(*retVal) = ((unsigned char)tmp); 
# 2356
} 
#endif
# 2358 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2359
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2371
::exit(___);}
#if 0
# 2359
{ 
# 2360
uint1 tmp; 
# 2361
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2362
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2363
} else { 
# 2364
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2365
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2366
} else { 
# 2367
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2368
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2369
}  }  }  
# 2370
(*retVal) = make_uchar1(tmp.x); 
# 2371
} 
#endif
# 2373 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2374
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2386
::exit(___);}
#if 0
# 2374
{ 
# 2375
short tmp; 
# 2376
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2377
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2378
} else { 
# 2379
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2380
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2381
} else { 
# 2382
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2383
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2384
}  }  }  
# 2385
(*retVal) = ((short)tmp); 
# 2386
} 
#endif
# 2388 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2389
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2401
::exit(___);}
#if 0
# 2389
{ 
# 2390
short1 tmp; 
# 2391
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2392
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2393
} else { 
# 2394
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2395
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2396
} else { 
# 2397
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2398
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2399
}  }  }  
# 2400
(*retVal) = make_short1(tmp.x); 
# 2401
} 
#endif
# 2403 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2404
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2416
::exit(___);}
#if 0
# 2404
{ 
# 2405
unsigned short tmp; 
# 2406
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2407
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2408
} else { 
# 2409
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2410
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2411
} else { 
# 2412
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2413
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2414
}  }  }  
# 2415
(*retVal) = ((unsigned short)tmp); 
# 2416
} 
#endif
# 2418 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2419
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2431
::exit(___);}
#if 0
# 2419
{ 
# 2420
ushort1 tmp; 
# 2421
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2422
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2423
} else { 
# 2424
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2425
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2426
} else { 
# 2427
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2428
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2429
}  }  }  
# 2430
(*retVal) = make_ushort1(tmp.x); 
# 2431
} 
#endif
# 2433 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2434
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2446
::exit(___);}
#if 0
# 2434
{ 
# 2435
int tmp; 
# 2436
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2437
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2438
} else { 
# 2439
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2440
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2441
} else { 
# 2442
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2443
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2444
}  }  }  
# 2445
(*retVal) = ((int)tmp); 
# 2446
} 
#endif
# 2448 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2449
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2461
::exit(___);}
#if 0
# 2449
{ 
# 2450
int1 tmp; 
# 2451
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2452
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2453
} else { 
# 2454
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2455
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2456
} else { 
# 2457
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2458
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2459
}  }  }  
# 2460
(*retVal) = make_int1(tmp.x); 
# 2461
} 
#endif
# 2463 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2464
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2476
::exit(___);}
#if 0
# 2464
{ 
# 2465
unsigned tmp; 
# 2466
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2467
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2468
} else { 
# 2469
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2470
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2471
} else { 
# 2472
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2473
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2474
}  }  }  
# 2475
(*retVal) = ((unsigned)tmp); 
# 2476
} 
#endif
# 2478 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2479
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2491
::exit(___);}
#if 0
# 2479
{ 
# 2480
uint1 tmp; 
# 2481
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2482
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2483
} else { 
# 2484
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2485
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2486
} else { 
# 2487
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2488
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2489
}  }  }  
# 2490
(*retVal) = make_uint1(tmp.x); 
# 2491
} 
#endif
# 2493 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2494
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2506
::exit(___);}
#if 0
# 2494
{ 
# 2495
long long tmp; 
# 2496
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2497
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2498
} else { 
# 2499
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2500
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2501
} else { 
# 2502
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2503
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2504
}  }  }  
# 2505
(*retVal) = ((long long)tmp); 
# 2506
} 
#endif
# 2508 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2509
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2521
::exit(___);}
#if 0
# 2509
{ 
# 2510
longlong1 tmp; 
# 2511
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2512
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2513
} else { 
# 2514
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2515
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2516
} else { 
# 2517
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2518
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2519
}  }  }  
# 2520
(*retVal) = make_longlong1(tmp.x); 
# 2521
} 
#endif
# 2523 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2524
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2536
::exit(___);}
#if 0
# 2524
{ 
# 2525
unsigned long long tmp; 
# 2526
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2527
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2528
} else { 
# 2529
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2530
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2531
} else { 
# 2532
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2533
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2534
}  }  }  
# 2535
(*retVal) = ((unsigned long long)tmp); 
# 2536
} 
#endif
# 2538 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2539
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2551
::exit(___);}
#if 0
# 2539
{ 
# 2540
ulonglong1 tmp; 
# 2541
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2542
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2543
} else { 
# 2544
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2545
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2546
} else { 
# 2547
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2548
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2549
}  }  }  
# 2550
(*retVal) = make_ulonglong1(tmp.x); 
# 2551
} 
#endif
# 2553 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2554
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2566
::exit(___);}
#if 0
# 2554
{ 
# 2555
float tmp; 
# 2556
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2557
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2558
} else { 
# 2559
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2560
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2561
} else { 
# 2562
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2563
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2564
}  }  }  
# 2565
(*retVal) = ((float)tmp); 
# 2566
} 
#endif
# 2568 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2569
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2581
::exit(___);}
#if 0
# 2569
{ 
# 2570
float1 tmp; 
# 2571
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2572
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2573
} else { 
# 2574
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2575
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2576
} else { 
# 2577
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2578
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2579
}  }  }  
# 2580
(*retVal) = make_float1(tmp.x); 
# 2581
} 
#endif
# 2589 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2590
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2602
::exit(___);}
#if 0
# 2590
{ 
# 2591
int2 tmp; 
# 2592
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2593
__asm__ volatile("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2594
} else { 
# 2595
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2596
__asm__ volatile("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2597
} else { 
# 2598
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2599
__asm__ volatile("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2600
}  }  }  
# 2601
(*retVal) = make_char2(tmp.x, tmp.y); 
# 2602
} 
#endif
# 2604 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2605
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2617
::exit(___);}
#if 0
# 2605
{ 
# 2606
uint2 tmp; 
# 2607
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2608
__asm__ volatile("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2609
} else { 
# 2610
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2611
__asm__ volatile("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2612
} else { 
# 2613
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2614
__asm__ volatile("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2615
}  }  }  
# 2616
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 2617
} 
#endif
# 2619 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2620
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2632
::exit(___);}
#if 0
# 2620
{ 
# 2621
short2 tmp; 
# 2622
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2623
__asm__ volatile("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2624
} else { 
# 2625
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2626
__asm__ volatile("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2627
} else { 
# 2628
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2629
__asm__ volatile("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2630
}  }  }  
# 2631
(*retVal) = make_short2(tmp.x, tmp.y); 
# 2632
} 
#endif
# 2634 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2635
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2647
::exit(___);}
#if 0
# 2635
{ 
# 2636
ushort2 tmp; 
# 2637
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2638
__asm__ volatile("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2639
} else { 
# 2640
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2641
__asm__ volatile("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2642
} else { 
# 2643
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2644
__asm__ volatile("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2645
}  }  }  
# 2646
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 2647
} 
#endif
# 2649 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2650
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2662
::exit(___);}
#if 0
# 2650
{ 
# 2651
int2 tmp; 
# 2652
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2653
__asm__ volatile("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2654
} else { 
# 2655
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2656
__asm__ volatile("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2657
} else { 
# 2658
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2659
__asm__ volatile("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2660
}  }  }  
# 2661
(*retVal) = make_int2(tmp.x, tmp.y); 
# 2662
} 
#endif
# 2664 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2665
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2677
::exit(___);}
#if 0
# 2665
{ 
# 2666
uint2 tmp; 
# 2667
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2668
__asm__ volatile("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2669
} else { 
# 2670
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2671
__asm__ volatile("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2672
} else { 
# 2673
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2674
__asm__ volatile("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2675
}  }  }  
# 2676
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 2677
} 
#endif
# 2679 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2680
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2692
::exit(___);}
#if 0
# 2680
{ 
# 2681
longlong2 tmp; 
# 2682
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2683
__asm__ volatile("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2684
} else { 
# 2685
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2686
__asm__ volatile("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2687
} else { 
# 2688
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2689
__asm__ volatile("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2690
}  }  }  
# 2691
(*retVal) = make_longlong2(tmp.x, tmp.y); 
# 2692
} 
#endif
# 2694 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2695
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2707
::exit(___);}
#if 0
# 2695
{ 
# 2696
ulonglong2 tmp; 
# 2697
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2698
__asm__ volatile("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2699
} else { 
# 2700
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2701
__asm__ volatile("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2702
} else { 
# 2703
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2704
__asm__ volatile("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2705
}  }  }  
# 2706
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
# 2707
} 
#endif
# 2709 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2710
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2722
::exit(___);}
#if 0
# 2710
{ 
# 2711
float2 tmp; 
# 2712
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2713
__asm__ volatile("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2714
} else { 
# 2715
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2716
__asm__ volatile("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2717
} else { 
# 2718
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2719
__asm__ volatile("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2720
}  }  }  
# 2721
(*retVal) = make_float2(tmp.x, tmp.y); 
# 2722
} 
#endif
# 2730 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2731
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2743
::exit(___);}
#if 0
# 2731
{ 
# 2732
int4 tmp; 
# 2733
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2734
__asm__ volatile("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2735
} else { 
# 2736
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2737
__asm__ volatile("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2738
} else { 
# 2739
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2740
__asm__ volatile("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2741
}  }  }  
# 2742
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2743
} 
#endif
# 2745 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2746
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2758
::exit(___);}
#if 0
# 2746
{ 
# 2747
uint4 tmp; 
# 2748
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2749
__asm__ volatile("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2750
} else { 
# 2751
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2752
__asm__ volatile("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2753
} else { 
# 2754
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2755
__asm__ volatile("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2756
}  }  }  
# 2757
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2758
} 
#endif
# 2760 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2761
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2773
::exit(___);}
#if 0
# 2761
{ 
# 2762
short4 tmp; 
# 2763
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2764
__asm__ volatile("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2765
} else { 
# 2766
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2767
__asm__ volatile("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2768
} else { 
# 2769
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2770
__asm__ volatile("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2771
}  }  }  
# 2772
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2773
} 
#endif
# 2775 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2776
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2788
::exit(___);}
#if 0
# 2776
{ 
# 2777
ushort4 tmp; 
# 2778
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2779
__asm__ volatile("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2780
} else { 
# 2781
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2782
__asm__ volatile("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2783
} else { 
# 2784
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2785
__asm__ volatile("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2786
}  }  }  
# 2787
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2788
} 
#endif
# 2790 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2791
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2803
::exit(___);}
#if 0
# 2791
{ 
# 2792
int4 tmp; 
# 2793
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2794
__asm__ volatile("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2795
} else { 
# 2796
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2797
__asm__ volatile("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2798
} else { 
# 2799
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2800
__asm__ volatile("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2801
}  }  }  
# 2802
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2803
} 
#endif
# 2805 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2806
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2818
::exit(___);}
#if 0
# 2806
{ 
# 2807
uint4 tmp; 
# 2808
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2809
__asm__ volatile("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2810
} else { 
# 2811
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2812
__asm__ volatile("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2813
} else { 
# 2814
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2815
__asm__ volatile("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2816
}  }  }  
# 2817
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2818
} 
#endif
# 2820 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2821
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2833
::exit(___);}
#if 0
# 2821
{ 
# 2822
float4 tmp; 
# 2823
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2824
__asm__ volatile("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2825
} else { 
# 2826
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2827
__asm__ volatile("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2828
} else { 
# 2829
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2830
__asm__ volatile("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (layer), "r" (x), "r" (y)); 
# 2831
}  }  }  
# 2832
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 2833
} 
#endif
# 2841 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
template< class T> 
# 2842
__attribute((always_inline)) __attribute__((unused)) static inline T surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2843
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 2847
::exit(___);}
#if 0
# 2843
{ 
# 2844
T ret; 
# 2845
surf2DLayeredread(&ret, surfObject, x, y, layer, boundaryMode); 
# 2846
return ret; 
# 2847
} 
#endif
# 2855 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2856
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2868
::exit(___);}
#if 0
# 2856
{ 
# 2857
int tmp; 
# 2858
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2859
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2860
} else { 
# 2861
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2862
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2863
} else { 
# 2864
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2865
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2866
}  }  }  
# 2867
(*retVal) = ((char)tmp); 
# 2868
} 
#endif
# 2870 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2871
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2883
::exit(___);}
#if 0
# 2871
{ 
# 2872
int tmp; 
# 2873
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2874
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2875
} else { 
# 2876
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2877
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2878
} else { 
# 2879
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2880
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2881
}  }  }  
# 2882
(*retVal) = ((signed char)tmp); 
# 2883
} 
#endif
# 2885 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2886
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2898
::exit(___);}
#if 0
# 2886
{ 
# 2887
int1 tmp; 
# 2888
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2889
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2890
} else { 
# 2891
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2892
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2893
} else { 
# 2894
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2895
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2896
}  }  }  
# 2897
(*retVal) = make_char1(tmp.x); 
# 2898
} 
#endif
# 2900 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2901
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2913
::exit(___);}
#if 0
# 2901
{ 
# 2902
unsigned tmp; 
# 2903
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2904
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2905
} else { 
# 2906
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2907
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2908
} else { 
# 2909
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2910
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2911
}  }  }  
# 2912
(*retVal) = ((unsigned char)tmp); 
# 2913
} 
#endif
# 2915 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2916
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2928
::exit(___);}
#if 0
# 2916
{ 
# 2917
uint1 tmp; 
# 2918
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2919
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2920
} else { 
# 2921
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2922
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2923
} else { 
# 2924
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2925
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2926
}  }  }  
# 2927
(*retVal) = make_uchar1(tmp.x); 
# 2928
} 
#endif
# 2930 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2931
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2943
::exit(___);}
#if 0
# 2931
{ 
# 2932
short tmp; 
# 2933
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2934
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2935
} else { 
# 2936
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2937
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2938
} else { 
# 2939
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2940
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2941
}  }  }  
# 2942
(*retVal) = ((short)tmp); 
# 2943
} 
#endif
# 2945 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2946
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2958
::exit(___);}
#if 0
# 2946
{ 
# 2947
short1 tmp; 
# 2948
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2949
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2950
} else { 
# 2951
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2952
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2953
} else { 
# 2954
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2955
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2956
}  }  }  
# 2957
(*retVal) = make_short1(tmp.x); 
# 2958
} 
#endif
# 2960 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2961
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2973
::exit(___);}
#if 0
# 2961
{ 
# 2962
unsigned short tmp; 
# 2963
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2964
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2965
} else { 
# 2966
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2967
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2968
} else { 
# 2969
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2970
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2971
}  }  }  
# 2972
(*retVal) = ((unsigned short)tmp); 
# 2973
} 
#endif
# 2975 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2976
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 2988
::exit(___);}
#if 0
# 2976
{ 
# 2977
ushort1 tmp; 
# 2978
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2979
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2980
} else { 
# 2981
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2982
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2983
} else { 
# 2984
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 2985
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2986
}  }  }  
# 2987
(*retVal) = make_ushort1(tmp.x); 
# 2988
} 
#endif
# 2990 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 2991
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3003
::exit(___);}
#if 0
# 2991
{ 
# 2992
int tmp; 
# 2993
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 2994
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2995
} else { 
# 2996
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 2997
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 2998
} else { 
# 2999
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3000
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3001
}  }  }  
# 3002
(*retVal) = ((int)tmp); 
# 3003
} 
#endif
# 3005 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3006
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3018
::exit(___);}
#if 0
# 3006
{ 
# 3007
int1 tmp; 
# 3008
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3009
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3010
} else { 
# 3011
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3012
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3013
} else { 
# 3014
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3015
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3016
}  }  }  
# 3017
(*retVal) = make_int1(tmp.x); 
# 3018
} 
#endif
# 3020 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3021
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3033
::exit(___);}
#if 0
# 3021
{ 
# 3022
unsigned tmp; 
# 3023
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3024
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3025
} else { 
# 3026
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3027
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3028
} else { 
# 3029
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3030
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3031
}  }  }  
# 3032
(*retVal) = ((unsigned)tmp); 
# 3033
} 
#endif
# 3035 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3036
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3048
::exit(___);}
#if 0
# 3036
{ 
# 3037
uint1 tmp; 
# 3038
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3039
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3040
} else { 
# 3041
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3042
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3043
} else { 
# 3044
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3045
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3046
}  }  }  
# 3047
(*retVal) = make_uint1(tmp.x); 
# 3048
} 
#endif
# 3050 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3051
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3063
::exit(___);}
#if 0
# 3051
{ 
# 3052
long long tmp; 
# 3053
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3054
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3055
} else { 
# 3056
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3057
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3058
} else { 
# 3059
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3060
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3061
}  }  }  
# 3062
(*retVal) = ((long long)tmp); 
# 3063
} 
#endif
# 3065 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3066
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3078
::exit(___);}
#if 0
# 3066
{ 
# 3067
longlong1 tmp; 
# 3068
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3069
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3070
} else { 
# 3071
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3072
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3073
} else { 
# 3074
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3075
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3076
}  }  }  
# 3077
(*retVal) = make_longlong1(tmp.x); 
# 3078
} 
#endif
# 3080 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3081
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3093
::exit(___);}
#if 0
# 3081
{ 
# 3082
unsigned long long tmp; 
# 3083
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3084
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3085
} else { 
# 3086
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3087
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3088
} else { 
# 3089
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3090
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3091
}  }  }  
# 3092
(*retVal) = ((unsigned long long)tmp); 
# 3093
} 
#endif
# 3095 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3096
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3108
::exit(___);}
#if 0
# 3096
{ 
# 3097
ulonglong1 tmp; 
# 3098
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3099
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3100
} else { 
# 3101
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3102
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3103
} else { 
# 3104
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3105
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3106
}  }  }  
# 3107
(*retVal) = make_ulonglong1(tmp.x); 
# 3108
} 
#endif
# 3110 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3111
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3123
::exit(___);}
#if 0
# 3111
{ 
# 3112
float tmp; 
# 3113
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3114
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3115
} else { 
# 3116
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3117
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3118
} else { 
# 3119
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3120
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3121
}  }  }  
# 3122
(*retVal) = ((float)tmp); 
# 3123
} 
#endif
# 3125 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3126
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3138
::exit(___);}
#if 0
# 3126
{ 
# 3127
float1 tmp; 
# 3128
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3129
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3130
} else { 
# 3131
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3132
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3133
} else { 
# 3134
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3135
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3136
}  }  }  
# 3137
(*retVal) = make_float1(tmp.x); 
# 3138
} 
#endif
# 3146 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3147
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3159
::exit(___);}
#if 0
# 3147
{ 
# 3148
int2 tmp; 
# 3149
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3150
__asm__ volatile("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3151
} else { 
# 3152
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3153
__asm__ volatile("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3154
} else { 
# 3155
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3156
__asm__ volatile("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3157
}  }  }  
# 3158
(*retVal) = make_char2(tmp.x, tmp.y); 
# 3159
} 
#endif
# 3161 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3162
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3174
::exit(___);}
#if 0
# 3162
{ 
# 3163
uint2 tmp; 
# 3164
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3165
__asm__ volatile("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3166
} else { 
# 3167
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3168
__asm__ volatile("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3169
} else { 
# 3170
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3171
__asm__ volatile("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3172
}  }  }  
# 3173
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 3174
} 
#endif
# 3176 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3177
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3189
::exit(___);}
#if 0
# 3177
{ 
# 3178
short2 tmp; 
# 3179
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3180
__asm__ volatile("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3181
} else { 
# 3182
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3183
__asm__ volatile("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3184
} else { 
# 3185
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3186
__asm__ volatile("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3187
}  }  }  
# 3188
(*retVal) = make_short2(tmp.x, tmp.y); 
# 3189
} 
#endif
# 3191 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3192
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3204
::exit(___);}
#if 0
# 3192
{ 
# 3193
ushort2 tmp; 
# 3194
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3195
__asm__ volatile("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3196
} else { 
# 3197
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3198
__asm__ volatile("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3199
} else { 
# 3200
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3201
__asm__ volatile("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3202
}  }  }  
# 3203
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 3204
} 
#endif
# 3206 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3207
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3219
::exit(___);}
#if 0
# 3207
{ 
# 3208
int2 tmp; 
# 3209
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3210
__asm__ volatile("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3211
} else { 
# 3212
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3213
__asm__ volatile("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3214
} else { 
# 3215
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3216
__asm__ volatile("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3217
}  }  }  
# 3218
(*retVal) = make_int2(tmp.x, tmp.y); 
# 3219
} 
#endif
# 3221 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3222
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3234
::exit(___);}
#if 0
# 3222
{ 
# 3223
uint2 tmp; 
# 3224
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3225
__asm__ volatile("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3226
} else { 
# 3227
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3228
__asm__ volatile("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3229
} else { 
# 3230
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3231
__asm__ volatile("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3232
}  }  }  
# 3233
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 3234
} 
#endif
# 3236 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3237
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3249
::exit(___);}
#if 0
# 3237
{ 
# 3238
longlong2 tmp; 
# 3239
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3240
__asm__ volatile("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3241
} else { 
# 3242
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3243
__asm__ volatile("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3244
} else { 
# 3245
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3246
__asm__ volatile("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3247
}  }  }  
# 3248
(*retVal) = make_longlong2(tmp.x, tmp.y); 
# 3249
} 
#endif
# 3251 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3252
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3264
::exit(___);}
#if 0
# 3252
{ 
# 3253
ulonglong2 tmp; 
# 3254
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3255
__asm__ volatile("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3256
} else { 
# 3257
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3258
__asm__ volatile("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3259
} else { 
# 3260
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3261
__asm__ volatile("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3262
}  }  }  
# 3263
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
# 3264
} 
#endif
# 3266 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3267
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3279
::exit(___);}
#if 0
# 3267
{ 
# 3268
float2 tmp; 
# 3269
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3270
__asm__ volatile("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3271
} else { 
# 3272
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3273
__asm__ volatile("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3274
} else { 
# 3275
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3276
__asm__ volatile("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3277
}  }  }  
# 3278
(*retVal) = make_float2(tmp.x, tmp.y); 
# 3279
} 
#endif
# 3287 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3288
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3300
::exit(___);}
#if 0
# 3288
{ 
# 3289
int4 tmp; 
# 3290
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3291
__asm__ volatile("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3292
} else { 
# 3293
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3294
__asm__ volatile("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3295
} else { 
# 3296
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3297
__asm__ volatile("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3298
}  }  }  
# 3299
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3300
} 
#endif
# 3302 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3303
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3315
::exit(___);}
#if 0
# 3303
{ 
# 3304
uint4 tmp; 
# 3305
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3306
__asm__ volatile("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3307
} else { 
# 3308
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3309
__asm__ volatile("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3310
} else { 
# 3311
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3312
__asm__ volatile("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3313
}  }  }  
# 3314
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3315
} 
#endif
# 3317 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3318
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3330
::exit(___);}
#if 0
# 3318
{ 
# 3319
short4 tmp; 
# 3320
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3321
__asm__ volatile("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3322
} else { 
# 3323
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3324
__asm__ volatile("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3325
} else { 
# 3326
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3327
__asm__ volatile("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3328
}  }  }  
# 3329
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3330
} 
#endif
# 3332 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3333
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3345
::exit(___);}
#if 0
# 3333
{ 
# 3334
ushort4 tmp; 
# 3335
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3336
__asm__ volatile("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3337
} else { 
# 3338
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3339
__asm__ volatile("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3340
} else { 
# 3341
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3342
__asm__ volatile("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3343
}  }  }  
# 3344
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3345
} 
#endif
# 3347 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3348
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3360
::exit(___);}
#if 0
# 3348
{ 
# 3349
int4 tmp; 
# 3350
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3351
__asm__ volatile("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3352
} else { 
# 3353
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3354
__asm__ volatile("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3355
} else { 
# 3356
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3357
__asm__ volatile("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3358
}  }  }  
# 3359
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3360
} 
#endif
# 3362 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3363
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3375
::exit(___);}
#if 0
# 3363
{ 
# 3364
uint4 tmp; 
# 3365
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3366
__asm__ volatile("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3367
} else { 
# 3368
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3369
__asm__ volatile("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3370
} else { 
# 3371
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3372
__asm__ volatile("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3373
}  }  }  
# 3374
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3375
} 
#endif
# 3377 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3378
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3390
::exit(___);}
#if 0
# 3378
{ 
# 3379
float4 tmp; 
# 3380
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3381
__asm__ volatile("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3382
} else { 
# 3383
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3384
__asm__ volatile("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3385
} else { 
# 3386
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3387
__asm__ volatile("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (face), "r" (x), "r" (y)); 
# 3388
}  }  }  
# 3389
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3390
} 
#endif
# 3398 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
template< class T> 
# 3399
__attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3400
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 3404
::exit(___);}
#if 0
# 3400
{ 
# 3401
T ret; 
# 3402
surfCubemapread(&ret, surfObject, face, x, y, boundaryMode); 
# 3403
return ret; 
# 3404
} 
#endif
# 3412 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3413
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3425
::exit(___);}
#if 0
# 3413
{ 
# 3414
int tmp; 
# 3415
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3416
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3417
} else { 
# 3418
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3419
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3420
} else { 
# 3421
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3422
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3423
}  }  }  
# 3424
(*retVal) = ((char)tmp); 
# 3425
} 
#endif
# 3427 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3428
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3440
::exit(___);}
#if 0
# 3428
{ 
# 3429
int tmp; 
# 3430
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3431
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3432
} else { 
# 3433
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3434
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3435
} else { 
# 3436
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3437
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3438
}  }  }  
# 3439
(*retVal) = ((signed char)tmp); 
# 3440
} 
#endif
# 3442 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3443
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3455
::exit(___);}
#if 0
# 3443
{ 
# 3444
int1 tmp; 
# 3445
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3446
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3447
} else { 
# 3448
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3449
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3450
} else { 
# 3451
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3452
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3453
}  }  }  
# 3454
(*retVal) = make_char1(tmp.x); 
# 3455
} 
#endif
# 3457 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3458
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3470
::exit(___);}
#if 0
# 3458
{ 
# 3459
unsigned tmp; 
# 3460
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3461
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3462
} else { 
# 3463
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3464
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3465
} else { 
# 3466
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3467
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3468
}  }  }  
# 3469
(*retVal) = ((unsigned char)tmp); 
# 3470
} 
#endif
# 3472 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3473
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3485
::exit(___);}
#if 0
# 3473
{ 
# 3474
uint1 tmp; 
# 3475
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3476
__asm__ volatile("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3477
} else { 
# 3478
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3479
__asm__ volatile("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3480
} else { 
# 3481
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3482
__asm__ volatile("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3483
}  }  }  
# 3484
(*retVal) = make_uchar1(tmp.x); 
# 3485
} 
#endif
# 3487 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3488
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3500
::exit(___);}
#if 0
# 3488
{ 
# 3489
short tmp; 
# 3490
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3491
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3492
} else { 
# 3493
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3494
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3495
} else { 
# 3496
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3497
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3498
}  }  }  
# 3499
(*retVal) = ((short)tmp); 
# 3500
} 
#endif
# 3502 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3503
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3515
::exit(___);}
#if 0
# 3503
{ 
# 3504
short1 tmp; 
# 3505
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3506
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3507
} else { 
# 3508
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3509
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3510
} else { 
# 3511
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3512
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3513
}  }  }  
# 3514
(*retVal) = make_short1(tmp.x); 
# 3515
} 
#endif
# 3517 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3518
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3530
::exit(___);}
#if 0
# 3518
{ 
# 3519
unsigned short tmp; 
# 3520
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3521
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3522
} else { 
# 3523
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3524
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3525
} else { 
# 3526
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3527
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3528
}  }  }  
# 3529
(*retVal) = ((unsigned short)tmp); 
# 3530
} 
#endif
# 3532 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3533
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3545
::exit(___);}
#if 0
# 3533
{ 
# 3534
ushort1 tmp; 
# 3535
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3536
__asm__ volatile("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3537
} else { 
# 3538
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3539
__asm__ volatile("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3540
} else { 
# 3541
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3542
__asm__ volatile("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3543
}  }  }  
# 3544
(*retVal) = make_ushort1(tmp.x); 
# 3545
} 
#endif
# 3547 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3548
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3560
::exit(___);}
#if 0
# 3548
{ 
# 3549
int tmp; 
# 3550
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3551
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3552
} else { 
# 3553
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3554
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3555
} else { 
# 3556
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3557
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3558
}  }  }  
# 3559
(*retVal) = ((int)tmp); 
# 3560
} 
#endif
# 3562 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3563
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3575
::exit(___);}
#if 0
# 3563
{ 
# 3564
int1 tmp; 
# 3565
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3566
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3567
} else { 
# 3568
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3569
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3570
} else { 
# 3571
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3572
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3573
}  }  }  
# 3574
(*retVal) = make_int1(tmp.x); 
# 3575
} 
#endif
# 3577 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3578
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3590
::exit(___);}
#if 0
# 3578
{ 
# 3579
unsigned tmp; 
# 3580
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3581
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3582
} else { 
# 3583
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3584
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3585
} else { 
# 3586
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3587
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3588
}  }  }  
# 3589
(*retVal) = ((unsigned)tmp); 
# 3590
} 
#endif
# 3592 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3593
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3605
::exit(___);}
#if 0
# 3593
{ 
# 3594
uint1 tmp; 
# 3595
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3596
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3597
} else { 
# 3598
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3599
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3600
} else { 
# 3601
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3602
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3603
}  }  }  
# 3604
(*retVal) = make_uint1(tmp.x); 
# 3605
} 
#endif
# 3607 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3608
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3620
::exit(___);}
#if 0
# 3608
{ 
# 3609
long long tmp; 
# 3610
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3611
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3612
} else { 
# 3613
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3614
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3615
} else { 
# 3616
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3617
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3618
}  }  }  
# 3619
(*retVal) = ((long long)tmp); 
# 3620
} 
#endif
# 3622 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3623
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3635
::exit(___);}
#if 0
# 3623
{ 
# 3624
longlong1 tmp; 
# 3625
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3626
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3627
} else { 
# 3628
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3629
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3630
} else { 
# 3631
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3632
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3633
}  }  }  
# 3634
(*retVal) = make_longlong1(tmp.x); 
# 3635
} 
#endif
# 3637 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3638
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3650
::exit(___);}
#if 0
# 3638
{ 
# 3639
unsigned long long tmp; 
# 3640
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3641
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3642
} else { 
# 3643
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3644
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3645
} else { 
# 3646
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3647
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3648
}  }  }  
# 3649
(*retVal) = ((unsigned long long)tmp); 
# 3650
} 
#endif
# 3652 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3653
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3665
::exit(___);}
#if 0
# 3653
{ 
# 3654
ulonglong1 tmp; 
# 3655
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3656
__asm__ volatile("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3657
} else { 
# 3658
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3659
__asm__ volatile("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3660
} else { 
# 3661
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3662
__asm__ volatile("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3663
}  }  }  
# 3664
(*retVal) = make_ulonglong1(tmp.x); 
# 3665
} 
#endif
# 3667 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3668
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3680
::exit(___);}
#if 0
# 3668
{ 
# 3669
float tmp; 
# 3670
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3671
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3672
} else { 
# 3673
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3674
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3675
} else { 
# 3676
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3677
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3678
}  }  }  
# 3679
(*retVal) = ((float)tmp); 
# 3680
} 
#endif
# 3682 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3683
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3695
::exit(___);}
#if 0
# 3683
{ 
# 3684
float1 tmp; 
# 3685
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3686
__asm__ volatile("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3687
} else { 
# 3688
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3689
__asm__ volatile("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3690
} else { 
# 3691
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3692
__asm__ volatile("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f" (tmp.x) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3693
}  }  }  
# 3694
(*retVal) = make_float1(tmp.x); 
# 3695
} 
#endif
# 3703 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3704
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3716
::exit(___);}
#if 0
# 3704
{ 
# 3705
int2 tmp; 
# 3706
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3707
__asm__ volatile("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3708
} else { 
# 3709
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3710
__asm__ volatile("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3711
} else { 
# 3712
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3713
__asm__ volatile("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3714
}  }  }  
# 3715
(*retVal) = make_char2(tmp.x, tmp.y); 
# 3716
} 
#endif
# 3718 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3719
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3731
::exit(___);}
#if 0
# 3719
{ 
# 3720
uint2 tmp; 
# 3721
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3722
__asm__ volatile("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3723
} else { 
# 3724
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3725
__asm__ volatile("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3726
} else { 
# 3727
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3728
__asm__ volatile("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3729
}  }  }  
# 3730
(*retVal) = make_uchar2(tmp.x, tmp.y); 
# 3731
} 
#endif
# 3733 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3734
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3746
::exit(___);}
#if 0
# 3734
{ 
# 3735
short2 tmp; 
# 3736
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3737
__asm__ volatile("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3738
} else { 
# 3739
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3740
__asm__ volatile("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3741
} else { 
# 3742
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3743
__asm__ volatile("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3744
}  }  }  
# 3745
(*retVal) = make_short2(tmp.x, tmp.y); 
# 3746
} 
#endif
# 3748 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3749
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3761
::exit(___);}
#if 0
# 3749
{ 
# 3750
ushort2 tmp; 
# 3751
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3752
__asm__ volatile("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3753
} else { 
# 3754
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3755
__asm__ volatile("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3756
} else { 
# 3757
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3758
__asm__ volatile("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h" (tmp.x), "=h" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3759
}  }  }  
# 3760
(*retVal) = make_ushort2(tmp.x, tmp.y); 
# 3761
} 
#endif
# 3763 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3764
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3776
::exit(___);}
#if 0
# 3764
{ 
# 3765
int2 tmp; 
# 3766
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3767
__asm__ volatile("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3768
} else { 
# 3769
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3770
__asm__ volatile("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3771
} else { 
# 3772
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3773
__asm__ volatile("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3774
}  }  }  
# 3775
(*retVal) = make_int2(tmp.x, tmp.y); 
# 3776
} 
#endif
# 3778 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3779
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3791
::exit(___);}
#if 0
# 3779
{ 
# 3780
uint2 tmp; 
# 3781
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3782
__asm__ volatile("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3783
} else { 
# 3784
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3785
__asm__ volatile("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3786
} else { 
# 3787
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3788
__asm__ volatile("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r" (tmp.x), "=r" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3789
}  }  }  
# 3790
(*retVal) = make_uint2(tmp.x, tmp.y); 
# 3791
} 
#endif
# 3793 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3794
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3806
::exit(___);}
#if 0
# 3794
{ 
# 3795
longlong2 tmp; 
# 3796
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3797
__asm__ volatile("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3798
} else { 
# 3799
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3800
__asm__ volatile("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3801
} else { 
# 3802
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3803
__asm__ volatile("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3804
}  }  }  
# 3805
(*retVal) = make_longlong2(tmp.x, tmp.y); 
# 3806
} 
#endif
# 3808 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3809
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3821
::exit(___);}
#if 0
# 3809
{ 
# 3810
ulonglong2 tmp; 
# 3811
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3812
__asm__ volatile("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3813
} else { 
# 3814
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3815
__asm__ volatile("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3816
} else { 
# 3817
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3818
__asm__ volatile("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l" (tmp.x), "=l" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3819
}  }  }  
# 3820
(*retVal) = make_ulonglong2(tmp.x, tmp.y); 
# 3821
} 
#endif
# 3823 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3824
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3836
::exit(___);}
#if 0
# 3824
{ 
# 3825
float2 tmp; 
# 3826
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3827
__asm__ volatile("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3828
} else { 
# 3829
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3830
__asm__ volatile("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3831
} else { 
# 3832
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3833
__asm__ volatile("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f" (tmp.x), "=f" (tmp.y) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3834
}  }  }  
# 3835
(*retVal) = make_float2(tmp.x, tmp.y); 
# 3836
} 
#endif
# 3844 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3845
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3857
::exit(___);}
#if 0
# 3845
{ 
# 3846
int4 tmp; 
# 3847
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3848
__asm__ volatile("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3849
} else { 
# 3850
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3851
__asm__ volatile("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3852
} else { 
# 3853
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3854
__asm__ volatile("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3855
}  }  }  
# 3856
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3857
} 
#endif
# 3859 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3860
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3872
::exit(___);}
#if 0
# 3860
{ 
# 3861
uint4 tmp; 
# 3862
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3863
__asm__ volatile("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3864
} else { 
# 3865
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3866
__asm__ volatile("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3867
} else { 
# 3868
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3869
__asm__ volatile("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3870
}  }  }  
# 3871
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3872
} 
#endif
# 3874 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3875
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3887
::exit(___);}
#if 0
# 3875
{ 
# 3876
short4 tmp; 
# 3877
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3878
__asm__ volatile("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3879
} else { 
# 3880
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3881
__asm__ volatile("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3882
} else { 
# 3883
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3884
__asm__ volatile("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3885
}  }  }  
# 3886
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3887
} 
#endif
# 3889 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3890
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3902
::exit(___);}
#if 0
# 3890
{ 
# 3891
ushort4 tmp; 
# 3892
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3893
__asm__ volatile("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3894
} else { 
# 3895
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3896
__asm__ volatile("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3897
} else { 
# 3898
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3899
__asm__ volatile("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h" (tmp.x), "=h" (tmp.y), "=h" (tmp.z), "=h" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3900
}  }  }  
# 3901
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3902
} 
#endif
# 3904 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3905
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3917
::exit(___);}
#if 0
# 3905
{ 
# 3906
int4 tmp; 
# 3907
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3908
__asm__ volatile("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3909
} else { 
# 3910
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3911
__asm__ volatile("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3912
} else { 
# 3913
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3914
__asm__ volatile("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3915
}  }  }  
# 3916
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3917
} 
#endif
# 3919 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3920
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3932
::exit(___);}
#if 0
# 3920
{ 
# 3921
uint4 tmp; 
# 3922
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3923
__asm__ volatile("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3924
} else { 
# 3925
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3926
__asm__ volatile("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3927
} else { 
# 3928
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3929
__asm__ volatile("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r" (tmp.x), "=r" (tmp.y), "=r" (tmp.z), "=r" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3930
}  }  }  
# 3931
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3932
} 
#endif
# 3934 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3935
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3947
::exit(___);}
#if 0
# 3935
{ 
# 3936
float4 tmp; 
# 3937
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3938
__asm__ volatile("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3939
} else { 
# 3940
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3941
__asm__ volatile("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3942
} else { 
# 3943
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3944
__asm__ volatile("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f" (tmp.x), "=f" (tmp.y), "=f" (tmp.z), "=f" (tmp.w) : "l" (surfObject), "r" (layerface), "r" (x), "r" (y)); 
# 3945
}  }  }  
# 3946
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
# 3947
} 
#endif
# 3955 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
template< class T> 
# 3956
__attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3957
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 3961
::exit(___);}
#if 0
# 3957
{ 
# 3958
T ret; 
# 3959
surfCubemapLayeredread(&ret, surfObject, x, y, z, layerface, boundaryMode); 
# 3960
return ret; 
# 3961
} 
#endif
# 3969 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3970
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 3980
::exit(___);}
#if 0
# 3970
{ 
# 3971
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3972
__asm__ volatile("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((int)data)); 
# 3973
} else { 
# 3974
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3975
__asm__ volatile("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((int)data)); 
# 3976
} else { 
# 3977
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3978
__asm__ volatile("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((int)data)); 
# 3979
}  }  }  
# 3980
} 
#endif
# 3982 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3983
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 3993
::exit(___);}
#if 0
# 3983
{ 
# 3984
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3985
__asm__ volatile("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((int)data)); 
# 3986
} else { 
# 3987
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 3988
__asm__ volatile("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((int)data)); 
# 3989
} else { 
# 3990
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 3991
__asm__ volatile("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((int)data)); 
# 3992
}  }  }  
# 3993
} 
#endif
# 3995 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 3996
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4006
::exit(___);}
#if 0
# 3996
{ 
# 3997
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 3998
__asm__ volatile("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((int)(data.x))); 
# 3999
} else { 
# 4000
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4001
__asm__ volatile("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((int)(data.x))); 
# 4002
} else { 
# 4003
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4004
__asm__ volatile("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((int)(data.x))); 
# 4005
}  }  }  
# 4006
} 
#endif
# 4008 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4009
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4019
::exit(___);}
#if 0
# 4009
{ 
# 4010
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4011
__asm__ volatile("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((unsigned)data)); 
# 4012
} else { 
# 4013
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4014
__asm__ volatile("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((unsigned)data)); 
# 4015
} else { 
# 4016
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4017
__asm__ volatile("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((unsigned)data)); 
# 4018
}  }  }  
# 4019
} 
#endif
# 4021 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4022
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4032
::exit(___);}
#if 0
# 4022
{ 
# 4023
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4024
__asm__ volatile("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((unsigned)(data.x))); 
# 4025
} else { 
# 4026
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4027
__asm__ volatile("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((unsigned)(data.x))); 
# 4028
} else { 
# 4029
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4030
__asm__ volatile("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" ((unsigned)(data.x))); 
# 4031
}  }  }  
# 4032
} 
#endif
# 4034 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4035
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4045
::exit(___);}
#if 0
# 4035
{ 
# 4036
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4037
__asm__ volatile("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data)); 
# 4038
} else { 
# 4039
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4040
__asm__ volatile("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data)); 
# 4041
} else { 
# 4042
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4043
__asm__ volatile("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data)); 
# 4044
}  }  }  
# 4045
} 
#endif
# 4047 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4048
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4058
::exit(___);}
#if 0
# 4048
{ 
# 4049
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4050
__asm__ volatile("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data.x)); 
# 4051
} else { 
# 4052
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4053
__asm__ volatile("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data.x)); 
# 4054
} else { 
# 4055
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4056
__asm__ volatile("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data.x)); 
# 4057
}  }  }  
# 4058
} 
#endif
# 4060 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4061
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4071
::exit(___);}
#if 0
# 4061
{ 
# 4062
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4063
__asm__ volatile("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data)); 
# 4064
} else { 
# 4065
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4066
__asm__ volatile("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data)); 
# 4067
} else { 
# 4068
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4069
__asm__ volatile("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data)); 
# 4070
}  }  }  
# 4071
} 
#endif
# 4073 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4074
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4084
::exit(___);}
#if 0
# 4074
{ 
# 4075
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4076
__asm__ volatile("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data.x)); 
# 4077
} else { 
# 4078
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4079
__asm__ volatile("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data.x)); 
# 4080
} else { 
# 4081
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4082
__asm__ volatile("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "h" (data.x)); 
# 4083
}  }  }  
# 4084
} 
#endif
# 4086 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4087
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4097
::exit(___);}
#if 0
# 4087
{ 
# 4088
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4089
__asm__ volatile("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data)); 
# 4090
} else { 
# 4091
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4092
__asm__ volatile("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data)); 
# 4093
} else { 
# 4094
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4095
__asm__ volatile("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data)); 
# 4096
}  }  }  
# 4097
} 
#endif
# 4099 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4100
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4110
::exit(___);}
#if 0
# 4100
{ 
# 4101
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4102
__asm__ volatile("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data.x)); 
# 4103
} else { 
# 4104
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4105
__asm__ volatile("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data.x)); 
# 4106
} else { 
# 4107
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4108
__asm__ volatile("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data.x)); 
# 4109
}  }  }  
# 4110
} 
#endif
# 4112 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4113
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4123
::exit(___);}
#if 0
# 4113
{ 
# 4114
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4115
__asm__ volatile("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data)); 
# 4116
} else { 
# 4117
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4118
__asm__ volatile("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data)); 
# 4119
} else { 
# 4120
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4121
__asm__ volatile("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data)); 
# 4122
}  }  }  
# 4123
} 
#endif
# 4125 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4126
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4136
::exit(___);}
#if 0
# 4126
{ 
# 4127
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4128
__asm__ volatile("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data.x)); 
# 4129
} else { 
# 4130
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4131
__asm__ volatile("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data.x)); 
# 4132
} else { 
# 4133
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4134
__asm__ volatile("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "r" (data.x)); 
# 4135
}  }  }  
# 4136
} 
#endif
# 4138 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4139
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4149
::exit(___);}
#if 0
# 4139
{ 
# 4140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4141
__asm__ volatile("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data)); 
# 4142
} else { 
# 4143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4144
__asm__ volatile("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data)); 
# 4145
} else { 
# 4146
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4147
__asm__ volatile("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data)); 
# 4148
}  }  }  
# 4149
} 
#endif
# 4151 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4152
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4162
::exit(___);}
#if 0
# 4152
{ 
# 4153
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4154
__asm__ volatile("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data.x)); 
# 4155
} else { 
# 4156
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4157
__asm__ volatile("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data.x)); 
# 4158
} else { 
# 4159
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4160
__asm__ volatile("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data.x)); 
# 4161
}  }  }  
# 4162
} 
#endif
# 4164 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4165
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4175
::exit(___);}
#if 0
# 4165
{ 
# 4166
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4167
__asm__ volatile("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data)); 
# 4168
} else { 
# 4169
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4170
__asm__ volatile("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data)); 
# 4171
} else { 
# 4172
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4173
__asm__ volatile("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data)); 
# 4174
}  }  }  
# 4175
} 
#endif
# 4177 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4178
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4188
::exit(___);}
#if 0
# 4178
{ 
# 4179
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4180
__asm__ volatile("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data.x)); 
# 4181
} else { 
# 4182
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4183
__asm__ volatile("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data.x)); 
# 4184
} else { 
# 4185
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4186
__asm__ volatile("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "l" (data.x)); 
# 4187
}  }  }  
# 4188
} 
#endif
# 4190 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4191
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4201
::exit(___);}
#if 0
# 4191
{ 
# 4192
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4193
__asm__ volatile("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "f" (data)); 
# 4194
} else { 
# 4195
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4196
__asm__ volatile("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "f" (data)); 
# 4197
} else { 
# 4198
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4199
__asm__ volatile("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "f" (data)); 
# 4200
}  }  }  
# 4201
} 
#endif
# 4203 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4204
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4214
::exit(___);}
#if 0
# 4204
{ 
# 4205
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4206
__asm__ volatile("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "f" (data.x)); 
# 4207
} else { 
# 4208
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4209
__asm__ volatile("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "f" (data.x)); 
# 4210
} else { 
# 4211
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4212
__asm__ volatile("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l" (surfObject), "r" (x), "f" (data.x)); 
# 4213
}  }  }  
# 4214
} 
#endif
# 4222 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4223
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4233
::exit(___);}
#if 0
# 4223
{ 
# 4224
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4225
__asm__ volatile("sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 4226
} else { 
# 4227
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4228
__asm__ volatile("sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 4229
} else { 
# 4230
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4231
__asm__ volatile("sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 4232
}  }  }  
# 4233
} 
#endif
# 4235 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4236
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4246
::exit(___);}
#if 0
# 4236
{ 
# 4237
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4238
__asm__ volatile("sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 4239
} else { 
# 4240
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4241
__asm__ volatile("sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 4242
} else { 
# 4243
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4244
__asm__ volatile("sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 4245
}  }  }  
# 4246
} 
#endif
# 4248 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4249
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4259
::exit(___);}
#if 0
# 4249
{ 
# 4250
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4251
__asm__ volatile("sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y)); 
# 4252
} else { 
# 4253
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4254
__asm__ volatile("sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y)); 
# 4255
} else { 
# 4256
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4257
__asm__ volatile("sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y)); 
# 4258
}  }  }  
# 4259
} 
#endif
# 4261 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4262
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4272
::exit(___);}
#if 0
# 4262
{ 
# 4263
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4264
__asm__ volatile("sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y)); 
# 4265
} else { 
# 4266
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4267
__asm__ volatile("sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y)); 
# 4268
} else { 
# 4269
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4270
__asm__ volatile("sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y)); 
# 4271
}  }  }  
# 4272
} 
#endif
# 4274 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4275
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4285
::exit(___);}
#if 0
# 4275
{ 
# 4276
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4277
__asm__ volatile("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y)); 
# 4278
} else { 
# 4279
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4280
__asm__ volatile("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y)); 
# 4281
} else { 
# 4282
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4283
__asm__ volatile("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y)); 
# 4284
}  }  }  
# 4285
} 
#endif
# 4287 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4288
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4298
::exit(___);}
#if 0
# 4288
{ 
# 4289
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4290
__asm__ volatile("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y)); 
# 4291
} else { 
# 4292
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4293
__asm__ volatile("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y)); 
# 4294
} else { 
# 4295
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4296
__asm__ volatile("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y)); 
# 4297
}  }  }  
# 4298
} 
#endif
# 4300 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4301
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4311
::exit(___);}
#if 0
# 4301
{ 
# 4302
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4303
__asm__ volatile("sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "l" (data.x), "l" (data.y)); 
# 4304
} else { 
# 4305
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4306
__asm__ volatile("sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "l" (data.x), "l" (data.y)); 
# 4307
} else { 
# 4308
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4309
__asm__ volatile("sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "l" (data.x), "l" (data.y)); 
# 4310
}  }  }  
# 4311
} 
#endif
# 4313 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4314
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4324
::exit(___);}
#if 0
# 4314
{ 
# 4315
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4316
__asm__ volatile("sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "l" (data.x), "l" (data.y)); 
# 4317
} else { 
# 4318
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4319
__asm__ volatile("sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "l" (data.x), "l" (data.y)); 
# 4320
} else { 
# 4321
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4322
__asm__ volatile("sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "l" (data.x), "l" (data.y)); 
# 4323
}  }  }  
# 4324
} 
#endif
# 4326 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4327
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4337
::exit(___);}
#if 0
# 4327
{ 
# 4328
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4329
__asm__ volatile("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "f" (data.x), "f" (data.y)); 
# 4330
} else { 
# 4331
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4332
__asm__ volatile("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "f" (data.x), "f" (data.y)); 
# 4333
} else { 
# 4334
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4335
__asm__ volatile("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l" (surfObject), "r" (x), "f" (data.x), "f" (data.y)); 
# 4336
}  }  }  
# 4337
} 
#endif
# 4345 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4346
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4356
::exit(___);}
#if 0
# 4346
{ 
# 4347
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4348
__asm__ volatile("sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 4349
} else { 
# 4350
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4351
__asm__ volatile("sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 4352
} else { 
# 4353
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4354
__asm__ volatile("sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 4355
}  }  }  
# 4356
} 
#endif
# 4358 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4359
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4369
::exit(___);}
#if 0
# 4359
{ 
# 4360
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4361
__asm__ volatile("sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 4362
} else { 
# 4363
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4364
__asm__ volatile("sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 4365
} else { 
# 4366
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4367
__asm__ volatile("sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 4368
}  }  }  
# 4369
} 
#endif
# 4371 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4372
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4382
::exit(___);}
#if 0
# 4372
{ 
# 4373
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4374
__asm__ volatile("sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4375
} else { 
# 4376
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4377
__asm__ volatile("sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4378
} else { 
# 4379
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4380
__asm__ volatile("sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4381
}  }  }  
# 4382
} 
#endif
# 4384 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4385
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4395
::exit(___);}
#if 0
# 4385
{ 
# 4386
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4387
__asm__ volatile("sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4388
} else { 
# 4389
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4390
__asm__ volatile("sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4391
} else { 
# 4392
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4393
__asm__ volatile("sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4394
}  }  }  
# 4395
} 
#endif
# 4397 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4398
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4408
::exit(___);}
#if 0
# 4398
{ 
# 4399
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4400
__asm__ volatile("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4401
} else { 
# 4402
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4403
__asm__ volatile("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4404
} else { 
# 4405
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4406
__asm__ volatile("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4407
}  }  }  
# 4408
} 
#endif
# 4410 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4411
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4421
::exit(___);}
#if 0
# 4411
{ 
# 4412
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4413
__asm__ volatile("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4414
} else { 
# 4415
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4416
__asm__ volatile("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4417
} else { 
# 4418
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4419
__asm__ volatile("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4420
}  }  }  
# 4421
} 
#endif
# 4423 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4424
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
# 4434
::exit(___);}
#if 0
# 4424
{ 
# 4425
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4426
__asm__ volatile("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 4427
} else { 
# 4428
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4429
__asm__ volatile("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 4430
} else { 
# 4431
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4432
__asm__ volatile("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l" (surfObject), "r" (x), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 4433
}  }  }  
# 4434
} 
#endif
# 4442 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4443
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4453
::exit(___);}
#if 0
# 4443
{ 
# 4444
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4445
__asm__ volatile("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)data)); 
# 4446
} else { 
# 4447
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4448
__asm__ volatile("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)data)); 
# 4449
} else { 
# 4450
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4451
__asm__ volatile("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)data)); 
# 4452
}  }  }  
# 4453
} 
#endif
# 4455 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4456
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4466
::exit(___);}
#if 0
# 4456
{ 
# 4457
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4458
__asm__ volatile("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)data)); 
# 4459
} else { 
# 4460
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4461
__asm__ volatile("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)data)); 
# 4462
} else { 
# 4463
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4464
__asm__ volatile("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)data)); 
# 4465
}  }  }  
# 4466
} 
#endif
# 4468 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4469
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4479
::exit(___);}
#if 0
# 4469
{ 
# 4470
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4471
__asm__ volatile("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 4472
} else { 
# 4473
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4474
__asm__ volatile("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 4475
} else { 
# 4476
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4477
__asm__ volatile("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 4478
}  }  }  
# 4479
} 
#endif
# 4481 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4482
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4492
::exit(___);}
#if 0
# 4482
{ 
# 4483
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4484
__asm__ volatile("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 4485
} else { 
# 4486
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4487
__asm__ volatile("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 4488
} else { 
# 4489
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4490
__asm__ volatile("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 4491
}  }  }  
# 4492
} 
#endif
# 4494 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4495
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4505
::exit(___);}
#if 0
# 4495
{ 
# 4496
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4497
__asm__ volatile("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 4498
} else { 
# 4499
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4500
__asm__ volatile("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 4501
} else { 
# 4502
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4503
__asm__ volatile("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 4504
}  }  }  
# 4505
} 
#endif
# 4507 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4508
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4518
::exit(___);}
#if 0
# 4508
{ 
# 4509
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4510
__asm__ volatile("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data)); 
# 4511
} else { 
# 4512
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4513
__asm__ volatile("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data)); 
# 4514
} else { 
# 4515
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4516
__asm__ volatile("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data)); 
# 4517
}  }  }  
# 4518
} 
#endif
# 4520 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4521
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4531
::exit(___);}
#if 0
# 4521
{ 
# 4522
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4523
__asm__ volatile("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x)); 
# 4524
} else { 
# 4525
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4526
__asm__ volatile("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x)); 
# 4527
} else { 
# 4528
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4529
__asm__ volatile("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x)); 
# 4530
}  }  }  
# 4531
} 
#endif
# 4533 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4534
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4544
::exit(___);}
#if 0
# 4534
{ 
# 4535
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4536
__asm__ volatile("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data)); 
# 4537
} else { 
# 4538
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4539
__asm__ volatile("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data)); 
# 4540
} else { 
# 4541
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4542
__asm__ volatile("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data)); 
# 4543
}  }  }  
# 4544
} 
#endif
# 4546 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4547
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4557
::exit(___);}
#if 0
# 4547
{ 
# 4548
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4549
__asm__ volatile("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x)); 
# 4550
} else { 
# 4551
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4552
__asm__ volatile("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x)); 
# 4553
} else { 
# 4554
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4555
__asm__ volatile("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x)); 
# 4556
}  }  }  
# 4557
} 
#endif
# 4559 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4560
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4570
::exit(___);}
#if 0
# 4560
{ 
# 4561
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4562
__asm__ volatile("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data)); 
# 4563
} else { 
# 4564
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4565
__asm__ volatile("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data)); 
# 4566
} else { 
# 4567
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4568
__asm__ volatile("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data)); 
# 4569
}  }  }  
# 4570
} 
#endif
# 4572 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4573
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4583
::exit(___);}
#if 0
# 4573
{ 
# 4574
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4575
__asm__ volatile("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x)); 
# 4576
} else { 
# 4577
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4578
__asm__ volatile("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x)); 
# 4579
} else { 
# 4580
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4581
__asm__ volatile("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x)); 
# 4582
}  }  }  
# 4583
} 
#endif
# 4585 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4586
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4596
::exit(___);}
#if 0
# 4586
{ 
# 4587
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4588
__asm__ volatile("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data)); 
# 4589
} else { 
# 4590
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4591
__asm__ volatile("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data)); 
# 4592
} else { 
# 4593
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4594
__asm__ volatile("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data)); 
# 4595
}  }  }  
# 4596
} 
#endif
# 4598 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4599
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4609
::exit(___);}
#if 0
# 4599
{ 
# 4600
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4601
__asm__ volatile("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x)); 
# 4602
} else { 
# 4603
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4604
__asm__ volatile("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x)); 
# 4605
} else { 
# 4606
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4607
__asm__ volatile("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x)); 
# 4608
}  }  }  
# 4609
} 
#endif
# 4611 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4612
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4622
::exit(___);}
#if 0
# 4612
{ 
# 4613
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4614
__asm__ volatile("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data)); 
# 4615
} else { 
# 4616
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4617
__asm__ volatile("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data)); 
# 4618
} else { 
# 4619
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4620
__asm__ volatile("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data)); 
# 4621
}  }  }  
# 4622
} 
#endif
# 4624 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4625
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4635
::exit(___);}
#if 0
# 4625
{ 
# 4626
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4627
__asm__ volatile("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x)); 
# 4628
} else { 
# 4629
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4630
__asm__ volatile("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x)); 
# 4631
} else { 
# 4632
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4633
__asm__ volatile("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x)); 
# 4634
}  }  }  
# 4635
} 
#endif
# 4637 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4638
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4648
::exit(___);}
#if 0
# 4638
{ 
# 4639
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4640
__asm__ volatile("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data)); 
# 4641
} else { 
# 4642
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4643
__asm__ volatile("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data)); 
# 4644
} else { 
# 4645
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4646
__asm__ volatile("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data)); 
# 4647
}  }  }  
# 4648
} 
#endif
# 4650 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4651
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4661
::exit(___);}
#if 0
# 4651
{ 
# 4652
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4653
__asm__ volatile("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x)); 
# 4654
} else { 
# 4655
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4656
__asm__ volatile("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x)); 
# 4657
} else { 
# 4658
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4659
__asm__ volatile("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x)); 
# 4660
}  }  }  
# 4661
} 
#endif
# 4663 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4664
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4674
::exit(___);}
#if 0
# 4664
{ 
# 4665
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4666
__asm__ volatile("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data)); 
# 4667
} else { 
# 4668
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4669
__asm__ volatile("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data)); 
# 4670
} else { 
# 4671
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4672
__asm__ volatile("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data)); 
# 4673
}  }  }  
# 4674
} 
#endif
# 4676 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4677
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4687
::exit(___);}
#if 0
# 4677
{ 
# 4678
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4679
__asm__ volatile("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data.x)); 
# 4680
} else { 
# 4681
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4682
__asm__ volatile("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data.x)); 
# 4683
} else { 
# 4684
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4685
__asm__ volatile("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data.x)); 
# 4686
}  }  }  
# 4687
} 
#endif
# 4695 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4696
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4706
::exit(___);}
#if 0
# 4696
{ 
# 4697
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4698
__asm__ volatile("sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 4699
} else { 
# 4700
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4701
__asm__ volatile("sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 4702
} else { 
# 4703
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4704
__asm__ volatile("sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 4705
}  }  }  
# 4706
} 
#endif
# 4708 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4709
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4719
::exit(___);}
#if 0
# 4709
{ 
# 4710
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4711
__asm__ volatile("sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 4712
} else { 
# 4713
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4714
__asm__ volatile("sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 4715
} else { 
# 4716
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4717
__asm__ volatile("sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 4718
}  }  }  
# 4719
} 
#endif
# 4721 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4722
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4732
::exit(___);}
#if 0
# 4722
{ 
# 4723
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4724
__asm__ volatile("sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 4725
} else { 
# 4726
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4727
__asm__ volatile("sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 4728
} else { 
# 4729
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4730
__asm__ volatile("sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 4731
}  }  }  
# 4732
} 
#endif
# 4734 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4735
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4745
::exit(___);}
#if 0
# 4735
{ 
# 4736
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4737
__asm__ volatile("sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 4738
} else { 
# 4739
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4740
__asm__ volatile("sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 4741
} else { 
# 4742
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4743
__asm__ volatile("sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 4744
}  }  }  
# 4745
} 
#endif
# 4747 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4748
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4758
::exit(___);}
#if 0
# 4748
{ 
# 4749
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4750
__asm__ volatile("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 4751
} else { 
# 4752
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4753
__asm__ volatile("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 4754
} else { 
# 4755
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4756
__asm__ volatile("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 4757
}  }  }  
# 4758
} 
#endif
# 4760 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4761
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4771
::exit(___);}
#if 0
# 4761
{ 
# 4762
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4763
__asm__ volatile("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 4764
} else { 
# 4765
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4766
__asm__ volatile("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 4767
} else { 
# 4768
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4769
__asm__ volatile("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 4770
}  }  }  
# 4771
} 
#endif
# 4773 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4774
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4784
::exit(___);}
#if 0
# 4774
{ 
# 4775
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4776
__asm__ volatile("sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 4777
} else { 
# 4778
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4779
__asm__ volatile("sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 4780
} else { 
# 4781
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4782
__asm__ volatile("sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 4783
}  }  }  
# 4784
} 
#endif
# 4786 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4787
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4797
::exit(___);}
#if 0
# 4787
{ 
# 4788
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4789
__asm__ volatile("sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 4790
} else { 
# 4791
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4792
__asm__ volatile("sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 4793
} else { 
# 4794
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4795
__asm__ volatile("sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 4796
}  }  }  
# 4797
} 
#endif
# 4799 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4800
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4810
::exit(___);}
#if 0
# 4800
{ 
# 4801
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4802
__asm__ volatile("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 4803
} else { 
# 4804
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4805
__asm__ volatile("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 4806
} else { 
# 4807
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4808
__asm__ volatile("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 4809
}  }  }  
# 4810
} 
#endif
# 4818 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4819
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4829
::exit(___);}
#if 0
# 4819
{ 
# 4820
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4821
__asm__ volatile("sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 4822
} else { 
# 4823
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4824
__asm__ volatile("sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 4825
} else { 
# 4826
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4827
__asm__ volatile("sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 4828
}  }  }  
# 4829
} 
#endif
# 4831 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4832
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4842
::exit(___);}
#if 0
# 4832
{ 
# 4833
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4834
__asm__ volatile("sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 4835
} else { 
# 4836
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4837
__asm__ volatile("sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 4838
} else { 
# 4839
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4840
__asm__ volatile("sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 4841
}  }  }  
# 4842
} 
#endif
# 4844 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4845
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4855
::exit(___);}
#if 0
# 4845
{ 
# 4846
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4847
__asm__ volatile("sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4848
} else { 
# 4849
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4850
__asm__ volatile("sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4851
} else { 
# 4852
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4853
__asm__ volatile("sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4854
}  }  }  
# 4855
} 
#endif
# 4857 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4858
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4868
::exit(___);}
#if 0
# 4858
{ 
# 4859
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4860
__asm__ volatile("sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4861
} else { 
# 4862
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4863
__asm__ volatile("sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4864
} else { 
# 4865
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4866
__asm__ volatile("sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 4867
}  }  }  
# 4868
} 
#endif
# 4870 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4871
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4881
::exit(___);}
#if 0
# 4871
{ 
# 4872
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4873
__asm__ volatile("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4874
} else { 
# 4875
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4876
__asm__ volatile("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4877
} else { 
# 4878
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4879
__asm__ volatile("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4880
}  }  }  
# 4881
} 
#endif
# 4883 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4884
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4894
::exit(___);}
#if 0
# 4884
{ 
# 4885
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4886
__asm__ volatile("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4887
} else { 
# 4888
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4889
__asm__ volatile("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4890
} else { 
# 4891
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4892
__asm__ volatile("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 4893
}  }  }  
# 4894
} 
#endif
# 4896 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4897
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 4907
::exit(___);}
#if 0
# 4897
{ 
# 4898
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4899
__asm__ volatile("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 4900
} else { 
# 4901
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4902
__asm__ volatile("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 4903
} else { 
# 4904
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4905
__asm__ volatile("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 4906
}  }  }  
# 4907
} 
#endif
# 4915 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4916
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4926
::exit(___);}
#if 0
# 4916
{ 
# 4917
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4918
__asm__ volatile("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)data)); 
# 4919
} else { 
# 4920
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4921
__asm__ volatile("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)data)); 
# 4922
} else { 
# 4923
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4924
__asm__ volatile("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)data)); 
# 4925
}  }  }  
# 4926
} 
#endif
# 4928 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4929
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4939
::exit(___);}
#if 0
# 4929
{ 
# 4930
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4931
__asm__ volatile("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)data)); 
# 4932
} else { 
# 4933
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4934
__asm__ volatile("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)data)); 
# 4935
} else { 
# 4936
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4937
__asm__ volatile("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)data)); 
# 4938
}  }  }  
# 4939
} 
#endif
# 4941 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4942
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4952
::exit(___);}
#if 0
# 4942
{ 
# 4943
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4944
__asm__ volatile("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)(data.x))); 
# 4945
} else { 
# 4946
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4947
__asm__ volatile("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)(data.x))); 
# 4948
} else { 
# 4949
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4950
__asm__ volatile("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)(data.x))); 
# 4951
}  }  }  
# 4952
} 
#endif
# 4954 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4955
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4965
::exit(___);}
#if 0
# 4955
{ 
# 4956
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4957
__asm__ volatile("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)data)); 
# 4958
} else { 
# 4959
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4960
__asm__ volatile("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)data)); 
# 4961
} else { 
# 4962
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4963
__asm__ volatile("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)data)); 
# 4964
}  }  }  
# 4965
} 
#endif
# 4967 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4968
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4978
::exit(___);}
#if 0
# 4968
{ 
# 4969
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4970
__asm__ volatile("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)(data.x))); 
# 4971
} else { 
# 4972
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4973
__asm__ volatile("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)(data.x))); 
# 4974
} else { 
# 4975
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4976
__asm__ volatile("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)(data.x))); 
# 4977
}  }  }  
# 4978
} 
#endif
# 4980 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4981
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 4991
::exit(___);}
#if 0
# 4981
{ 
# 4982
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4983
__asm__ volatile("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data)); 
# 4984
} else { 
# 4985
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4986
__asm__ volatile("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data)); 
# 4987
} else { 
# 4988
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 4989
__asm__ volatile("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data)); 
# 4990
}  }  }  
# 4991
} 
#endif
# 4993 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 4994
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5004
::exit(___);}
#if 0
# 4994
{ 
# 4995
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 4996
__asm__ volatile("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x)); 
# 4997
} else { 
# 4998
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 4999
__asm__ volatile("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x)); 
# 5000
} else { 
# 5001
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5002
__asm__ volatile("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x)); 
# 5003
}  }  }  
# 5004
} 
#endif
# 5006 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5007
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5017
::exit(___);}
#if 0
# 5007
{ 
# 5008
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5009
__asm__ volatile("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data)); 
# 5010
} else { 
# 5011
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5012
__asm__ volatile("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data)); 
# 5013
} else { 
# 5014
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5015
__asm__ volatile("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data)); 
# 5016
}  }  }  
# 5017
} 
#endif
# 5019 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5020
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5030
::exit(___);}
#if 0
# 5020
{ 
# 5021
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5022
__asm__ volatile("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x)); 
# 5023
} else { 
# 5024
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5025
__asm__ volatile("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x)); 
# 5026
} else { 
# 5027
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5028
__asm__ volatile("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x)); 
# 5029
}  }  }  
# 5030
} 
#endif
# 5032 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5033
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5043
::exit(___);}
#if 0
# 5033
{ 
# 5034
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5035
__asm__ volatile("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data)); 
# 5036
} else { 
# 5037
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5038
__asm__ volatile("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data)); 
# 5039
} else { 
# 5040
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5041
__asm__ volatile("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data)); 
# 5042
}  }  }  
# 5043
} 
#endif
# 5045 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5046
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5056
::exit(___);}
#if 0
# 5046
{ 
# 5047
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5048
__asm__ volatile("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x)); 
# 5049
} else { 
# 5050
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5051
__asm__ volatile("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x)); 
# 5052
} else { 
# 5053
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5054
__asm__ volatile("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x)); 
# 5055
}  }  }  
# 5056
} 
#endif
# 5058 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5059
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5069
::exit(___);}
#if 0
# 5059
{ 
# 5060
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5061
__asm__ volatile("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data)); 
# 5062
} else { 
# 5063
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5064
__asm__ volatile("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data)); 
# 5065
} else { 
# 5066
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5067
__asm__ volatile("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data)); 
# 5068
}  }  }  
# 5069
} 
#endif
# 5071 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5072
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5082
::exit(___);}
#if 0
# 5072
{ 
# 5073
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5074
__asm__ volatile("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x)); 
# 5075
} else { 
# 5076
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5077
__asm__ volatile("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x)); 
# 5078
} else { 
# 5079
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5080
__asm__ volatile("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x)); 
# 5081
}  }  }  
# 5082
} 
#endif
# 5084 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5085
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5095
::exit(___);}
#if 0
# 5085
{ 
# 5086
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5087
__asm__ volatile("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data)); 
# 5088
} else { 
# 5089
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5090
__asm__ volatile("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data)); 
# 5091
} else { 
# 5092
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5093
__asm__ volatile("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data)); 
# 5094
}  }  }  
# 5095
} 
#endif
# 5097 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5098
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5108
::exit(___);}
#if 0
# 5098
{ 
# 5099
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5100
__asm__ volatile("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x)); 
# 5101
} else { 
# 5102
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5103
__asm__ volatile("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x)); 
# 5104
} else { 
# 5105
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5106
__asm__ volatile("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x)); 
# 5107
}  }  }  
# 5108
} 
#endif
# 5110 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5111
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5121
::exit(___);}
#if 0
# 5111
{ 
# 5112
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5113
__asm__ volatile("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data)); 
# 5114
} else { 
# 5115
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5116
__asm__ volatile("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data)); 
# 5117
} else { 
# 5118
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5119
__asm__ volatile("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data)); 
# 5120
}  }  }  
# 5121
} 
#endif
# 5123 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5124
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5134
::exit(___);}
#if 0
# 5124
{ 
# 5125
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5126
__asm__ volatile("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x)); 
# 5127
} else { 
# 5128
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5129
__asm__ volatile("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x)); 
# 5130
} else { 
# 5131
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5132
__asm__ volatile("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x)); 
# 5133
}  }  }  
# 5134
} 
#endif
# 5136 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5137
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5147
::exit(___);}
#if 0
# 5137
{ 
# 5138
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5139
__asm__ volatile("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data)); 
# 5140
} else { 
# 5141
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5142
__asm__ volatile("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data)); 
# 5143
} else { 
# 5144
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5145
__asm__ volatile("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data)); 
# 5146
}  }  }  
# 5147
} 
#endif
# 5149 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5150
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5160
::exit(___);}
#if 0
# 5150
{ 
# 5151
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5152
__asm__ volatile("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data.x)); 
# 5153
} else { 
# 5154
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5155
__asm__ volatile("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data.x)); 
# 5156
} else { 
# 5157
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5158
__asm__ volatile("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data.x)); 
# 5159
}  }  }  
# 5160
} 
#endif
# 5168 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5169
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5179
::exit(___);}
#if 0
# 5169
{ 
# 5170
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5171
__asm__ volatile("sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 5172
} else { 
# 5173
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5174
__asm__ volatile("sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 5175
} else { 
# 5176
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5177
__asm__ volatile("sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 5178
}  }  }  
# 5179
} 
#endif
# 5181 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5182
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5192
::exit(___);}
#if 0
# 5182
{ 
# 5183
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5184
__asm__ volatile("sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 5185
} else { 
# 5186
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5187
__asm__ volatile("sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 5188
} else { 
# 5189
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5190
__asm__ volatile("sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 5191
}  }  }  
# 5192
} 
#endif
# 5194 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5195
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5205
::exit(___);}
#if 0
# 5195
{ 
# 5196
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5197
__asm__ volatile("sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y)); 
# 5198
} else { 
# 5199
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5200
__asm__ volatile("sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y)); 
# 5201
} else { 
# 5202
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5203
__asm__ volatile("sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y)); 
# 5204
}  }  }  
# 5205
} 
#endif
# 5207 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5208
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5218
::exit(___);}
#if 0
# 5208
{ 
# 5209
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5210
__asm__ volatile("sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y)); 
# 5211
} else { 
# 5212
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5213
__asm__ volatile("sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y)); 
# 5214
} else { 
# 5215
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5216
__asm__ volatile("sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y)); 
# 5217
}  }  }  
# 5218
} 
#endif
# 5220 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5221
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5231
::exit(___);}
#if 0
# 5221
{ 
# 5222
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5223
__asm__ volatile("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y)); 
# 5224
} else { 
# 5225
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5226
__asm__ volatile("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y)); 
# 5227
} else { 
# 5228
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5229
__asm__ volatile("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y)); 
# 5230
}  }  }  
# 5231
} 
#endif
# 5233 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5234
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5244
::exit(___);}
#if 0
# 5234
{ 
# 5235
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5236
__asm__ volatile("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y)); 
# 5237
} else { 
# 5238
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5239
__asm__ volatile("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y)); 
# 5240
} else { 
# 5241
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5242
__asm__ volatile("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y)); 
# 5243
}  }  }  
# 5244
} 
#endif
# 5246 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5247
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5257
::exit(___);}
#if 0
# 5247
{ 
# 5248
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5249
__asm__ volatile("sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x), "l" (data.y)); 
# 5250
} else { 
# 5251
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5252
__asm__ volatile("sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x), "l" (data.y)); 
# 5253
} else { 
# 5254
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5255
__asm__ volatile("sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x), "l" (data.y)); 
# 5256
}  }  }  
# 5257
} 
#endif
# 5259 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5260
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5270
::exit(___);}
#if 0
# 5260
{ 
# 5261
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5262
__asm__ volatile("sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x), "l" (data.y)); 
# 5263
} else { 
# 5264
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5265
__asm__ volatile("sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x), "l" (data.y)); 
# 5266
} else { 
# 5267
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5268
__asm__ volatile("sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "l" (data.x), "l" (data.y)); 
# 5269
}  }  }  
# 5270
} 
#endif
# 5272 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5273
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5283
::exit(___);}
#if 0
# 5273
{ 
# 5274
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5275
__asm__ volatile("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data.x), "f" (data.y)); 
# 5276
} else { 
# 5277
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5278
__asm__ volatile("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data.x), "f" (data.y)); 
# 5279
} else { 
# 5280
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5281
__asm__ volatile("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data.x), "f" (data.y)); 
# 5282
}  }  }  
# 5283
} 
#endif
# 5291 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5292
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5302
::exit(___);}
#if 0
# 5292
{ 
# 5293
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5294
__asm__ volatile("sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 5295
} else { 
# 5296
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5297
__asm__ volatile("sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 5298
} else { 
# 5299
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5300
__asm__ volatile("sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 5301
}  }  }  
# 5302
} 
#endif
# 5304 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5305
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5315
::exit(___);}
#if 0
# 5305
{ 
# 5306
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5307
__asm__ volatile("sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 5308
} else { 
# 5309
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5310
__asm__ volatile("sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 5311
} else { 
# 5312
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5313
__asm__ volatile("sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 5314
}  }  }  
# 5315
} 
#endif
# 5317 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5318
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5328
::exit(___);}
#if 0
# 5318
{ 
# 5319
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5320
__asm__ volatile("sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5321
} else { 
# 5322
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5323
__asm__ volatile("sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5324
} else { 
# 5325
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5326
__asm__ volatile("sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5327
}  }  }  
# 5328
} 
#endif
# 5330 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5331
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5341
::exit(___);}
#if 0
# 5331
{ 
# 5332
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5333
__asm__ volatile("sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5334
} else { 
# 5335
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5336
__asm__ volatile("sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5337
} else { 
# 5338
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5339
__asm__ volatile("sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5340
}  }  }  
# 5341
} 
#endif
# 5343 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5344
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5354
::exit(___);}
#if 0
# 5344
{ 
# 5345
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5346
__asm__ volatile("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5347
} else { 
# 5348
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5349
__asm__ volatile("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5350
} else { 
# 5351
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5352
__asm__ volatile("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5353
}  }  }  
# 5354
} 
#endif
# 5356 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5357
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5367
::exit(___);}
#if 0
# 5357
{ 
# 5358
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5359
__asm__ volatile("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5360
} else { 
# 5361
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5362
__asm__ volatile("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5363
} else { 
# 5364
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5365
__asm__ volatile("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5366
}  }  }  
# 5367
} 
#endif
# 5369 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5370
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 5380
::exit(___);}
#if 0
# 5370
{ 
# 5371
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5372
__asm__ volatile("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 5373
} else { 
# 5374
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5375
__asm__ volatile("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 5376
} else { 
# 5377
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5378
__asm__ volatile("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (x), "r" (y), "r" (z), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 5379
}  }  }  
# 5380
} 
#endif
# 5388 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5389
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5399
::exit(___);}
#if 0
# 5389
{ 
# 5390
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5391
__asm__ volatile("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)data)); 
# 5392
} else { 
# 5393
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5394
__asm__ volatile("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)data)); 
# 5395
} else { 
# 5396
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5397
__asm__ volatile("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)data)); 
# 5398
}  }  }  
# 5399
} 
#endif
# 5401 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5402
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5412
::exit(___);}
#if 0
# 5402
{ 
# 5403
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5404
__asm__ volatile("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)data)); 
# 5405
} else { 
# 5406
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5407
__asm__ volatile("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)data)); 
# 5408
} else { 
# 5409
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5410
__asm__ volatile("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)data)); 
# 5411
}  }  }  
# 5412
} 
#endif
# 5414 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5415
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5425
::exit(___);}
#if 0
# 5415
{ 
# 5416
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5417
__asm__ volatile("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)(data.x))); 
# 5418
} else { 
# 5419
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5420
__asm__ volatile("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)(data.x))); 
# 5421
} else { 
# 5422
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5423
__asm__ volatile("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)(data.x))); 
# 5424
}  }  }  
# 5425
} 
#endif
# 5427 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5428
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5438
::exit(___);}
#if 0
# 5428
{ 
# 5429
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5430
__asm__ volatile("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)data)); 
# 5431
} else { 
# 5432
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5433
__asm__ volatile("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)data)); 
# 5434
} else { 
# 5435
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5436
__asm__ volatile("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)data)); 
# 5437
}  }  }  
# 5438
} 
#endif
# 5440 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5441
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5451
::exit(___);}
#if 0
# 5441
{ 
# 5442
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5443
__asm__ volatile("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)(data.x))); 
# 5444
} else { 
# 5445
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5446
__asm__ volatile("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)(data.x))); 
# 5447
} else { 
# 5448
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5449
__asm__ volatile("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)(data.x))); 
# 5450
}  }  }  
# 5451
} 
#endif
# 5453 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5454
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5464
::exit(___);}
#if 0
# 5454
{ 
# 5455
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5456
__asm__ volatile("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data)); 
# 5457
} else { 
# 5458
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5459
__asm__ volatile("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data)); 
# 5460
} else { 
# 5461
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5462
__asm__ volatile("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data)); 
# 5463
}  }  }  
# 5464
} 
#endif
# 5466 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5467
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5477
::exit(___);}
#if 0
# 5467
{ 
# 5468
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5469
__asm__ volatile("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x)); 
# 5470
} else { 
# 5471
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5472
__asm__ volatile("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x)); 
# 5473
} else { 
# 5474
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5475
__asm__ volatile("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x)); 
# 5476
}  }  }  
# 5477
} 
#endif
# 5479 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5480
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5490
::exit(___);}
#if 0
# 5480
{ 
# 5481
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5482
__asm__ volatile("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data)); 
# 5483
} else { 
# 5484
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5485
__asm__ volatile("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data)); 
# 5486
} else { 
# 5487
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5488
__asm__ volatile("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data)); 
# 5489
}  }  }  
# 5490
} 
#endif
# 5492 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5493
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5503
::exit(___);}
#if 0
# 5493
{ 
# 5494
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5495
__asm__ volatile("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x)); 
# 5496
} else { 
# 5497
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5498
__asm__ volatile("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x)); 
# 5499
} else { 
# 5500
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5501
__asm__ volatile("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x)); 
# 5502
}  }  }  
# 5503
} 
#endif
# 5505 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5506
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5516
::exit(___);}
#if 0
# 5506
{ 
# 5507
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5508
__asm__ volatile("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data)); 
# 5509
} else { 
# 5510
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5511
__asm__ volatile("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data)); 
# 5512
} else { 
# 5513
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5514
__asm__ volatile("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data)); 
# 5515
}  }  }  
# 5516
} 
#endif
# 5518 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5519
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5529
::exit(___);}
#if 0
# 5519
{ 
# 5520
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5521
__asm__ volatile("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x)); 
# 5522
} else { 
# 5523
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5524
__asm__ volatile("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x)); 
# 5525
} else { 
# 5526
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5527
__asm__ volatile("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x)); 
# 5528
}  }  }  
# 5529
} 
#endif
# 5531 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5532
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5542
::exit(___);}
#if 0
# 5532
{ 
# 5533
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5534
__asm__ volatile("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data)); 
# 5535
} else { 
# 5536
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5537
__asm__ volatile("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data)); 
# 5538
} else { 
# 5539
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5540
__asm__ volatile("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data)); 
# 5541
}  }  }  
# 5542
} 
#endif
# 5544 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5545
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5555
::exit(___);}
#if 0
# 5545
{ 
# 5546
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5547
__asm__ volatile("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x)); 
# 5548
} else { 
# 5549
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5550
__asm__ volatile("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x)); 
# 5551
} else { 
# 5552
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5553
__asm__ volatile("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x)); 
# 5554
}  }  }  
# 5555
} 
#endif
# 5557 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5558
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5568
::exit(___);}
#if 0
# 5558
{ 
# 5559
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5560
__asm__ volatile("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data)); 
# 5561
} else { 
# 5562
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5563
__asm__ volatile("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data)); 
# 5564
} else { 
# 5565
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5566
__asm__ volatile("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data)); 
# 5567
}  }  }  
# 5568
} 
#endif
# 5570 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5571
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5581
::exit(___);}
#if 0
# 5571
{ 
# 5572
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5573
__asm__ volatile("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x)); 
# 5574
} else { 
# 5575
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5576
__asm__ volatile("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x)); 
# 5577
} else { 
# 5578
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5579
__asm__ volatile("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x)); 
# 5580
}  }  }  
# 5581
} 
#endif
# 5583 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5584
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5594
::exit(___);}
#if 0
# 5584
{ 
# 5585
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5586
__asm__ volatile("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data)); 
# 5587
} else { 
# 5588
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5589
__asm__ volatile("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data)); 
# 5590
} else { 
# 5591
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5592
__asm__ volatile("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data)); 
# 5593
}  }  }  
# 5594
} 
#endif
# 5596 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5597
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5607
::exit(___);}
#if 0
# 5597
{ 
# 5598
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5599
__asm__ volatile("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x)); 
# 5600
} else { 
# 5601
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5602
__asm__ volatile("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x)); 
# 5603
} else { 
# 5604
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5605
__asm__ volatile("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x)); 
# 5606
}  }  }  
# 5607
} 
#endif
# 5609 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5610
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5620
::exit(___);}
#if 0
# 5610
{ 
# 5611
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5612
__asm__ volatile("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data)); 
# 5613
} else { 
# 5614
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5615
__asm__ volatile("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data)); 
# 5616
} else { 
# 5617
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5618
__asm__ volatile("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data)); 
# 5619
}  }  }  
# 5620
} 
#endif
# 5622 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5623
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5633
::exit(___);}
#if 0
# 5623
{ 
# 5624
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5625
__asm__ volatile("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data.x)); 
# 5626
} else { 
# 5627
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5628
__asm__ volatile("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data.x)); 
# 5629
} else { 
# 5630
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5631
__asm__ volatile("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data.x)); 
# 5632
}  }  }  
# 5633
} 
#endif
# 5641 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5642
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5652
::exit(___);}
#if 0
# 5642
{ 
# 5643
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5644
__asm__ volatile("sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 5645
} else { 
# 5646
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5647
__asm__ volatile("sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 5648
} else { 
# 5649
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5650
__asm__ volatile("sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 5651
}  }  }  
# 5652
} 
#endif
# 5654 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5655
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5665
::exit(___);}
#if 0
# 5655
{ 
# 5656
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5657
__asm__ volatile("sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 5658
} else { 
# 5659
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5660
__asm__ volatile("sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 5661
} else { 
# 5662
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5663
__asm__ volatile("sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 5664
}  }  }  
# 5665
} 
#endif
# 5667 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5668
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5678
::exit(___);}
#if 0
# 5668
{ 
# 5669
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5670
__asm__ volatile("sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y)); 
# 5671
} else { 
# 5672
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5673
__asm__ volatile("sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y)); 
# 5674
} else { 
# 5675
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5676
__asm__ volatile("sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y)); 
# 5677
}  }  }  
# 5678
} 
#endif
# 5680 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5681
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5691
::exit(___);}
#if 0
# 5681
{ 
# 5682
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5683
__asm__ volatile("sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y)); 
# 5684
} else { 
# 5685
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5686
__asm__ volatile("sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y)); 
# 5687
} else { 
# 5688
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5689
__asm__ volatile("sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y)); 
# 5690
}  }  }  
# 5691
} 
#endif
# 5693 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5694
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5704
::exit(___);}
#if 0
# 5694
{ 
# 5695
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5696
__asm__ volatile("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y)); 
# 5697
} else { 
# 5698
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5699
__asm__ volatile("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y)); 
# 5700
} else { 
# 5701
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5702
__asm__ volatile("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y)); 
# 5703
}  }  }  
# 5704
} 
#endif
# 5706 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5707
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5717
::exit(___);}
#if 0
# 5707
{ 
# 5708
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5709
__asm__ volatile("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y)); 
# 5710
} else { 
# 5711
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5712
__asm__ volatile("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y)); 
# 5713
} else { 
# 5714
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5715
__asm__ volatile("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y)); 
# 5716
}  }  }  
# 5717
} 
#endif
# 5719 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5720
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5730
::exit(___);}
#if 0
# 5720
{ 
# 5721
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5722
__asm__ volatile("sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x), "l" (data.y)); 
# 5723
} else { 
# 5724
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5725
__asm__ volatile("sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x), "l" (data.y)); 
# 5726
} else { 
# 5727
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5728
__asm__ volatile("sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x), "l" (data.y)); 
# 5729
}  }  }  
# 5730
} 
#endif
# 5732 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5733
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5743
::exit(___);}
#if 0
# 5733
{ 
# 5734
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5735
__asm__ volatile("sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x), "l" (data.y)); 
# 5736
} else { 
# 5737
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5738
__asm__ volatile("sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x), "l" (data.y)); 
# 5739
} else { 
# 5740
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5741
__asm__ volatile("sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "l" (data.x), "l" (data.y)); 
# 5742
}  }  }  
# 5743
} 
#endif
# 5745 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5746
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5756
::exit(___);}
#if 0
# 5746
{ 
# 5747
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5748
__asm__ volatile("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data.x), "f" (data.y)); 
# 5749
} else { 
# 5750
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5751
__asm__ volatile("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data.x), "f" (data.y)); 
# 5752
} else { 
# 5753
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5754
__asm__ volatile("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data.x), "f" (data.y)); 
# 5755
}  }  }  
# 5756
} 
#endif
# 5764 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5765
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5775
::exit(___);}
#if 0
# 5765
{ 
# 5766
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5767
__asm__ volatile("sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 5768
} else { 
# 5769
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5770
__asm__ volatile("sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 5771
} else { 
# 5772
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5773
__asm__ volatile("sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 5774
}  }  }  
# 5775
} 
#endif
# 5777 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5778
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5788
::exit(___);}
#if 0
# 5778
{ 
# 5779
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5780
__asm__ volatile("sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 5781
} else { 
# 5782
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5783
__asm__ volatile("sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 5784
} else { 
# 5785
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5786
__asm__ volatile("sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 5787
}  }  }  
# 5788
} 
#endif
# 5790 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5791
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5801
::exit(___);}
#if 0
# 5791
{ 
# 5792
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5793
__asm__ volatile("sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5794
} else { 
# 5795
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5796
__asm__ volatile("sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5797
} else { 
# 5798
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5799
__asm__ volatile("sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5800
}  }  }  
# 5801
} 
#endif
# 5803 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5804
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5814
::exit(___);}
#if 0
# 5804
{ 
# 5805
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5806
__asm__ volatile("sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5807
} else { 
# 5808
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5809
__asm__ volatile("sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5810
} else { 
# 5811
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5812
__asm__ volatile("sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 5813
}  }  }  
# 5814
} 
#endif
# 5816 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5817
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5827
::exit(___);}
#if 0
# 5817
{ 
# 5818
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5819
__asm__ volatile("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5820
} else { 
# 5821
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5822
__asm__ volatile("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5823
} else { 
# 5824
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5825
__asm__ volatile("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5826
}  }  }  
# 5827
} 
#endif
# 5829 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5830
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5840
::exit(___);}
#if 0
# 5830
{ 
# 5831
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5832
__asm__ volatile("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5833
} else { 
# 5834
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5835
__asm__ volatile("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5836
} else { 
# 5837
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5838
__asm__ volatile("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 5839
}  }  }  
# 5840
} 
#endif
# 5842 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5843
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 5853
::exit(___);}
#if 0
# 5843
{ 
# 5844
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5845
__asm__ volatile("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 5846
} else { 
# 5847
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5848
__asm__ volatile("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 5849
} else { 
# 5850
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5851
__asm__ volatile("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l" (surfObject), "r" (layer), "r" (x), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 5852
}  }  }  
# 5853
} 
#endif
# 5861 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5862
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5872
::exit(___);}
#if 0
# 5862
{ 
# 5863
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5864
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)data)); 
# 5865
} else { 
# 5866
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5867
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)data)); 
# 5868
} else { 
# 5869
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5870
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)data)); 
# 5871
}  }  }  
# 5872
} 
#endif
# 5874 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5875
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5885
::exit(___);}
#if 0
# 5875
{ 
# 5876
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5877
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)data)); 
# 5878
} else { 
# 5879
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5880
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)data)); 
# 5881
} else { 
# 5882
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5883
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)data)); 
# 5884
}  }  }  
# 5885
} 
#endif
# 5887 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5888
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5898
::exit(___);}
#if 0
# 5888
{ 
# 5889
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5890
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 5891
} else { 
# 5892
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5893
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 5894
} else { 
# 5895
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5896
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 5897
}  }  }  
# 5898
} 
#endif
# 5900 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5901
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5911
::exit(___);}
#if 0
# 5901
{ 
# 5902
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5903
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 5904
} else { 
# 5905
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5906
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 5907
} else { 
# 5908
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5909
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 5910
}  }  }  
# 5911
} 
#endif
# 5913 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5914
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5924
::exit(___);}
#if 0
# 5914
{ 
# 5915
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5916
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 5917
} else { 
# 5918
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5919
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 5920
} else { 
# 5921
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5922
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 5923
}  }  }  
# 5924
} 
#endif
# 5926 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5927
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5937
::exit(___);}
#if 0
# 5927
{ 
# 5928
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5929
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data)); 
# 5930
} else { 
# 5931
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5932
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data)); 
# 5933
} else { 
# 5934
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5935
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data)); 
# 5936
}  }  }  
# 5937
} 
#endif
# 5939 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5940
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5950
::exit(___);}
#if 0
# 5940
{ 
# 5941
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5942
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x)); 
# 5943
} else { 
# 5944
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5945
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x)); 
# 5946
} else { 
# 5947
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5948
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x)); 
# 5949
}  }  }  
# 5950
} 
#endif
# 5952 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5953
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5963
::exit(___);}
#if 0
# 5953
{ 
# 5954
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5955
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data)); 
# 5956
} else { 
# 5957
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5958
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data)); 
# 5959
} else { 
# 5960
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5961
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data)); 
# 5962
}  }  }  
# 5963
} 
#endif
# 5965 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5966
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5976
::exit(___);}
#if 0
# 5966
{ 
# 5967
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5968
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x)); 
# 5969
} else { 
# 5970
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5971
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x)); 
# 5972
} else { 
# 5973
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5974
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x)); 
# 5975
}  }  }  
# 5976
} 
#endif
# 5978 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5979
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 5989
::exit(___);}
#if 0
# 5979
{ 
# 5980
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5981
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data)); 
# 5982
} else { 
# 5983
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5984
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data)); 
# 5985
} else { 
# 5986
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 5987
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data)); 
# 5988
}  }  }  
# 5989
} 
#endif
# 5991 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 5992
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6002
::exit(___);}
#if 0
# 5992
{ 
# 5993
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 5994
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x)); 
# 5995
} else { 
# 5996
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 5997
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x)); 
# 5998
} else { 
# 5999
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6000
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x)); 
# 6001
}  }  }  
# 6002
} 
#endif
# 6004 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6005
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6015
::exit(___);}
#if 0
# 6005
{ 
# 6006
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6007
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data)); 
# 6008
} else { 
# 6009
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6010
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data)); 
# 6011
} else { 
# 6012
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6013
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data)); 
# 6014
}  }  }  
# 6015
} 
#endif
# 6017 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6018
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6028
::exit(___);}
#if 0
# 6018
{ 
# 6019
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6020
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x)); 
# 6021
} else { 
# 6022
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6023
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x)); 
# 6024
} else { 
# 6025
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6026
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x)); 
# 6027
}  }  }  
# 6028
} 
#endif
# 6030 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6031
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6041
::exit(___);}
#if 0
# 6031
{ 
# 6032
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6033
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data)); 
# 6034
} else { 
# 6035
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6036
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data)); 
# 6037
} else { 
# 6038
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6039
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data)); 
# 6040
}  }  }  
# 6041
} 
#endif
# 6043 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6044
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6054
::exit(___);}
#if 0
# 6044
{ 
# 6045
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6046
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x)); 
# 6047
} else { 
# 6048
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6049
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x)); 
# 6050
} else { 
# 6051
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6052
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x)); 
# 6053
}  }  }  
# 6054
} 
#endif
# 6056 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6057
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6067
::exit(___);}
#if 0
# 6057
{ 
# 6058
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6059
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data)); 
# 6060
} else { 
# 6061
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6062
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data)); 
# 6063
} else { 
# 6064
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6065
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data)); 
# 6066
}  }  }  
# 6067
} 
#endif
# 6069 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6070
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6080
::exit(___);}
#if 0
# 6070
{ 
# 6071
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6072
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x)); 
# 6073
} else { 
# 6074
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6075
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x)); 
# 6076
} else { 
# 6077
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6078
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x)); 
# 6079
}  }  }  
# 6080
} 
#endif
# 6082 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6083
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6093
::exit(___);}
#if 0
# 6083
{ 
# 6084
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6085
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data)); 
# 6086
} else { 
# 6087
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6088
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data)); 
# 6089
} else { 
# 6090
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6091
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data)); 
# 6092
}  }  }  
# 6093
} 
#endif
# 6095 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6096
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6106
::exit(___);}
#if 0
# 6096
{ 
# 6097
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6098
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data.x)); 
# 6099
} else { 
# 6100
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6101
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data.x)); 
# 6102
} else { 
# 6103
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6104
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data.x)); 
# 6105
}  }  }  
# 6106
} 
#endif
# 6114 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6115
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6125
::exit(___);}
#if 0
# 6115
{ 
# 6116
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6117
__asm__ volatile("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 6118
} else { 
# 6119
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6120
__asm__ volatile("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 6121
} else { 
# 6122
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6123
__asm__ volatile("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 6124
}  }  }  
# 6125
} 
#endif
# 6127 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6128
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6138
::exit(___);}
#if 0
# 6128
{ 
# 6129
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6130
__asm__ volatile("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 6131
} else { 
# 6132
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6133
__asm__ volatile("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 6134
} else { 
# 6135
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6136
__asm__ volatile("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 6137
}  }  }  
# 6138
} 
#endif
# 6140 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6141
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6151
::exit(___);}
#if 0
# 6141
{ 
# 6142
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6143
__asm__ volatile("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6144
} else { 
# 6145
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6146
__asm__ volatile("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6147
} else { 
# 6148
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6149
__asm__ volatile("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6150
}  }  }  
# 6151
} 
#endif
# 6153 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6154
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6164
::exit(___);}
#if 0
# 6154
{ 
# 6155
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6156
__asm__ volatile("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6157
} else { 
# 6158
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6159
__asm__ volatile("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6160
} else { 
# 6161
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6162
__asm__ volatile("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6163
}  }  }  
# 6164
} 
#endif
# 6166 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6167
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6177
::exit(___);}
#if 0
# 6167
{ 
# 6168
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6169
__asm__ volatile("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6170
} else { 
# 6171
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6172
__asm__ volatile("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6173
} else { 
# 6174
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6175
__asm__ volatile("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6176
}  }  }  
# 6177
} 
#endif
# 6179 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6180
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6190
::exit(___);}
#if 0
# 6180
{ 
# 6181
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6182
__asm__ volatile("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6183
} else { 
# 6184
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6185
__asm__ volatile("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6186
} else { 
# 6187
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6188
__asm__ volatile("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6189
}  }  }  
# 6190
} 
#endif
# 6192 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6193
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6203
::exit(___);}
#if 0
# 6193
{ 
# 6194
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6195
__asm__ volatile("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6196
} else { 
# 6197
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6198
__asm__ volatile("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6199
} else { 
# 6200
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6201
__asm__ volatile("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6202
}  }  }  
# 6203
} 
#endif
# 6205 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6206
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6216
::exit(___);}
#if 0
# 6206
{ 
# 6207
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6208
__asm__ volatile("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6209
} else { 
# 6210
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6211
__asm__ volatile("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6212
} else { 
# 6213
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6214
__asm__ volatile("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6215
}  }  }  
# 6216
} 
#endif
# 6218 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6219
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6229
::exit(___);}
#if 0
# 6219
{ 
# 6220
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6221
__asm__ volatile("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 6222
} else { 
# 6223
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6224
__asm__ volatile("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 6225
} else { 
# 6226
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6227
__asm__ volatile("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 6228
}  }  }  
# 6229
} 
#endif
# 6237 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6238
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6248
::exit(___);}
#if 0
# 6238
{ 
# 6239
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6240
__asm__ volatile("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 6241
} else { 
# 6242
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6243
__asm__ volatile("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 6244
} else { 
# 6245
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6246
__asm__ volatile("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 6247
}  }  }  
# 6248
} 
#endif
# 6250 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6251
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6261
::exit(___);}
#if 0
# 6251
{ 
# 6252
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6253
__asm__ volatile("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 6254
} else { 
# 6255
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6256
__asm__ volatile("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 6257
} else { 
# 6258
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6259
__asm__ volatile("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 6260
}  }  }  
# 6261
} 
#endif
# 6263 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6264
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6274
::exit(___);}
#if 0
# 6264
{ 
# 6265
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6266
__asm__ volatile("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6267
} else { 
# 6268
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6269
__asm__ volatile("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6270
} else { 
# 6271
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6272
__asm__ volatile("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6273
}  }  }  
# 6274
} 
#endif
# 6276 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6277
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6287
::exit(___);}
#if 0
# 6277
{ 
# 6278
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6279
__asm__ volatile("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6280
} else { 
# 6281
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6282
__asm__ volatile("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6283
} else { 
# 6284
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6285
__asm__ volatile("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6286
}  }  }  
# 6287
} 
#endif
# 6289 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6290
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6300
::exit(___);}
#if 0
# 6290
{ 
# 6291
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6292
__asm__ volatile("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6293
} else { 
# 6294
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6295
__asm__ volatile("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6296
} else { 
# 6297
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6298
__asm__ volatile("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6299
}  }  }  
# 6300
} 
#endif
# 6302 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6303
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6313
::exit(___);}
#if 0
# 6303
{ 
# 6304
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6305
__asm__ volatile("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6306
} else { 
# 6307
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6308
__asm__ volatile("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6309
} else { 
# 6310
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6311
__asm__ volatile("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6312
}  }  }  
# 6313
} 
#endif
# 6315 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6316
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 6326
::exit(___);}
#if 0
# 6316
{ 
# 6317
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6318
__asm__ volatile("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 6319
} else { 
# 6320
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6321
__asm__ volatile("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 6322
} else { 
# 6323
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6324
__asm__ volatile("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layer), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 6325
}  }  }  
# 6326
} 
#endif
# 6334 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6335
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6345
::exit(___);}
#if 0
# 6335
{ 
# 6336
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6337
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)data)); 
# 6338
} else { 
# 6339
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6340
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)data)); 
# 6341
} else { 
# 6342
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6343
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)data)); 
# 6344
}  }  }  
# 6345
} 
#endif
# 6347 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6348
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6358
::exit(___);}
#if 0
# 6348
{ 
# 6349
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6350
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)data)); 
# 6351
} else { 
# 6352
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6353
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)data)); 
# 6354
} else { 
# 6355
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6356
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)data)); 
# 6357
}  }  }  
# 6358
} 
#endif
# 6360 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6361
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6371
::exit(___);}
#if 0
# 6361
{ 
# 6362
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6363
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 6364
} else { 
# 6365
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6366
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 6367
} else { 
# 6368
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6369
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 6370
}  }  }  
# 6371
} 
#endif
# 6373 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6374
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6384
::exit(___);}
#if 0
# 6374
{ 
# 6375
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6376
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 6377
} else { 
# 6378
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6379
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 6380
} else { 
# 6381
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6382
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 6383
}  }  }  
# 6384
} 
#endif
# 6386 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6387
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6397
::exit(___);}
#if 0
# 6387
{ 
# 6388
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6389
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 6390
} else { 
# 6391
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6392
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 6393
} else { 
# 6394
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6395
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 6396
}  }  }  
# 6397
} 
#endif
# 6399 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6400
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6410
::exit(___);}
#if 0
# 6400
{ 
# 6401
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6402
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data)); 
# 6403
} else { 
# 6404
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6405
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data)); 
# 6406
} else { 
# 6407
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6408
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data)); 
# 6409
}  }  }  
# 6410
} 
#endif
# 6412 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6413
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6423
::exit(___);}
#if 0
# 6413
{ 
# 6414
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6415
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x)); 
# 6416
} else { 
# 6417
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6418
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x)); 
# 6419
} else { 
# 6420
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6421
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x)); 
# 6422
}  }  }  
# 6423
} 
#endif
# 6425 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6426
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6436
::exit(___);}
#if 0
# 6426
{ 
# 6427
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6428
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data)); 
# 6429
} else { 
# 6430
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6431
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data)); 
# 6432
} else { 
# 6433
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6434
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data)); 
# 6435
}  }  }  
# 6436
} 
#endif
# 6438 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6439
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6449
::exit(___);}
#if 0
# 6439
{ 
# 6440
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6441
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x)); 
# 6442
} else { 
# 6443
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6444
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x)); 
# 6445
} else { 
# 6446
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6447
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x)); 
# 6448
}  }  }  
# 6449
} 
#endif
# 6451 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6452
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6462
::exit(___);}
#if 0
# 6452
{ 
# 6453
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6454
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data)); 
# 6455
} else { 
# 6456
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6457
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data)); 
# 6458
} else { 
# 6459
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6460
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data)); 
# 6461
}  }  }  
# 6462
} 
#endif
# 6464 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6465
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6475
::exit(___);}
#if 0
# 6465
{ 
# 6466
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6467
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x)); 
# 6468
} else { 
# 6469
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6470
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x)); 
# 6471
} else { 
# 6472
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6473
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x)); 
# 6474
}  }  }  
# 6475
} 
#endif
# 6477 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6478
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6488
::exit(___);}
#if 0
# 6478
{ 
# 6479
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6480
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data)); 
# 6481
} else { 
# 6482
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6483
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data)); 
# 6484
} else { 
# 6485
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6486
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data)); 
# 6487
}  }  }  
# 6488
} 
#endif
# 6490 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6491
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6501
::exit(___);}
#if 0
# 6491
{ 
# 6492
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6493
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x)); 
# 6494
} else { 
# 6495
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6496
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x)); 
# 6497
} else { 
# 6498
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6499
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x)); 
# 6500
}  }  }  
# 6501
} 
#endif
# 6503 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6504
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6514
::exit(___);}
#if 0
# 6504
{ 
# 6505
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6506
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data)); 
# 6507
} else { 
# 6508
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6509
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data)); 
# 6510
} else { 
# 6511
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6512
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data)); 
# 6513
}  }  }  
# 6514
} 
#endif
# 6516 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6517
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6527
::exit(___);}
#if 0
# 6517
{ 
# 6518
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6519
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x)); 
# 6520
} else { 
# 6521
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6522
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x)); 
# 6523
} else { 
# 6524
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6525
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x)); 
# 6526
}  }  }  
# 6527
} 
#endif
# 6529 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6530
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6540
::exit(___);}
#if 0
# 6530
{ 
# 6531
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6532
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data)); 
# 6533
} else { 
# 6534
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6535
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data)); 
# 6536
} else { 
# 6537
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6538
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data)); 
# 6539
}  }  }  
# 6540
} 
#endif
# 6542 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6543
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6553
::exit(___);}
#if 0
# 6543
{ 
# 6544
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6545
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x)); 
# 6546
} else { 
# 6547
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6548
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x)); 
# 6549
} else { 
# 6550
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6551
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x)); 
# 6552
}  }  }  
# 6553
} 
#endif
# 6555 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6556
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6566
::exit(___);}
#if 0
# 6556
{ 
# 6557
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6558
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data)); 
# 6559
} else { 
# 6560
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6561
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data)); 
# 6562
} else { 
# 6563
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6564
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data)); 
# 6565
}  }  }  
# 6566
} 
#endif
# 6568 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6569
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6579
::exit(___);}
#if 0
# 6569
{ 
# 6570
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6571
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data.x)); 
# 6572
} else { 
# 6573
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6574
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data.x)); 
# 6575
} else { 
# 6576
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6577
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data.x)); 
# 6578
}  }  }  
# 6579
} 
#endif
# 6587 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6588
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6598
::exit(___);}
#if 0
# 6588
{ 
# 6589
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6590
__asm__ volatile("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 6591
} else { 
# 6592
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6593
__asm__ volatile("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 6594
} else { 
# 6595
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6596
__asm__ volatile("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 6597
}  }  }  
# 6598
} 
#endif
# 6600 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6601
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6611
::exit(___);}
#if 0
# 6601
{ 
# 6602
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6603
__asm__ volatile("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 6604
} else { 
# 6605
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6606
__asm__ volatile("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 6607
} else { 
# 6608
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6609
__asm__ volatile("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 6610
}  }  }  
# 6611
} 
#endif
# 6613 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6614
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6624
::exit(___);}
#if 0
# 6614
{ 
# 6615
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6616
__asm__ volatile("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6617
} else { 
# 6618
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6619
__asm__ volatile("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6620
} else { 
# 6621
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6622
__asm__ volatile("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6623
}  }  }  
# 6624
} 
#endif
# 6626 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6627
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6637
::exit(___);}
#if 0
# 6627
{ 
# 6628
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6629
__asm__ volatile("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6630
} else { 
# 6631
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6632
__asm__ volatile("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6633
} else { 
# 6634
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6635
__asm__ volatile("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 6636
}  }  }  
# 6637
} 
#endif
# 6639 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6640
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6650
::exit(___);}
#if 0
# 6640
{ 
# 6641
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6642
__asm__ volatile("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6643
} else { 
# 6644
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6645
__asm__ volatile("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6646
} else { 
# 6647
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6648
__asm__ volatile("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6649
}  }  }  
# 6650
} 
#endif
# 6652 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6653
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6663
::exit(___);}
#if 0
# 6653
{ 
# 6654
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6655
__asm__ volatile("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6656
} else { 
# 6657
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6658
__asm__ volatile("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6659
} else { 
# 6660
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6661
__asm__ volatile("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 6662
}  }  }  
# 6663
} 
#endif
# 6665 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6666
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6676
::exit(___);}
#if 0
# 6666
{ 
# 6667
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6668
__asm__ volatile("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6669
} else { 
# 6670
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6671
__asm__ volatile("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6672
} else { 
# 6673
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6674
__asm__ volatile("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6675
}  }  }  
# 6676
} 
#endif
# 6678 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6679
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6689
::exit(___);}
#if 0
# 6679
{ 
# 6680
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6681
__asm__ volatile("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6682
} else { 
# 6683
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6684
__asm__ volatile("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6685
} else { 
# 6686
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6687
__asm__ volatile("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 6688
}  }  }  
# 6689
} 
#endif
# 6691 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6692
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6702
::exit(___);}
#if 0
# 6692
{ 
# 6693
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6694
__asm__ volatile("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 6695
} else { 
# 6696
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6697
__asm__ volatile("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 6698
} else { 
# 6699
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6700
__asm__ volatile("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 6701
}  }  }  
# 6702
} 
#endif
# 6710 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6711
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6721
::exit(___);}
#if 0
# 6711
{ 
# 6712
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6713
__asm__ volatile("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 6714
} else { 
# 6715
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6716
__asm__ volatile("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 6717
} else { 
# 6718
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6719
__asm__ volatile("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 6720
}  }  }  
# 6721
} 
#endif
# 6723 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6724
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6734
::exit(___);}
#if 0
# 6724
{ 
# 6725
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6726
__asm__ volatile("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 6727
} else { 
# 6728
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6729
__asm__ volatile("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 6730
} else { 
# 6731
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6732
__asm__ volatile("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 6733
}  }  }  
# 6734
} 
#endif
# 6736 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6737
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6747
::exit(___);}
#if 0
# 6737
{ 
# 6738
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6739
__asm__ volatile("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6740
} else { 
# 6741
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6742
__asm__ volatile("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6743
} else { 
# 6744
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6745
__asm__ volatile("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6746
}  }  }  
# 6747
} 
#endif
# 6749 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6750
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6760
::exit(___);}
#if 0
# 6750
{ 
# 6751
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6752
__asm__ volatile("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6753
} else { 
# 6754
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6755
__asm__ volatile("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6756
} else { 
# 6757
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6758
__asm__ volatile("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 6759
}  }  }  
# 6760
} 
#endif
# 6762 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6763
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6773
::exit(___);}
#if 0
# 6763
{ 
# 6764
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6765
__asm__ volatile("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6766
} else { 
# 6767
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6768
__asm__ volatile("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6769
} else { 
# 6770
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6771
__asm__ volatile("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6772
}  }  }  
# 6773
} 
#endif
# 6775 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6776
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6786
::exit(___);}
#if 0
# 6776
{ 
# 6777
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6778
__asm__ volatile("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6779
} else { 
# 6780
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6781
__asm__ volatile("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6782
} else { 
# 6783
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6784
__asm__ volatile("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 6785
}  }  }  
# 6786
} 
#endif
# 6788 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6789
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 6799
::exit(___);}
#if 0
# 6789
{ 
# 6790
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6791
__asm__ volatile("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 6792
} else { 
# 6793
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6794
__asm__ volatile("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 6795
} else { 
# 6796
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6797
__asm__ volatile("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (face), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 6798
}  }  }  
# 6799
} 
#endif
# 6807 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6808
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6818
::exit(___);}
#if 0
# 6808
{ 
# 6809
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6810
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)data)); 
# 6811
} else { 
# 6812
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6813
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)data)); 
# 6814
} else { 
# 6815
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6816
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)data)); 
# 6817
}  }  }  
# 6818
} 
#endif
# 6820 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6821
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6831
::exit(___);}
#if 0
# 6821
{ 
# 6822
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6823
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)data)); 
# 6824
} else { 
# 6825
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6826
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)data)); 
# 6827
} else { 
# 6828
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6829
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)data)); 
# 6830
}  }  }  
# 6831
} 
#endif
# 6833 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6834
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6844
::exit(___);}
#if 0
# 6834
{ 
# 6835
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6836
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 6837
} else { 
# 6838
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6839
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 6840
} else { 
# 6841
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6842
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)(data.x))); 
# 6843
}  }  }  
# 6844
} 
#endif
# 6846 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6847
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6857
::exit(___);}
#if 0
# 6847
{ 
# 6848
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6849
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 6850
} else { 
# 6851
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6852
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 6853
} else { 
# 6854
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6855
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)data)); 
# 6856
}  }  }  
# 6857
} 
#endif
# 6859 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6860
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6870
::exit(___);}
#if 0
# 6860
{ 
# 6861
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6862
__asm__ volatile("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 6863
} else { 
# 6864
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6865
__asm__ volatile("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 6866
} else { 
# 6867
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6868
__asm__ volatile("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)(data.x))); 
# 6869
}  }  }  
# 6870
} 
#endif
# 6872 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6873
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6883
::exit(___);}
#if 0
# 6873
{ 
# 6874
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6875
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data)); 
# 6876
} else { 
# 6877
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6878
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data)); 
# 6879
} else { 
# 6880
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6881
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data)); 
# 6882
}  }  }  
# 6883
} 
#endif
# 6885 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6886
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6896
::exit(___);}
#if 0
# 6886
{ 
# 6887
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6888
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x)); 
# 6889
} else { 
# 6890
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6891
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x)); 
# 6892
} else { 
# 6893
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6894
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x)); 
# 6895
}  }  }  
# 6896
} 
#endif
# 6898 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6899
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6909
::exit(___);}
#if 0
# 6899
{ 
# 6900
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6901
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data)); 
# 6902
} else { 
# 6903
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6904
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data)); 
# 6905
} else { 
# 6906
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6907
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data)); 
# 6908
}  }  }  
# 6909
} 
#endif
# 6911 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6912
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6922
::exit(___);}
#if 0
# 6912
{ 
# 6913
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6914
__asm__ volatile("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x)); 
# 6915
} else { 
# 6916
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6917
__asm__ volatile("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x)); 
# 6918
} else { 
# 6919
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6920
__asm__ volatile("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x)); 
# 6921
}  }  }  
# 6922
} 
#endif
# 6924 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6925
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6935
::exit(___);}
#if 0
# 6925
{ 
# 6926
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6927
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data)); 
# 6928
} else { 
# 6929
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6930
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data)); 
# 6931
} else { 
# 6932
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6933
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data)); 
# 6934
}  }  }  
# 6935
} 
#endif
# 6937 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6938
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6948
::exit(___);}
#if 0
# 6938
{ 
# 6939
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6940
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x)); 
# 6941
} else { 
# 6942
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6943
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x)); 
# 6944
} else { 
# 6945
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6946
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x)); 
# 6947
}  }  }  
# 6948
} 
#endif
# 6950 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6951
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6961
::exit(___);}
#if 0
# 6951
{ 
# 6952
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6953
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data)); 
# 6954
} else { 
# 6955
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6956
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data)); 
# 6957
} else { 
# 6958
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6959
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data)); 
# 6960
}  }  }  
# 6961
} 
#endif
# 6963 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6964
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6974
::exit(___);}
#if 0
# 6964
{ 
# 6965
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6966
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x)); 
# 6967
} else { 
# 6968
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6969
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x)); 
# 6970
} else { 
# 6971
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6972
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x)); 
# 6973
}  }  }  
# 6974
} 
#endif
# 6976 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6977
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 6987
::exit(___);}
#if 0
# 6977
{ 
# 6978
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6979
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data)); 
# 6980
} else { 
# 6981
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6982
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data)); 
# 6983
} else { 
# 6984
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6985
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data)); 
# 6986
}  }  }  
# 6987
} 
#endif
# 6989 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 6990
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7000
::exit(___);}
#if 0
# 6990
{ 
# 6991
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 6992
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x)); 
# 6993
} else { 
# 6994
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 6995
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x)); 
# 6996
} else { 
# 6997
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 6998
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x)); 
# 6999
}  }  }  
# 7000
} 
#endif
# 7002 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7003
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7013
::exit(___);}
#if 0
# 7003
{ 
# 7004
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7005
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data)); 
# 7006
} else { 
# 7007
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7008
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data)); 
# 7009
} else { 
# 7010
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7011
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data)); 
# 7012
}  }  }  
# 7013
} 
#endif
# 7015 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7016
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7026
::exit(___);}
#if 0
# 7016
{ 
# 7017
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7018
__asm__ volatile("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x)); 
# 7019
} else { 
# 7020
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7021
__asm__ volatile("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x)); 
# 7022
} else { 
# 7023
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7024
__asm__ volatile("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x)); 
# 7025
}  }  }  
# 7026
} 
#endif
# 7028 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7029
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7039
::exit(___);}
#if 0
# 7029
{ 
# 7030
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7031
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data)); 
# 7032
} else { 
# 7033
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7034
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data)); 
# 7035
} else { 
# 7036
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7037
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data)); 
# 7038
}  }  }  
# 7039
} 
#endif
# 7041 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7042
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7052
::exit(___);}
#if 0
# 7042
{ 
# 7043
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7044
__asm__ volatile("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data.x)); 
# 7045
} else { 
# 7046
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7047
__asm__ volatile("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data.x)); 
# 7048
} else { 
# 7049
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7050
__asm__ volatile("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data.x)); 
# 7051
}  }  }  
# 7052
} 
#endif
# 7060 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7061
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7071
::exit(___);}
#if 0
# 7061
{ 
# 7062
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7063
__asm__ volatile("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 7064
} else { 
# 7065
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7066
__asm__ volatile("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 7067
} else { 
# 7068
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7069
__asm__ volatile("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y))); 
# 7070
}  }  }  
# 7071
} 
#endif
# 7073 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7074
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7084
::exit(___);}
#if 0
# 7074
{ 
# 7075
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7076
__asm__ volatile("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 7077
} else { 
# 7078
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7079
__asm__ volatile("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 7080
} else { 
# 7081
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7082
__asm__ volatile("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y))); 
# 7083
}  }  }  
# 7084
} 
#endif
# 7086 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7087
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7097
::exit(___);}
#if 0
# 7087
{ 
# 7088
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7089
__asm__ volatile("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 7090
} else { 
# 7091
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7092
__asm__ volatile("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 7093
} else { 
# 7094
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7095
__asm__ volatile("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 7096
}  }  }  
# 7097
} 
#endif
# 7099 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7100
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7110
::exit(___);}
#if 0
# 7100
{ 
# 7101
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7102
__asm__ volatile("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 7103
} else { 
# 7104
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7105
__asm__ volatile("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 7106
} else { 
# 7107
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7108
__asm__ volatile("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y)); 
# 7109
}  }  }  
# 7110
} 
#endif
# 7112 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7113
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7123
::exit(___);}
#if 0
# 7113
{ 
# 7114
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7115
__asm__ volatile("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 7116
} else { 
# 7117
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7118
__asm__ volatile("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 7119
} else { 
# 7120
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7121
__asm__ volatile("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 7122
}  }  }  
# 7123
} 
#endif
# 7125 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7126
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7136
::exit(___);}
#if 0
# 7126
{ 
# 7127
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7128
__asm__ volatile("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 7129
} else { 
# 7130
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7131
__asm__ volatile("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 7132
} else { 
# 7133
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7134
__asm__ volatile("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y)); 
# 7135
}  }  }  
# 7136
} 
#endif
# 7138 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7139
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7149
::exit(___);}
#if 0
# 7139
{ 
# 7140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7141
__asm__ volatile("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 7142
} else { 
# 7143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7144
__asm__ volatile("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 7145
} else { 
# 7146
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7147
__asm__ volatile("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 7148
}  }  }  
# 7149
} 
#endif
# 7151 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7152
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7162
::exit(___);}
#if 0
# 7152
{ 
# 7153
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7154
__asm__ volatile("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 7155
} else { 
# 7156
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7157
__asm__ volatile("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 7158
} else { 
# 7159
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7160
__asm__ volatile("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "l" (data.x), "l" (data.y)); 
# 7161
}  }  }  
# 7162
} 
#endif
# 7164 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7165
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7175
::exit(___);}
#if 0
# 7165
{ 
# 7166
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7167
__asm__ volatile("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 7168
} else { 
# 7169
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7170
__asm__ volatile("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 7171
} else { 
# 7172
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7173
__asm__ volatile("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data.x), "f" (data.y)); 
# 7174
}  }  }  
# 7175
} 
#endif
# 7183 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7184
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7194
::exit(___);}
#if 0
# 7184
{ 
# 7185
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7186
__asm__ volatile("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 7187
} else { 
# 7188
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7189
__asm__ volatile("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 7190
} else { 
# 7191
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7192
__asm__ volatile("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((int)(data.x)), "r" ((int)(data.y)), "r" ((int)(data.z)), "r" ((int)(data.w))); 
# 7193
}  }  }  
# 7194
} 
#endif
# 7196 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7197
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7207
::exit(___);}
#if 0
# 7197
{ 
# 7198
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7199
__asm__ volatile("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 7200
} else { 
# 7201
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7202
__asm__ volatile("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 7203
} else { 
# 7204
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7205
__asm__ volatile("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" ((unsigned)(data.x)), "r" ((unsigned)(data.y)), "r" ((unsigned)(data.z)), "r" ((unsigned)(data.w))); 
# 7206
}  }  }  
# 7207
} 
#endif
# 7209 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7210
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7220
::exit(___);}
#if 0
# 7210
{ 
# 7211
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7212
__asm__ volatile("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 7213
} else { 
# 7214
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7215
__asm__ volatile("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 7216
} else { 
# 7217
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7218
__asm__ volatile("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 7219
}  }  }  
# 7220
} 
#endif
# 7222 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7223
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7233
::exit(___);}
#if 0
# 7223
{ 
# 7224
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7225
__asm__ volatile("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 7226
} else { 
# 7227
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7228
__asm__ volatile("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 7229
} else { 
# 7230
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7231
__asm__ volatile("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "h" (data.x), "h" (data.y), "h" (data.z), "h" (data.w)); 
# 7232
}  }  }  
# 7233
} 
#endif
# 7235 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7236
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7246
::exit(___);}
#if 0
# 7236
{ 
# 7237
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7238
__asm__ volatile("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 7239
} else { 
# 7240
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7241
__asm__ volatile("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 7242
} else { 
# 7243
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7244
__asm__ volatile("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 7245
}  }  }  
# 7246
} 
#endif
# 7248 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7249
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7259
::exit(___);}
#if 0
# 7249
{ 
# 7250
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7251
__asm__ volatile("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 7252
} else { 
# 7253
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7254
__asm__ volatile("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 7255
} else { 
# 7256
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7257
__asm__ volatile("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "r" (data.x), "r" (data.y), "r" (data.z), "r" (data.w)); 
# 7258
}  }  }  
# 7259
} 
#endif
# 7261 "/usr/local/cuda/bin/..//include/surface_indirect_functions.h"
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 7262
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)layerface;(void)boundaryMode;
# 7272
::exit(___);}
#if 0
# 7262
{ 
# 7263
if (boundaryMode == (cudaBoundaryModeTrap)) { 
# 7264
__asm__ volatile("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 7265
} else { 
# 7266
if (boundaryMode == (cudaBoundaryModeClamp)) { 
# 7267
__asm__ volatile("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 7268
} else { 
# 7269
if (boundaryMode == (cudaBoundaryModeZero)) { 
# 7270
__asm__ volatile("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l" (surfObject), "r" (layerface), "r" (x), "r" (y), "f" (data.x), "f" (data.y), "f" (data.z), "f" (data.w)); 
# 7271
}  }  }  
# 7272
} 
#endif
# 66 "/usr/local/cuda/bin/..//include/device_launch_parameters.h"
extern "C" { extern const uint3 threadIdx; } 
# 67
extern "C" { extern const uint3 blockIdx; } 
# 68
extern "C" { extern const dim3 blockDim; } 
# 69
extern "C" { extern const dim3 gridDim; } 
# 70
extern "C" { extern const int warpSize; } 
# 116 "/usr/local/cuda/bin/..//include/cuda_device_runtime_api.h"
namespace _GLOBAL__N__12_test_cpp1_ii_main { }; using namespace _GLOBAL__N__12_test_cpp1_ii_main; namespace _GLOBAL__N__12_test_cpp1_ii_main { 
# 123 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 124
cudaSetupArgument(T 
# 125
arg, size_t 
# 126
offset) 
# 128
{ 
# 129
return ::cudaSetupArgument((const void *)(&arg), sizeof(T), offset); 
# 130
} 
# 162 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
static inline cudaError_t cudaEventCreate(cudaEvent_t *
# 163
event, unsigned 
# 164
flags) 
# 166
{ 
# 167
return ::cudaEventCreateWithFlags(event, flags); 
# 168
} 
# 225 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
inline cudaError_t cudaMallocHost(void **
# 226
ptr, size_t 
# 227
size, unsigned 
# 228
flags) 
# 230
{ 
# 231
return ::cudaHostAlloc(ptr, size, flags); 
# 232
} 
# 234
template< class T> inline cudaError_t 
# 235
cudaHostAlloc(T **
# 236
ptr, size_t 
# 237
size, unsigned 
# 238
flags) 
# 240
{ 
# 241
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
# 242
} 
# 244
template< class T> inline cudaError_t 
# 245
cudaHostGetDevicePointer(T **
# 246
pDevice, void *
# 247
pHost, unsigned 
# 248
flags) 
# 250
{ 
# 251
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
# 252
} 
# 254
template< class T> inline cudaError_t 
# 255
cudaMalloc(T **
# 256
devPtr, size_t 
# 257
size) 
# 259
{ 
# 260
return ::cudaMalloc((void **)((void *)devPtr), size); 
# 261
} 
# 263
template< class T> inline cudaError_t 
# 264
cudaMallocHost(T **
# 265
ptr, size_t 
# 266
size, unsigned 
# 267
flags = 0) 
# 269
{ 
# 270
return cudaMallocHost((void **)((void *)ptr), size, flags); 
# 271
} 
# 273
template< class T> inline cudaError_t 
# 274
cudaMallocPitch(T **
# 275
devPtr, size_t *
# 276
pitch, size_t 
# 277
width, size_t 
# 278
height) 
# 280
{ 
# 281
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
# 282
} 
# 319 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 320
cudaMemcpyToSymbol(const T &
# 321
symbol, const void *
# 322
src, size_t 
# 323
count, size_t 
# 324
offset = 0, cudaMemcpyKind 
# 325
kind = cudaMemcpyHostToDevice) 
# 327
{ 
# 328
return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset, kind); 
# 329
} 
# 371 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 372
cudaMemcpyToSymbolAsync(const T &
# 373
symbol, const void *
# 374
src, size_t 
# 375
count, size_t 
# 376
offset = 0, cudaMemcpyKind 
# 377
kind = cudaMemcpyHostToDevice, cudaStream_t 
# 378
stream = 0) 
# 380
{ 
# 381
return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count, offset, kind, stream); 
# 382
} 
# 417 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 418
cudaMemcpyFromSymbol(void *
# 419
dst, const T &
# 420
symbol, size_t 
# 421
count, size_t 
# 422
offset = 0, cudaMemcpyKind 
# 423
kind = cudaMemcpyDeviceToHost) 
# 425
{ 
# 426
return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count, offset, kind); 
# 427
} 
# 469 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 470
cudaMemcpyFromSymbolAsync(void *
# 471
dst, const T &
# 472
symbol, size_t 
# 473
count, size_t 
# 474
offset = 0, cudaMemcpyKind 
# 475
kind = cudaMemcpyDeviceToHost, cudaStream_t 
# 476
stream = 0) 
# 478
{ 
# 479
return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count, offset, kind, stream); 
# 480
} 
# 502 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 503
cudaGetSymbolAddress(void **
# 504
devPtr, const T &
# 505
symbol) 
# 507
{ 
# 508
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
# 509
} 
# 531 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 532
cudaGetSymbolSize(size_t *
# 533
size, const T &
# 534
symbol) 
# 536
{ 
# 537
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
# 538
} 
# 574 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> inline cudaError_t 
# 575
cudaBindTexture(size_t *
# 576
offset, const texture< T, dim, readMode>  &
# 577
tex, const void *
# 578
devPtr, const cudaChannelFormatDesc &
# 579
desc, size_t 
# 580
size = ((2147483647) * 2U) + 1U) 
# 582
{ 
# 583
return ::cudaBindTexture(offset, &tex, devPtr, &desc, size); 
# 584
} 
# 619 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> inline cudaError_t 
# 620
cudaBindTexture(size_t *
# 621
offset, const texture< T, dim, readMode>  &
# 622
tex, const void *
# 623
devPtr, size_t 
# 624
size = ((2147483647) * 2U) + 1U) 
# 626
{ 
# 627
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
# 628
} 
# 675 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> inline cudaError_t 
# 676
cudaBindTexture2D(size_t *
# 677
offset, const texture< T, dim, readMode>  &
# 678
tex, const void *
# 679
devPtr, const cudaChannelFormatDesc &
# 680
desc, size_t 
# 681
width, size_t 
# 682
height, size_t 
# 683
pitch) 
# 685
{ 
# 686
return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch); 
# 687
} 
# 733 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> inline cudaError_t 
# 734
cudaBindTexture2D(size_t *
# 735
offset, const texture< T, dim, readMode>  &
# 736
tex, const void *
# 737
devPtr, size_t 
# 738
width, size_t 
# 739
height, size_t 
# 740
pitch) 
# 742
{ 
# 743
return ::cudaBindTexture2D(offset, &tex, devPtr, &(tex.channelDesc), width, height, pitch); 
# 744
} 
# 775 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> inline cudaError_t 
# 776
cudaBindTextureToArray(const texture< T, dim, readMode>  &
# 777
tex, cudaArray_const_t 
# 778
array, const cudaChannelFormatDesc &
# 779
desc) 
# 781
{ 
# 782
return ::cudaBindTextureToArray(&tex, array, &desc); 
# 783
} 
# 813 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> inline cudaError_t 
# 814
cudaBindTextureToArray(const texture< T, dim, readMode>  &
# 815
tex, cudaArray_const_t 
# 816
array) 
# 818
{ 
# 819
cudaChannelFormatDesc desc; 
# 820
cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
# 822
return (err == (cudaSuccess)) ? cudaBindTextureToArray(tex, array, desc) : err; 
# 823
} 
# 854 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> inline cudaError_t 
# 855
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
# 856
tex, cudaMipmappedArray_const_t 
# 857
mipmappedArray, const cudaChannelFormatDesc &
# 858
desc) 
# 860
{ 
# 861
return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc); 
# 862
} 
# 892 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> inline cudaError_t 
# 893
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
# 894
tex, cudaMipmappedArray_const_t 
# 895
mipmappedArray) 
# 897
{ 
# 898
cudaChannelFormatDesc desc; 
# 899
cudaArray_t levelArray; 
# 900
cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0); 
# 902
if (err != (cudaSuccess)) { 
# 903
return err; 
# 904
}  
# 905
err = ::cudaGetChannelDesc(&desc, levelArray); 
# 907
return (err == (cudaSuccess)) ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err; 
# 908
} 
# 931 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> inline cudaError_t 
# 932
cudaUnbindTexture(const texture< T, dim, readMode>  &
# 933
tex) 
# 935
{ 
# 936
return ::cudaUnbindTexture(&tex); 
# 937
} 
# 965 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> inline cudaError_t 
# 966
cudaGetTextureAlignmentOffset(size_t *
# 967
offset, const texture< T, dim, readMode>  &
# 968
tex) 
# 970
{ 
# 971
return ::cudaGetTextureAlignmentOffset(offset, &tex); 
# 972
} 
# 1018 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 1019
cudaFuncSetCacheConfig(T *
# 1020
func, cudaFuncCache 
# 1021
cacheConfig) 
# 1023
{ 
# 1024
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
# 1025
} 
# 1027
template< class T> inline cudaError_t 
# 1028
cudaFuncSetSharedMemConfig(T *
# 1029
func, cudaSharedMemConfig 
# 1030
config) 
# 1032
{ 
# 1033
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
# 1034
} 
# 1070 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 1071
cudaLaunch(T *
# 1072
func) 
# 1074
{ 
# 1075
return ::cudaLaunch((const void *)func); 
# 1076
} 
# 1108 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 1109
cudaFuncGetAttributes(cudaFuncAttributes *
# 1110
attr, T *
# 1111
entry) 
# 1113
{ 
# 1114
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
# 1115
} 
# 1137 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim> inline cudaError_t 
# 1138
cudaBindSurfaceToArray(const surface< T, dim>  &
# 1139
surf, cudaArray_const_t 
# 1140
array, const cudaChannelFormatDesc &
# 1141
desc) 
# 1143
{ 
# 1144
return ::cudaBindSurfaceToArray(&surf, array, &desc); 
# 1145
} 
# 1166 "/usr/local/cuda/bin/..//include/cuda_runtime.h"
template< class T, int dim> inline cudaError_t 
# 1167
cudaBindSurfaceToArray(const surface< T, dim>  &
# 1168
surf, cudaArray_const_t 
# 1169
array) 
# 1171
{ 
# 1172
cudaChannelFormatDesc desc; 
# 1173
cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
# 1175
return (err == (cudaSuccess)) ? cudaBindSurfaceToArray(surf, array, desc) : err; 
# 1176
} 
# 1182
}
# 3 "test.cu"
int main() { 
# 4
return 0; 
# 5
} 

# 1 "test.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__12_test_cpp1_ii_main
# 1 "test.cudafe1.stub.c"
#include "test.cudafe1.stub.c"
# 1 "test.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE
